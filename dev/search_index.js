var documenterSearchIndex = {"docs":
[{"location":"API/Option/#FinanceModels.Option-API-Reference","page":"Option","title":"FinanceModels.Option API Reference","text":"","category":"section"},{"location":"API/Option/","page":"Option","title":"Option","text":"Modules = [FinanceModels.Option]","category":"page"},{"location":"API/Option/#Exported-API","page":"Option","title":"Exported API","text":"","category":"section"},{"location":"API/Option/","page":"Option","title":"Option","text":"Modules = [FinanceModels.Option]\nPrivate = false","category":"page"},{"location":"API/Option/#FinanceModels.Option","page":"Option","title":"FinanceModels.Option","text":"\n\n\n\n","category":"module"},{"location":"API/Option/#Unexported-API","page":"Option","title":"Unexported API","text":"","category":"section"},{"location":"API/Option/","page":"Option","title":"Option","text":"Modules = [FinanceModels.Option]\nPublic = false","category":"page"},{"location":"API/Option/#FinanceModels.Option.EuroCall","page":"Option","title":"FinanceModels.Option.EuroCall","text":"EuroCall(contract,strike,maturity)\n\nA European call option on the given contract with the given strike and maturity.\n\nArguments\n\ncontract::AbstractContract -  The underlying contract.\nstrike::Real -  The strike price.\nmaturity::Union{Real,Date} -  The maturity of the option.\n\nSupertype Hierarchy ≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡\n\nEuroCall{S,K,M} <: FinanceCore.AbstractContract <: Any\n\n\n\n\n\n","category":"type"},{"location":"API/Option/","page":"Option","title":"Option","text":"Please open an issue if you encounter any issues or confusion with the package.","category":"page"},{"location":"API/Fit/#FinanceModels.Fit-API-Reference","page":"Fit","title":"FinanceModels.Fit API Reference","text":"","category":"section"},{"location":"API/Fit/","page":"Fit","title":"Fit","text":"Modules = [FinanceModels.Fit]","category":"page"},{"location":"API/Fit/#Exported-API","page":"Fit","title":"Exported API","text":"","category":"section"},{"location":"API/Fit/","page":"Fit","title":"Fit","text":"Modules = [FinanceModels.Fit]\nPrivate = false","category":"page"},{"location":"API/Fit/#Unexported-API","page":"Fit","title":"Unexported API","text":"","category":"section"},{"location":"API/Fit/","page":"Fit","title":"Fit","text":"Modules = [FinanceModels.Fit]\nPublic = false","category":"page"},{"location":"API/Fit/#FinanceModels.Fit.Bootstrap","page":"Fit","title":"FinanceModels.Fit.Bootstrap","text":"Bootstrap()\n\nA singleton type which is passed to fit in order to bootstrap Splines. The curves are fit such that the spline passes through the zero rates of the curve. \n\nA subtype of FitMethod.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"API/Fit/#FinanceModels.Fit.Loss","page":"Fit","title":"FinanceModels.Fit.Loss","text":"Fit.Loss(function)\n\nfunction should be a loss measure, such as x->x^2 or x->abs(x). This is used by the optimization algorithm in fit to determine optimal parameters as defined by this loss function.\n\nA subtype of FitMethod.\n\nExamples\n\njulia> mod0 = Yield.Constant();\n\njulia> quotes = ZCBPrice([0.9, 0.8, 0.7,0.6]);\n\njulia> fit(mod0,quotes,Fit.Loss(x-x^2))\n\n              ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Yield Curve (FinanceModels.Yield.Constant)⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀           \n              ┌────────────────────────────────────────────────────────────┐           \n     0.120649 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ Zero rates\n              │⠀⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⣧⢰⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⣿⣾⠀⣀⣸⠀⢸⢳⣇⢀⣀⣀⣀⣀⣀⠀⡀⣀⣀⣀⡀⡀⣀⢀⣀⡀⡀⣀⢀⡀⣀⡀⢀⣀⡀⢀⡀⢀⣀⡀⢀⡀⠀⣀⡀⢀⡀⢀⣀⡀⢀⣀⠀⣀⡀⢀⣀⠀⢀│           \n              │⢠⢻⡟⡆⣿⡟⣦⠚⠀⢸⣾⠛⠛⠘⠛⠘⢲⡗⠛⠃⠛⠓⠓⠛⠚⠛⠑⠓⠛⠃⠓⠛⠑⠚⡟⠓⢻⡗⠚⠀⠓⠚⠑⠒⠃⠓⠚⠑⠚⠀⠓⠃⠘⠒⠃⠓⠃⠘⠒⠃│           \n              │⢸⢸⡇⢹⡏⠁⠉⠀⠀⠈⠉⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⠈⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n   Continuous │⢸⢸⡇⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⢸⠀⠁⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⢸⠀⠀⠘⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⡎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n     0.120649 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              └────────────────────────────────────────────────────────────┘           \n              ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀time⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀30⠀  \n\n\n\n\n\n\n","category":"type"},{"location":"API/Fit/","page":"Fit","title":"Fit","text":"Please open an issue if you encounter any issues or confusion with the package.","category":"page"},{"location":"contracts/#Contracts","page":"Contracts","title":"Contracts","text":"","category":"section"},{"location":"contracts/#**Contracts**-A-composable-way-to-represent-financial-instruments","page":"Contracts","title":"Contracts - A composable way to represent financial instruments","text":"","category":"section"},{"location":"contracts/","page":"Contracts","title":"Contracts","text":"Contracts are a composable way to represent financial instruments. They are, in essence, anything that is a collection of cashflows. Contracts can be combined to represent more complex instruments. For example, a bond can be represented as a collection of cashflows that correspond to the coupon payments and the principal repayment.","category":"page"},{"location":"contracts/","page":"Contracts","title":"Contracts","text":"Examples:","category":"page"},{"location":"contracts/","page":"Contracts","title":"Contracts","text":"a Cashflow\nBonds:\nBond.Fixed, Bond.Floating\nOptions:\nOption.EuroCall and Option.EuroPut \nCompositional contracts:\nForwardto represent an instrument that is relative to a forward point in time.\nComposite to represent the combination of two other instruments.  ","category":"page"},{"location":"contracts/","page":"Contracts","title":"Contracts","text":"In the future, this notion may be extended to liabilities (e.g. insurance policies in LifeContingencies.jl)","category":"page"},{"location":"contracts/#Cashflow-a-fundamental-financial-type","page":"Contracts","title":"Cashflow - a fundamental financial type","text":"","category":"section"},{"location":"contracts/","page":"Contracts","title":"Contracts","text":"Say you wanted to model a contract that paid quarterly payments, and those payments occurred starting 15 days from the valuation date (first payment time = 15/365 = 0.057)","category":"page"},{"location":"contracts/","page":"Contracts","title":"Contracts","text":"Previously, you had two options:","category":"page"},{"location":"contracts/","page":"Contracts","title":"Contracts","text":"Choose a discrete timestep to model (e.g. monthly, quarterly, annual) and then lump the cashflows into those timesteps. E.g. with monthly timesteps  of a unit payment of our contract, it might look like: [1,0,0,1,0,0...]\nKeep track of two vectors: one for the payment and one for the times. In this case, that might look like: cfs = [1,1,...];times = [0.057, 0.307...]","category":"page"},{"location":"contracts/","page":"Contracts","title":"Contracts","text":"The former has inaccuracies due to the simplified timing and logical complication related to mapping the contracts natural periodicity into an arbitrary modeling choice. The latter becomes unwieldy and fails to take advantage of Julia's type system. ","category":"page"},{"location":"contracts/","page":"Contracts","title":"Contracts","text":"The new solution: Cashflows. Our example above would become: [Cashflow(1,0.057), Cashflow(1,0.307),...]","category":"page"},{"location":"contracts/#Creating-a-new-Contract","page":"Contracts","title":"Creating a new Contract","text":"","category":"section"},{"location":"contracts/","page":"Contracts","title":"Contracts","text":"A contract is anything that creates a vector of Cashflows when collected. For example, let's create a bond which only pays down principle and offers no coupons.","category":"page"},{"location":"contracts/","page":"Contracts","title":"Contracts","text":"using FinanceModels,FinanceCore\n\n# Transducers is used to provide a more powerful, composible way to construct collections than the basic iteration interface\nusing Transducers: __foldl__, @next, complete\n\n\"\"\"\nA bond which pays down its par (one unit) in equal payments. \n\"\"\"\nstruct PrincipleOnlyBond{F<:FinanceCore.Frequency} <: FinanceModels.Bond.AbstractBond\n    frequency::F\n    maturity::Float64\nend\n\n# We extend the interface to say what should happen as the bond is projected\n# There's two parts to customize:\n# 1. any initialization or state to keep track of\n# 2. The loop where we decide what gets returned at each timestep\nfunction Transducers.__foldl__(rf, val, p::Projection{C,M,K}) where {C<:PrincipleOnlyBond,M,K}\n    # initialization stuff\n    b = p.contract # the contract within a projection\n    ts = Bond.coupon_times(b) # works since it's a FinanceModels.Bond.AbstractBond with a frequency and maturity\n    pmt = 1 / length(ts)\n\n    for t in ts\n        # the loop wich returns a value\n        cf = Cashflow(pmt, t)\n        val = @next(rf, val, cf) # the value to return is the last argument\n    end\n    return complete(rf, val)\nend","category":"page"},{"location":"contracts/","page":"Contracts","title":"Contracts","text":"That's it! then we can use this fitting models, projections, quotes, etc. Here we simply collect the bond into an array of cashflows:","category":"page"},{"location":"contracts/","page":"Contracts","title":"Contracts","text":"julia> PrincipleOnlyBond(Periodic(2),5.) |> collect\n10-element Vector{Cashflow{Float64, Float64}}:\n Cashflow{Float64, Float64}(0.1, 0.5)\n Cashflow{Float64, Float64}(0.1, 1.0)\n Cashflow{Float64, Float64}(0.1, 1.5)\n Cashflow{Float64, Float64}(0.1, 2.0)\n Cashflow{Float64, Float64}(0.1, 2.5)\n Cashflow{Float64, Float64}(0.1, 3.0)\n Cashflow{Float64, Float64}(0.1, 3.5)\n Cashflow{Float64, Float64}(0.1, 4.0)\n Cashflow{Float64, Float64}(0.1, 4.5)\n Cashflow{Float64, Float64}(0.1, 5.0)","category":"page"},{"location":"contracts/","page":"Contracts","title":"Contracts","text":"Note that all contracts in FinanceModels.jl are currently unit contracts in that they assume a unit par value. ","category":"page"},{"location":"contracts/#More-complex-Contracts","page":"Contracts","title":"More complex Contracts","text":"","category":"section"},{"location":"contracts/","page":"Contracts","title":"Contracts","text":"When the cashflow depends on a model. An example of this is a floating bond where the coupon paid depends on a view of forward rates. See this section in the overview on projections for how this is handled.","category":"page"},{"location":"contracts/#Available-Contracts-and-Modules","page":"Contracts","title":"Available Contracts & Modules","text":"","category":"section"},{"location":"contracts/","page":"Contracts","title":"Contracts","text":"See the Modules in the left navigation for details on available contracts/models/functions.","category":"page"},{"location":"models/#Models,-Valuation,-Projections,-and-Fitting","page":"Models, Valuation, and Fitting","title":"Models, Valuation, Projections, and Fitting","text":"","category":"section"},{"location":"models/#Introduction","page":"Models, Valuation, and Fitting","title":"Introduction","text":"","category":"section"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"Conceptually, we have an iterative process:","category":"page"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"We use models to value contracts\nWe use observed (or assumed) prices to calibrate models","category":"page"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"Thus the discussion of model calibration and valuation of contracts is inextricably linked together.","category":"page"},{"location":"models/#Yield-(Interest-Rate)-models","page":"Models, Valuation, and Fitting","title":"Yield (Interest Rate) models","text":"","category":"section"},{"location":"models/#Rates","page":"Models, Valuation, and Fitting","title":"Rates","text":"","category":"section"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"We should first discuss Rates, which are reexported from FinanceCore.jl","category":"page"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"Rates are types that wrap scalar values to provide information about how to determine discount and accumulation factors. These allow for explicit handling of rate compounding conventions which, if not explicit, is often a source of errors in practice.","category":"page"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"There are two Frequency types:","category":"page"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"Yields.Periodic(m) for rates that compound m times per period (e.g. m times per year if working with annual rates).\nYields.Continuous() for continuously compounding rates.","category":"page"},{"location":"models/#Examples","page":"Models, Valuation, and Fitting","title":"Examples","text":"","category":"section"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"Continuous(0.05)       # 5% continuously compounded\nPeriodic(0.05,2)       # 5% compounded twice per period","category":"page"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"These are both subtypes of the parent Rate type and are instantiated as:","category":"page"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"Rate(0.05,Continuous())       # 5% continuously compounded\nRate(0.05,Periodic(2))        # 5% compounded twice per period","category":"page"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"Broadcast over a vector to create Rates with the given compounding:","category":"page"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"Periodic.([0.02,0.03,0.04],2) \nContinuous.([0.02,0.03,0.04]) ","category":"page"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"Rates can also be constructed by specifying the CompoundingFrequency and then passing a scalar rate:","category":"page"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"Periodic(1)(0.05)\nContinuous()(0.05)","category":"page"},{"location":"models/#Conversion","page":"Models, Valuation, and Fitting","title":"Conversion","text":"","category":"section"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"Convert rates between different types with convert. E.g.:","category":"page"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"r = Rate(0.01,Periodic(12))             # rate that compounds 12 times per rate period (ie monthly)\n\nconvert(Yields.Periodic(1),r)                  # convert monthly rate to annual effective\nconvert(Yields.Continuous(),r)          # convert monthly rate to continuous","category":"page"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"To get the scalar value out of the Rate, use FinanceModels.rate(r):","category":"page"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"julia> r = Rate(0.01,Periodic(12));   \njulia> rate(r)\n0.01\n","category":"page"},{"location":"models/#Arithmetic","page":"Models, Valuation, and Fitting","title":"Arithmetic","text":"","category":"section"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"Adding, subtracting, multiplying, dividing, and comparing rates is supported.","category":"page"},{"location":"models/#Available-Models-Yields","page":"Models, Valuation, and Fitting","title":"Available Models - Yields","text":"","category":"section"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"FinanceModels.Yield.Constant\nBootstrapped Splines\nFinanceModels.Yield.SmithWilson\nFinanceModels.Yield.NelsonSiegel\nFinanceModels.Yield.NelsonSiegelSvensson","category":"page"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"Yield models can also be composed. Here is an example of fitting rates and spread separately and then adding the two models together:","category":"page"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"julia> q_rate = ZCBYield([0.01,0.02,0.03]);\n\njulia> q_spread = ZCBYield([0.01,0.01,0.01]);\n\njulia> m_rate = fit(Spline.Linear(),q_rate,Fit.Bootstrap());⠀           \n\njulia> m_spread = fit(Spline.Linear(),q_spread,Fit.Bootstrap());\n\njulia> forward(m_spread + m_rate,0,1)\nRate{Float64, Continuous}(0.01980262729617973, Continuous())\n\njulia> forward(m_spread + m_rate,0,1) |> Periodic(1)\nRate{Float64, Periodic}(0.020000000000000018, Periodic(1))\n\njulia> discount(m_spread + m_rate,0,3)\n0.8889963586709149\n\njulia> discount(0.04,3)\n0.8889963586709148","category":"page"},{"location":"models/#Creating-New-Yield-Models","page":"Models, Valuation, and Fitting","title":"Creating New Yield Models","text":"","category":"section"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"See the FinanceModels.jl Guide for an example of creating a model from scratch. Some additional aspects to note:","category":"page"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"The only method that must be defined to calculate the FinanceCore.present_value of something is FinanceCore.discount. Other methods will be inferred.\nOther methods that are imputed by default, but can be extended include: FinanceCore.accumulation, FinanceModels.forward, FinanceModels.par, FinanceModels.zero, and FinanceModels.rate.","category":"page"},{"location":"models/#Equity-and-Volatility-Models","page":"Models, Valuation, and Fitting","title":"Equity and Volatility Models","text":"","category":"section"},{"location":"models/#Available-Models-Option-Valuation","page":"Models, Valuation, and Fitting","title":"Available Models - Option Valuation","text":"","category":"section"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"FinanceModels.Equity.BlackScholesMerton","category":"page"},{"location":"models/#Available-Models-Volatility","page":"Models, Valuation, and Fitting","title":"Available Models - Volatility","text":"","category":"section"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"FinanceModels.Volatility.Constant","category":"page"},{"location":"models/#Creating-new-Volatility-Models","page":"Models, Valuation, and Fitting","title":"Creating new Volatility Models","text":"","category":"section"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"A volatility model must extend volatility(vol::Volatility.MyNewModel, strike_ratio, time_to_maturity).","category":"page"},{"location":"API/Yield/#FinanceModels.Yield-API-Reference","page":"Yield","title":"FinanceModels.Yield API Reference","text":"","category":"section"},{"location":"API/Yield/","page":"Yield","title":"Yield","text":"Modules = [FinanceModels.Yield]","category":"page"},{"location":"API/Yield/#Exported-API","page":"Yield","title":"Exported API","text":"","category":"section"},{"location":"API/Yield/","page":"Yield","title":"Yield","text":"Modules = [FinanceModels.Yield]\nPrivate = false","category":"page"},{"location":"API/Yield/#Base.zero-Union{Tuple{YC}, Tuple{YC, Any}} where YC<:FinanceModels.Yield.AbstractYieldModel","page":"Yield","title":"Base.zero","text":"zero(curve,time)\n\nReturn the zero rate for the curve at the given time.\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#FinanceCore.discount-Union{Tuple{T}, Tuple{T, Any, Any}} where T<:FinanceModels.Yield.AbstractYieldModel","page":"Yield","title":"FinanceCore.discount","text":"discount(yc, to)\ndiscount(yc, from,to)\n\nThe discount factor for the yield curve yc for times from through to.\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#FinanceCore.forward-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T<:FinanceModels.Yield.AbstractYieldModel","page":"Yield","title":"FinanceCore.forward","text":"forward(yc, from, to)˚\n\nThe forward Rate implied by the yield curve yc between times from and to.\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#FinanceModels.Yield.par-Tuple{Any, Any}","page":"Yield","title":"FinanceModels.Yield.par","text":"par(curve,time;frequency=2)\n\nCalculate the par yield for maturity time for the given curve and frequency. Returns a Rate object with periodicity corresponding to the frequency. The exception to this is if time is less than what the payments allowed by frequency (e.g. a time 0.5 but with frequency 1) will effectively assume frequency equal to 1 over time.\n\nExamples\n\njulia> c = Yields.Constant(0.04);\n\njulia> Yields.par(c,4)\nYields.Rate{Float64, Yields.Periodic}(0.03960780543711406, Yields.Periodic(2))\n\njulia> Yields.par(c,4;frequency=1)\nYields.Rate{Float64, Yields.Periodic}(0.040000000000000036, Yields.Periodic(1))\n\njulia> Yields.par(c,0.6;frequency=4)\nYields.Rate{Float64, Yields.Periodic}(0.039413626195875295, Yields.Periodic(4))\n\njulia> Yields.par(c,0.2;frequency=4)\nYields.Rate{Float64, Yields.Periodic}(0.039374942589460726, Yields.Periodic(5))\n\njulia> Yields.par(c,2.5)\nYields.Rate{Float64, Yields.Periodic}(0.03960780543711406, Yields.Periodic(2))\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#Unexported-API","page":"Yield","title":"Unexported API","text":"","category":"section"},{"location":"API/Yield/","page":"Yield","title":"Yield","text":"Modules = [FinanceModels.Yield]\nPublic = false","category":"page"},{"location":"API/Yield/#FinanceModels.Yield.CompositeYield","page":"Yield","title":"FinanceModels.Yield.CompositeYield","text":"CompositeYield(curve1,curve2,operation)\n\nCreates a datastructure that will perform the given operation after independently calculating the effects of the two curves.  Can only be created via the public API by using the +, -, *, and / operatations on AbstractYield objects.\n\nAs this is double the normal operations when performing calculations, if you are using the curve in performance critical locations, you should consider transforming the inputs and  constructing a single curve object ahead of time.\n\n\n\n\n\n","category":"type"},{"location":"API/Yield/#FinanceModels.Yield.Constant","page":"Yield","title":"FinanceModels.Yield.Constant","text":"Constant(rate)\n\nA yield curve representing a flat term structure. rate can be a Rate object or a Real object.\n\nIf fiting with the default FinanceModels.jl settings, the solver will attempt to fit a discount rate with the range of: -1.0 .. 1.0\n\n\n\n\n\n","category":"type"},{"location":"API/Yield/#FinanceModels.Yield.ForwardStarting","page":"Yield","title":"FinanceModels.Yield.ForwardStarting","text":"ForwardStarting(curve,forwardstart)\n\nRebase a curve so that discount/accumulation/etc. are re-based so that time zero from the new curves perspective is the given forwardstart time.\n\nExamples\n\njulia> zero = [5.0, 5.8, 6.4, 6.8] ./ 100\njulia> maturity = [0.5, 1.0, 1.5, 2.0]\njulia> curve = Yields.Zero(zero, maturity)\njulia> fwd = Yields.ForwardStarting(curve, 1.0)\n\njulia> FinanceCore.discount(curve,1,2)\n0.9275624570410582\n\njulia> FinanceCore.discount(fwd,1) # `curve` has effectively been reindexed to `1.0`\n0.9275624570410582\n\nExtended Help\n\nWhile ForwardStarting could be nested so that, e.g. the third period's curve is the one-period forward of the second period's curve, it will be more efficient to reuse the initial curve from a runtime and compiler perspective.\n\nForwardStarting is not used to construct a curve based on forward rates. \n\n\n\n\n\n","category":"type"},{"location":"API/Yield/#FinanceModels.Yield.NelsonSiegel","page":"Yield","title":"FinanceModels.Yield.NelsonSiegel","text":"NelsonSiegel(β₀, β₁, β₂, τ₁)\nNelsonSiegel(τ₁=1.0) # used in fitting\n\nA Nelson-Siegel yield curve model  Parameters of Nelson and Siegel (1987) parametric model, along with default parameter ranges used in the fitting:\n\nβ₀ represents a long-term interest rate: -10.0 .. 10.0\nβ₁ represents a time-decay component: -10.0 .. 10.0\nβ₂ represents a hump: -10.0 .. 10.0\nτ₁ controls the location of the hump: 0.0 .. 100.0\n\nExamples\n\njulia> β₀, β₁, β₂, τ₁ = 0.6, -1.2, -1.9, 3.0\njulia> nsm = Yields.NelsonSiegel.(β₀, β₁, β₂, τ₁)\n\n# Extended Help\n\nNelsonSiegel has generally been replaced by NelsonSiegelSvensson, which is a more flexible model.\n\n## References\n- https://onriskandreturn.com/2019/12/01/nelson-siegel-yield-curve-model/\n- https://www.bis.org/publ/bppdf/bispap25.pdf\n\n\n\n\n\n\n","category":"type"},{"location":"API/Yield/#FinanceModels.Yield.NelsonSiegelSvensson","page":"Yield","title":"FinanceModels.Yield.NelsonSiegelSvensson","text":"NelsonSiegelSvensson(τ₁, τ₂, β₀, β₁, β₂, β₃)\nNelsonSiegelSvensson(τ₁=1.0, τ₂=1.0)\n\nReturn the NelsonSiegelSvensson yield curve. The rates should be continuous zero spot rates. If rates are not Rates, then they will be interpreted as Continuous Rates.\n\nParameters of Svensson (1994) parametric model, along with the default parameter bounds used in the fit routine:\n\nτ₁ controls the location of the hump: 0.0 .. 100.0\nτ₁ controls the location of the second hump: 0.0 .. 100.0\nβ₀ represents a long-term interest rate: -10.0 .. 10.0\nβ₁ represents a time-decay component: -10.0 .. 10.0\nβ₂ represents a hump: -10.0 .. 10.0\nβ₃ represents a second hump: -10.0 .. 10.0\n\nExamples\n\njulia> β₀, β₁, β₂, β₃, τ₁, τ₂ = 0.6, -1.2, -2.1, 3.0, 1.5\njulia> nssm = NelsonSiegelSvensson.NelsonSiegelSvensson.(β₀, β₁, β₂, β₃, τ₁, τ₂)\n\n# Extended Help\n\nNelson-Siegel-Svensson Pros:\n\n- Simplicity: With only six parameters, the model is quite parsimonious and easy to estimate. It's also easier to interpret and communicate than more complex models.\n- Economic Interpretability: Each of the model's components can be given an economic interpretation, with parameters representing long term rate, short term rate, the rates of decay towards the long term rate, and humps in the yield curve.\n\nNelson-Siegel-Svensson Cons:\n\n- Unusual Curves: NSS makes some assumptions about the shape of the yield curve (e.g. generally has a hump in short to medium term maturities). It might not be the best choice for fitting unusual curves.\n- Arbitrage Opportunities: The NSS model does not guarantee absence of arbitrage opportunities. More sophisticated models, like the ones based on no-arbitrage conditions, might provide better pricing accuracy in some contexts.\n- Sensitivity: Similar inputs may produce different parameters due to the highly convex, non-linear region to solve for the parameters. Entities like the ECB will partially mitigate this by using the prior business day's parameters as the starting point for the current day's yield curve.\n\n## References\n- https://onriskandreturn.com/2019/12/01/nelson-siegel-yield-curve-model/\n- https://www.bis.org/publ/bppdf/bispap25.pdf\n\n\n\n\n\n\n","category":"type"},{"location":"API/Yield/#FinanceModels.Yield.SmithWilson","page":"Yield","title":"FinanceModels.Yield.SmithWilson","text":"Yield.SmithWilson(u, qb; ufr=ufr, α=α)\nYield.SmithWilson(;ufr=ufr, α=α)\n\nCreate a yield curve object that implements the Smith-Wilson interpolation/extrapolation scheme.\n\nTo calibrate a curve, you generally want to construct the object without the u and qb arguments and call fit in conjunction with Quotes (fit requires no third parameter for SmithWilson curves). See Examples for what this looks like.  Positional arguments to construct a curve:\n\nA curve can be with u is the timepoints coming from the calibration, and qb is the internal parameterization of the curve that ensures that the calibration is correct. Users may prefer the other constructors but this mathematical constructor is also available.\n\nRequired keyword arguments:\n\nufr is the Ultimate Forward Rate, the forward interest rate to which the yield curve tends, in continuous compounding convention. \nα is the parameter that governs the speed of convergence towards the Ultimate Forward Rate. It can be typed with \\alpha[TAB]\n\nExamples\n\ntimes = [1.0, 2.5, 5.6]\nprices = [0.9, 0.7, 0.5]\nqs = ZCBPrice.(prices, times)\n\nufr = 0.03\nα = 0.1\n\nmodel = fit(Yield.SmithWilson(ufr=ufr, α=α), qs)\n\nExtended Help\n\nReferences\n\nSmith-Wilson Yields Curves\nA Technical Note on the Smith-Wilson Method\n\n\n\n\n\n","category":"type"},{"location":"API/Yield/#Base.:*-Tuple{FinanceModels.Yield.AbstractYieldModel, FinanceModels.Yield.AbstractYieldModel}","page":"Yield","title":"Base.:*","text":"Yields.AbstractYieldModel * Yields.AbstractYieldModel\n\nThe multiplication of two yields will create a CompositeYield. For rate, discount, and accumulation purposes the spot rates of the two curves will be added together. This can be useful, for example, if you wanted to after-tax a yield.\n\nExamples\n\njulia> m = Yields.Constant(0.01) * 0.79;\n\njulia> accumulation(m,1)\n1.0079\n\njulia> accumulation(.01*.79,1)\n1.0079\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#Base.:+-Tuple{FinanceModels.Yield.AbstractYieldModel, FinanceModels.Yield.AbstractYieldModel}","page":"Yield","title":"Base.:+","text":"Yields.AbstractYieldModel + Yields.AbstractYieldModel\n\nThe addition of two yields will create a CompositeYield. For rate, discount, and accumulation purposes the spot rates of the two curves will be added together.\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#Base.:--Tuple{FinanceModels.Yield.AbstractYieldModel, FinanceModels.Yield.AbstractYieldModel}","page":"Yield","title":"Base.:-","text":"Yields.AbstractYieldModel - Yields.AbstractYieldModel\n\nThe subtraction of two yields will create a CompositeYield. For rate, discount, and accumulation purposes the spot rates of the second curves will be subtracted from the first.\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#Base.:/-Tuple{FinanceModels.Yield.AbstractYieldModel, FinanceModels.Yield.AbstractYieldModel}","page":"Yield","title":"Base.:/","text":"Yields.AbstractYieldModel / Yields.AbstractYieldModel\n\nThe division of two yields will create a CompositeYield. For rate, discount, and accumulation purposes the spot rates of the two curves will have the first divided by the second. This can be useful, for example, if you wanted to gross-up a yield to be pre-tax.\n\nExamples\n\njulia> m = Yields.Constant(0.01) / 0.79;\n\njulia> accumulation(d,1)\n1.0126582278481013\n\njulia> accumulation(.01/.79,1)\n1.0126582278481013\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#FinanceCore.accumulation-Tuple{FinanceModels.Yield.AbstractYieldModel, Any}","page":"Yield","title":"FinanceCore.accumulation","text":"accumulation(yc, from, to)\n\nThe accumulation factor for the yield curve yc for times from through to.\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#FinanceModels.Yield.H-Union{Tuple{T}, Tuple{Any, T, T}} where T","page":"Yield","title":"FinanceModels.Yield.H","text":"H(α, t1, t2)\n\nThe Smith-Wilson H function implemented in a faster way.\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#FinanceModels.Yield.H_ordered-Tuple{Any, Any, Any}","page":"Yield","title":"FinanceModels.Yield.H_ordered","text":"H_ordered(α, t_min, t_max)\n\nThe Smith-Wilson H function with ordered arguments (for better performance than using min and max).\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/","page":"Yield","title":"Yield","text":"Please open an issue if you encounter any issues or confusion with the package.","category":"page"},{"location":"API/Bond/#FinanceModels.Bond-API-Reference","page":"Bond","title":"FinanceModels.Bond API Reference","text":"","category":"section"},{"location":"API/Bond/","page":"Bond","title":"Bond","text":"Modules = [FinanceModels.Bond]","category":"page"},{"location":"API/Bond/#Exported-API","page":"Bond","title":"Exported API","text":"","category":"section"},{"location":"API/Bond/","page":"Bond","title":"Bond","text":"Modules = [FinanceModels.Bond]\nPrivate = false","category":"page"},{"location":"API/Bond/#FinanceModels.Bond","page":"Bond","title":"FinanceModels.Bond","text":"The Bond module provide a number of fixed-income contracts and related methods.\n\n\n\n\n\n","category":"module"},{"location":"API/Bond/#FinanceModels.Bond.CMTYield-Tuple{Any, Any}","page":"Bond","title":"FinanceModels.Bond.CMTYield","text":"CMTYield(yield,maturity)\nCMTYield(yield::Vector)\n\nReturns a Quote for the correpsonding bond implied by the given bond equivalent yield, and assumes that instruments <= one year maturity` pay no coupons and that the rest pay semi-annual.\n\nUse broadcasting to create a set of quotes given a collection of FinanceModels and maturities, e.g. CMTYield.(FinanceModels,maturities).\n\nSee also FinanceCore.Quote, Bond.Fixed\n\nExamples\n\njulia> CMTYield(0.05,10)\nQuote{Float64, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}}(1.0, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}(0.05, Periodic(2), 10))\n\n\n\n\n\n","category":"method"},{"location":"API/Bond/#FinanceModels.Bond.ParSwapYield-Tuple{Any, Any}","page":"Bond","title":"FinanceModels.Bond.ParSwapYield","text":"ParSwapYield(yield, maturity; frequency=Periodic(4))\n\nSame as ParYield, except the frequency is four times per period by default.\n\n\n\n\n\n","category":"method"},{"location":"API/Bond/#FinanceModels.Bond.ParYield-Tuple{Any, Any}","page":"Bond","title":"FinanceModels.Bond.ParYield","text":"ParYield(yield, maturity; frequency=Periodic(2)) ParYield(yield::Vector)\n\nTakes bond equivalent FinanceModels, and assumes that instruments <= one year maturity pay no coupons and that the rest pay semi-annual. Alternative, you may pass a Rate as the yield and the coupon frequency will be inferred from the Rate's frequency. \n\nUse broadcasting to create a set of quotes given a collection of FinanceModels and maturities, e.g. ParYield.(FinanceModels,maturities).\n\nExamples\n\njulia> ParYield(0.05,10)\nQuote{Float64, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}}(1.0, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}(0.05, Periodic(2), 10))\n\n\n\n\n\n","category":"method"},{"location":"API/Bond/#FinanceModels.Bond.ZCBPrice-Tuple{Any, Any}","page":"Bond","title":"FinanceModels.Bond.ZCBPrice","text":"ZCBPrice(discount,maturity)\nZCBPrice(yield::Vector)\n\nTakes spot/zero discount factors and returns a Quote for the cashflow occuring at the given maturity.\n\nUse broadcasting to create a set of quotes given a collection of prices and maturities, e.g. ZCBPrice.(FinanceModels,maturities).\n\nSee also ZCBYield\n\nExamples\n\n\njulia> ZCBPrice(0.5,10)\nQuote{Float64, Cashflow{Float64, Int64}}(0.5, Cashflow{Float64, Int64}(1.0, 10))\n\njulia> ZCBPrice([0.9,0.8,0.75])\n3-element Vector{Quote{Float64, Cashflow{Float64, Int64}}}:\n Quote{Float64, Cashflow{Float64, Int64}}(0.9, Cashflow{Float64, Int64}(1.0, 1))\n Quote{Float64, Cashflow{Float64, Int64}}(0.8, Cashflow{Float64, Int64}(1.0, 2))\n Quote{Float64, Cashflow{Float64, Int64}}(0.75, Cashflow{Float64, Int64}(1.0, 3))\n \n\n\n\n\n\n","category":"method"},{"location":"API/Bond/#FinanceModels.Bond.ZCBYield-Tuple{Any, Any}","page":"Bond","title":"FinanceModels.Bond.ZCBYield","text":"ZCBYield(yield,maturity)\nZCBYield(yield::Vector)\n\nReturns a Quote for the cashflow occuring at the given maturity and the quoted value is derived from the given yield.\n\nTakes zero (sometimes called \"spot\") rates. Assumes annual effective compounding (Periodic(1)) unless given aRate` with a different compounding frequency.\n\nUse broadcasting to create a set of quotes given a collection of FinanceModels and maturities, e.g. ZCBYield.(FinanceModels,maturities).\n\nSee also ZCBPrice\n\nExamples\n\njulia> ZCBYield(0.05,30)\nQuote{Float64, Cashflow{Float64, Int64}}(0.23137744865585788, Cashflow{Float64, Int64}(1.0, 30))\n\njulia> ZCBYield(Periodic(0.05,1),30)\nQuote{Float64, Cashflow{Float64, Int64}}(0.23137744865585788, Cashflow{Float64, Int64}(1.0, 30))\n\njulia> ZCBYield(Continuous(0.05),30)\nQuote{Float64, Cashflow{Float64, Int64}}(0.22313016014842982, Cashflow{Float64, Int64}(1.0, 30))\n\njulia> ZCBYield([0.04,0.05,0.045])\n3-element Vector{Quote{Float64, Cashflow{Float64, Int64}}}:\n Quote{Float64, Cashflow{Float64, Int64}}(0.9615384615384615, Cashflow{Float64, Int64}(1.0, 1))\n Quote{Float64, Cashflow{Float64, Int64}}(0.9070294784580498, Cashflow{Float64, Int64}(1.0, 2))\n Quote{Float64, Cashflow{Float64, Int64}}(0.8762966040549094, Cashflow{Float64, Int64}(1.0, 3))\n\n\n\n\n\n","category":"method"},{"location":"API/Bond/#Unexported-API","page":"Bond","title":"Unexported API","text":"","category":"section"},{"location":"API/Bond/","page":"Bond","title":"Bond","text":"Modules = [FinanceModels.Bond]\nPublic = false","category":"page"},{"location":"API/Bond/#FinanceModels.Bond.Fixed","page":"Bond","title":"FinanceModels.Bond.Fixed","text":"Bond.Fixed(coupon_rate,frequency<:FinanceCore.Frequency,maturity)\n\nAn object representing a fixed coupon bond. coupon_rate / frequency is the actual payment amount.\n\nNote that there are a number of convienience constructors which return a Quote for a Bond.Fixed: \n\nParYield\nParSwapYield\nCMTYield\nOISYield\n\nSee also FinanceCore.Quote.\n\nExamples\n\njulia> Bond.Fixed(0.05,Periodic(2),3)\nFinanceModels.Bond.Fixed{Periodic, Float64, Int64}(0.05, Periodic(2), 3)\n\njulia> Bond.Fixed(0.05,Periodic(2),3) |> collect\n6-element Vector{Cashflow{Float64, Float64}}:\n Cashflow{Float64, Float64}(0.025, 0.5)\n Cashflow{Float64, Float64}(0.025, 1.0)\n Cashflow{Float64, Float64}(0.025, 1.5)\n Cashflow{Float64, Float64}(0.025, 2.0)\n Cashflow{Float64, Float64}(0.025, 2.5)\n Cashflow{Float64, Float64}(1.025, 3.0)\n\n\njulia> ParYield(0.05,10)\nQuote{Float64, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}}(1.0, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}(0.05, Periodic(2), 10))\n\n\n\n\n\n","category":"type"},{"location":"API/Bond/#FinanceModels.Bond.Floating","page":"Bond","title":"FinanceModels.Bond.Floating","text":"Bond.Floating(coupon_rate,frequency<:FinanceCore.Frequency,maturity,model_key)\n\nAn object representing a floating coupon bond. (coupon_rate + reference rate) / frequency is the actual payment amount, where the reference rate requires a Projection with a key/value pair where the key is the model_key argument and the value is the model which produces the reference rate.\n\nSee also FinanceCore.Quote.\n\nExamples\n\njulia> p = Projection(\n        Bond.Floating(0.02, Periodic(1), 3.0, \"SOFR\"),\n        Dict(\"SOFR\" => Yield.Constant(0.05)),  # note the key/value store used for the model in the projection\n        CashflowProjection(),\n    );\n\njulia> collect(p)\n3-element Vector{Cashflow{Float64, Float64}}:\n    Cashflow{Float64, Float64}(0.07000000000000005, 1.0)\n    Cashflow{Float64, Float64}(0.07000000000000005, 2.0)\n    Cashflow{Float64, Float64}(1.07, 3.0)\n\n\n\n\n\n","category":"type"},{"location":"API/Bond/#FinanceModels.Bond.ForwardYields","page":"Bond","title":"FinanceModels.Bond.ForwardYields","text":"ForwardYields(yields,times)\n\nReturns a vector of Quote corresponding to the yield at the given forward times. \n\nExamples\n\njulia> FinanceModels.Bond.ForwardYields([0.01,0.02],[1.,3.])\n2-element Vector{Quote{Float64, Cashflow{Float64, Float64}}}:\n Quote{Float64, Cashflow{Float64, Float64}}(0.9900990099009901, Cashflow{Float64, Float64}(1.0, 1.0))\n Quote{Float64, Cashflow{Float64, Float64}}(0.9423223345470445, Cashflow{Float64, Float64}(1.0, 3.0))\n\n\n\n\n\n","category":"function"},{"location":"API/Bond/#FinanceModels.Bond.OISYield-Tuple{Any, Any}","page":"Bond","title":"FinanceModels.Bond.OISYield","text":"OISYield(yield, maturity)\n\nReturns the implied Quote for the fixed bond implied by the given yield and maturity. Assumes that maturities less than or equal to 12 months are settled once (per Hull textbook, 4.7), otherwise quarterly and that the FinanceModels given are bond equivalent.\n\nUse broadcasting to create a set of quotes given a collection of FinanceModels and maturities, e.g. OISYield.(FinanceModels,maturities).\n\nSee also FinanceCore.Quote, Bond.Fixed\n\nExamples\n\njulia> OISYield(0.05,10)\nQuote{Float64, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}}(1.0, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}(0.05, Periodic(4), 10))\n\n\n\n\n\n","category":"method"},{"location":"API/Bond/#FinanceModels.Bond.coupon_times-Tuple{Any, Any}","page":"Bond","title":"FinanceModels.Bond.coupon_times","text":"coupon_times(maturity, frequency)\n\nGenerate coupon times for a bond with the given maturity and frequency.\n\nArguments\n\nmaturity::Real: The maturity of the bond.\nfrequency::Real: The coupon frequency of the bond.\n\nReturns\n\nAn array of coupon times for the bond.\n\nExamples\n\njulia-repl julia> Bond.coupon_times(10, 2) 0.5:0.5:10.0 julia> Bond.coupon_times(Bond.Fixed(0.05,Periodic(4),20)) 0.25:0.25:20.0`\n\n\n\n\n\n","category":"method"},{"location":"API/Bond/","page":"Bond","title":"Bond","text":"Please open an issue if you encounter any issues or confusion with the package.","category":"page"},{"location":"API/FinanceModels/#FinanceModels-API-Reference","page":"FinanceModels","title":"FinanceModels API Reference","text":"","category":"section"},{"location":"API/FinanceModels/","page":"FinanceModels","title":"FinanceModels","text":"Modules = [FinanceModels]","category":"page"},{"location":"API/FinanceModels/#Exported-API","page":"FinanceModels","title":"Exported API","text":"","category":"section"},{"location":"API/FinanceModels/","page":"FinanceModels","title":"FinanceModels","text":"Modules = [FinanceModels]\nPrivate = false","category":"page"},{"location":"API/FinanceModels/#FinanceModels.CashflowProjection","page":"FinanceModels","title":"FinanceModels.CashflowProjection","text":"CashflowProjection()\n\nA concrete subtype of ProjectionKind which is the projection which returns only a reducible collection of Cashflows. Use in conjunction with a Projection.\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceModels/#FinanceModels.CommonEquity","page":"FinanceModels","title":"FinanceModels.CommonEquity","text":"CommonEquity()\n\nA singleton type representing a unit stock.\n\nSee also: Option.\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceModels/#FinanceModels.Forward","page":"FinanceModels","title":"FinanceModels.Forward","text":"Forward(time,instrument)\n\nThe instrument is relative to the Forward time. e.g. if you have a Forward(1.0, Cashflow(1.0, 3.0)) then the instrument is a cashflow that pays 1.0 at time 4.0\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceModels/#FinanceModels.NullModel","page":"FinanceModels","title":"FinanceModels.NullModel","text":"NullModel()\n\nA singleton type representing a placeholder model for when you don't really need a model. For example: determining nominal cashflows for fixed income contract.\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceModels/#FinanceModels.Projection","page":"FinanceModels","title":"FinanceModels.Projection","text":"Projection(contract,model,kind)\n\nThe set of contracts and assumptions (model) to project the kind of output desired. Some assets require a projection in order to be valued (e.g. a floating rate bond).\n\nIf attempting to collect or otherwise reduce a contract (<:AbstractContract), by default it will get wrapped into a Projection(contract,NullModel(),CashflowProjection())\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceModels/#FinanceCore.present_value","page":"FinanceModels","title":"FinanceCore.present_value","text":"present_value(model,contract,current_time=0.0)\n\nReturn the value of the contract as corresponding with the valuation assumptions embedded in the model.\n\nExamples\n\nm = Equity.BlackScholesMerton(0.01, 0.02, 0.15)\n\na = Option.EuroCall(CommonEquity(), 1.0, 1.0)\n\npv(m, a) # ≈ 0.05410094201902403\n\n\n\n\n\n","category":"function"},{"location":"API/FinanceModels/#FinanceModels.fit-Union{Tuple{F}, Tuple{Any, Any}, Tuple{Any, Any, F}} where F<:FinanceModels.Fit.Loss","page":"FinanceModels","title":"FinanceModels.fit","text":"fit(\n    model, \n    quotes, \n    method=Fit.Loss(x -> x^2);\n    variables=__default_optic(model), \n    optimizer=__default_optim(model)\n    )\n\nFit a model to a collection of quotes using a loss function and optimization method.\n\nArguments\n\nmodel: The initial model to fit, which is generally an instantiated but un-optimized model.\nquotes: A collection of quotes to fit the model to.\nmethod::F=Fit.Loss(x -> x^2): The loss function to use for fitting the model. Defaults to the squared loss function. \nmethod can also be Bootstrap(). If this is the case, model should be a spline such as Spline.Linear(), Spline.Cubic()...\nvariables=__default_optic(model): The variables to optimize over. This is an optic specifying which parameters of the modle can vary. See extended help for more.\noptimizer=__default_optim(model): The optimization algorithm to use. The default optimization for a given model is ECA from Metahueristics.jl; see extended help for more on customizing the solver including setting the seed.\n\nThe optimization routine will then attempt to modify parameters of model to best fit the quoted prices of the contracts underlying the quotes by calling present_value(model,contract). The optimization will minimize the loss function specified within Fit.Loss(...). \n\nDifferent types of quotes are appropriate for different kinds of models. For example, if you try to value a set of equtiy EuroCalls with a Yield.Constant, you will get an error because the present_value(m<:Yield.Constant,o<:EuroCall) is not defined.\n\nReturns\n\nThe fitted model.\n\nExamples\n\njulia> model = Yield.Constant();\n\njulia> quotes = ZCBPrice([0.9, 0.8, 0.7,0.6]);\n\njulia> fit(model,quotes)\n\n              ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Yield Curve (FinanceModels.Yield.Constant)⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀           \n              ┌────────────────────────────────────────────────────────────┐           \n     0.120649 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ Zero rates\n              │⠀⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⣧⢰⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⣿⣾⠀⣀⣸⠀⢸⢳⣇⢀⣀⣀⣀⣀⣀⠀⡀⣀⣀⣀⡀⡀⣀⢀⣀⡀⡀⣀⢀⡀⣀⡀⢀⣀⡀⢀⡀⢀⣀⡀⢀⡀⠀⣀⡀⢀⡀⢀⣀⡀⢀⣀⠀⣀⡀⢀⣀⠀⢀│           \n              │⢠⢻⡟⡆⣿⡟⣦⠚⠀⢸⣾⠛⠛⠘⠛⠘⢲⡗⠛⠃⠛⠓⠓⠛⠚⠛⠑⠓⠛⠃⠓⠛⠑⠚⡟⠓⢻⡗⠚⠀⠓⠚⠑⠒⠃⠓⠚⠑⠚⠀⠓⠃⠘⠒⠃⠓⠃⠘⠒⠃│           \n              │⢸⢸⡇⢹⡏⠁⠉⠀⠀⠈⠉⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⠈⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n   Continuous │⢸⢸⡇⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⢸⠀⠁⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⢸⠀⠀⠘⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⡎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n     0.120649 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              └────────────────────────────────────────────────────────────┘           \n              ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀time⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀30⠀  \n\n\nExtended help\n\nCustomizing the Solver\n\nThe default solver is ECA() from Metahueristics.jl. This is a stochastic global optimizer which will run with a random seed by default.\n\nTo make the seed static, you can specify the kwarg to fit with a customized ECA: e.g. fit(...;optimizer=ECA(seed=123))\nA number of options are available for ECA() or you may specify a different solver.\nMore documentation is available from the upstream packages:\nMetaheuristics.jl\nOptimization.jl\nAccessibleOptimization.jl\n\nDefining the variables\n\nAn arbitrarily complex model may be the object we intend to fit - how does fit know what free variables are able to be solved for within the given model? variables is a singlular or vector optic argument. What does this mean?\n\nAn optic (or \"lens\") is a way to define an accessor to a given object. Example:\n\njulia> using Accessors, AccessibleOptimization, IntervalSets\n\njulia> obj = (a = \"AA\", b = \"BB\");\n\njulia> lens = @optic _.a\n(@optic _.a)\n\njulia> lens(obj)\n\"AA\"\n\nAn optic argument is a singular or vector of lenses with an optional range of acceptable parameters. For example, we might have a model as follows where we want  fit to optize parameters a and b:\n\nstruct MyModel <:FinanceModels.AbstractModel\n     a \n     b \nend\n\n__default_optic(m::MyModel) = OptArgs([\n    @optic(_.a) => 0.0 .. 100.0,\n    @optic(_.b) => -10.0 .. 10.0,\n]...)\n\nIn this way, fit know which arbitrary parameters in a given object may be modified. Technically, we are not modifying the immutable MyModel, but instead efficiently creating a new instance. This is enabled by AccessibleOptimization.jl.\n\nNote that not all opitmization algorithms want a bounded interval. In that case, simply leave off the paired range. The prior example would then become:\n\n__default_optic(m::MyModel) = OptArgs([\n    @optic(_.a),\n    @optic(_.b),\n]...)\n\n```\n\nAdditional Examples\n\nSee the tutorials in the package documentation for FinanceModels.jl or the docstrings of FinanceModels.jl's avaiable model types.\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceModels/#Unexported-API","page":"FinanceModels","title":"Unexported API","text":"","category":"section"},{"location":"API/FinanceModels/","page":"FinanceModels","title":"FinanceModels","text":"Modules = [FinanceModels]\nPublic = false","category":"page"},{"location":"API/FinanceModels/#FinanceModels.ProjectionKind","page":"FinanceModels","title":"FinanceModels.ProjectionKind","text":"abstract type ProjectionKind\n\nAn abstract type that controls what gets produced from the model.\n\nSubtypes of ProjectionKind define the level of detail in the output of the model. For example, if you just want cashflows or you want a full amortization schedule, you might define an AmortizationSchedule kind which shows principle, interest, etc.\n\nAfter defining a new ProjectionKind, you need to define the how the projection works for that new output by extending either:\n\nfunction Transducers.asfoldable(p::Projection{C,M,K}) where {C<:Cashflow,M,K<:CashflowProjection}\n    ...\nend\n\nor \n\nfunction Transducers.__foldl__(rf, val, p::Projection{C,M,K}) where {C<:Cashflow,M,K<:CashflowProjection}\n    ...\nend\n\nThere are examples of this in the documentation.\n\nExamples\n\n```julia julia> struct CashflowProjection <: ProjectionKind end CashflowProjection\n\njulia> struct AmortizationSchedule <: ProjectionKind end AmortizationSchedule\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceModels/#FinanceModels.__default_optic-Tuple{FinanceModels.Yield.Constant}","page":"FinanceModels","title":"FinanceModels.__default_optic","text":"__default_optic(model)\n\nReturns the variables to optimize over for the given model. This is an optic/lens specifying which parameters of the modle can vary. See extended help for more. An optic argument is a singular or vector of lenses with an optional range of acceptable parameters.\n\nExamples\n\nWe might have a model as follows where we want fit to optize parameters a and b:\n\nstruct MyModel <:FinanceModels.AbstractModel\n        a \n        b \nend\n\n__default_optic(m::MyModel) = OptArgs([\n    @optic(_.a) => 0.0 .. 100.0,\n    @optic(_.b) => -10.0 .. 10.0,\n]...)\n\nExtended help\n\nAn arbitrarily complex model may be the object we intend to fit - how does fit know what free variables are able to be solved for within the given model? variables is a singlular or vector optic argument. What does this mean?\n\nAn optic (or \"lens\") is a way to define an accessor to a given object. Example:\n\njulia> using Accessors, AccessibleOptimization, IntervalSets\n\njulia> obj = (a = \"AA\", b = \"BB\");\n\njulia> lens = @optic _.a\n(@optic _.a)\n\njulia> lens(obj)\n\"AA\"\n\nAn optic argument is a singular or vector of lenses with an optional range of acceptable parameters. For example, we might have a model as follows where we want  fit to optize parameters a and b:\n\nstruct MyModel <:FinanceModels.AbstractModel\n        a \n        b \nend\n\n__default_optic(m::MyModel) = OptArgs([\n    @optic(_.a) => 0.0 .. 100.0,\n    @optic(_.b) => -10.0 .. 10.0,\n]...)\n\nIn this way, fit know which arbitrary parameters in a given object may be modified. Technically, we are not modifying the immutable MyModel, but instead efficiently creating a new instance. This is enabled by AccessibleOptimization.jl.\n\nNote that not all opitmization algorithms want a bounded interval. In that case, simply leave off the paired range. The prior example would then become:\n\n__default_optic(m::MyModel) = OptArgs([\n    @optic(_.a),\n    @optic(_.b),\n]...)\n\n```\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceModels/#FinanceModels.cashflows_timepoints-Tuple{Any}","page":"FinanceModels","title":"FinanceModels.cashflows_timepoints","text":"cashflows_timepoints(contracts)\ncashflows_timepoints(quotes)\n\nCreate a matrix of cashflows and a vector of timepoints for a collection of quotes or contracts. Timepoints need not be spaced evenly.\n\nThis is used when constructing SmithWilson yield curves.\n\nArguments\n\ncontracts or quotes: A collection of <:AbstractContracts or Quotes.\n\nReturns\n\nA tuple (m, times) where m is a matrix of cashflows and times is a vector of timepoints.\n\nExamples\n\njulia> FinanceModels.cashflows_timepoints(ParYield.([0.04,0.02,0.04],[1,4,4]))\n([0.02 0.01 0.02; 1.02 0.01 0.02; … ; 0.0 0.01 0.02; 0.0 1.01 1.02], [0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0])\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceModels/#FinanceModels.eurocall-Tuple{}","page":"FinanceModels","title":"FinanceModels.eurocall","text":"eurocall(;S=1.,K=1.,τ=1,r,σ,q=0.)\n\nCalculate the Black-Scholes implied option price for a european call, where:\n\nS is the current asset price\nK is the strike or exercise price\nτ is the time remaining to maturity (can be typed with \\tau[tab])\nr is the continuously compounded risk free rate\nσ is the (implied) volatility (can be typed with \\sigma[tab])\nq is the continuously paid dividend rate\n\nRates should be input as rates (not percentages), e.g.: 0.05 instead of 5 for a rate of five percent.\n\n!!! Experimental: this function is well-tested, but the derivatives functionality (API) may change in a future version of ActuaryUtilities.\n\nExtended Help\n\nThis is the same as the formulation presented in the dividend extension of the BS model in Wikipedia.\n\nOther general comments:\n\nSwap/OIS curves are generally better sources for r than government debt (e.g. US Treasury) due to the collateralized nature of swap instruments.\n(Implied) volatility is characterized by a curve that is a function of the strike price (among other things), so take care when using \nYields.jl can assist with converting rates to continuously compounded if you need to perform conversions.\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceModels/#FinanceModels.europut-Tuple{}","page":"FinanceModels","title":"FinanceModels.europut","text":"europut(;S=1.,K=1.,τ=1,r,σ,q=0.)\n\nCalculate the Black-Scholes implied option price for a european call, where:\n\nS is the current asset price\nK is the strike or exercise price\nτ is the time remaining to maturity (can be typed with \\tau[tab])\nr is the continuously compounded risk free rate\nσ is the (implied) volatility (can be typed with \\sigma[tab])\nq is the continuously paid dividend rate\n\nRates should be input as rates (not percentages), e.g.: 0.05 instead of 5 for a rate of five percent.\n\n!!! Experimental: this function is well-tested, but the derivatives functionality (API) may change in a future version of ActuaryUtilities.\n\nExtended Help\n\nThis is the same as the formulation presented in the dividend extension of the BS model in Wikipedia.\n\nOther general comments:\n\nSwap/OIS curves are generally better sources for r than government debt (e.g. US Treasury) due to the collateralized nature of swap instruments.\n(Implied) volatility is characterized by a curve that is a function of the strike price (among other things), so take care when using \nYields.jl can assist with converting rates to continuously compounded if you need to perform conversions.\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceModels/#FinanceModels.volatility-Tuple{FinanceModels.Volatility.Constant, Any, Any}","page":"FinanceModels","title":"FinanceModels.volatility","text":"volatility(volatiltiy_model,strike_ratio,time_to_maturity)\n\nReturns the volatility associated with the moneyness (strike/price ratio) and time to maturity.\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceModels/","page":"FinanceModels","title":"FinanceModels","text":"Please open an issue if you encounter any issues or confusion with the package.","category":"page"},{"location":"migration/#Migration-Guide","page":"Migration Guide","title":"Migration Guide","text":"","category":"section"},{"location":"migration/#v3-to-v4","page":"Migration Guide","title":"v3 to v4","text":"","category":"section"},{"location":"migration/#Yields.jl-is-now-FinanceModels.jl","page":"Migration Guide","title":"Yields.jl is now FinanceModels.jl","text":"","category":"section"},{"location":"migration/","page":"Migration Guide","title":"Migration Guide","text":"This re-write accomplishes three primary things:","category":"page"},{"location":"migration/","page":"Migration Guide","title":"Migration Guide","text":"Provide a composable set of contracts and Quotes \nThose contracts, when combined with a model produce a Cashflow via a flexibly defined Projection\nmodels can be fit with a new unified API: fit(model_type,quotes,fit_method) ","category":"page"},{"location":"migration/#Migrating-Code","page":"Migration Guide","title":"Migrating Code","text":"","category":"section"},{"location":"migration/#Update-Dependencies","page":"Migration Guide","title":"Update Dependencies","text":"","category":"section"},{"location":"migration/","page":"Migration Guide","title":"Migration Guide","text":"You should remove Yields from your project's dependencies and add FinanceModels instead. (link to Pkg documentation on how to do this)","category":"page"},{"location":"migration/#API-Changes","page":"Migration Guide","title":"API Changes","text":"","category":"section"},{"location":"migration/","page":"Migration Guide","title":"Migration Guide","text":"Previously, the API pattern was, e.g.:","category":"page"},{"location":"migration/","page":"Migration Guide","title":"Migration Guide","text":"model = Yields.Par(SmitWilson(...), rates,timepoints)","category":"page"},{"location":"migration/","page":"Migration Guide","title":"Migration Guide","text":"Now, follow the pattern of:","category":"page"},{"location":"migration/","page":"Migration Guide","title":"Migration Guide","text":"Define the quotes you want to fit the model to\nfit the model to those quotes","category":"page"},{"location":"migration/","page":"Migration Guide","title":"Migration Guide","text":"Example:","category":"page"},{"location":"migration/","page":"Migration Guide","title":"Migration Guide","text":"quotes = ParYield.(rates,timepoints)\nmodel = fit(SmithWilson(),quotes)","category":"page"},{"location":"migration/#Details-of-changes","page":"Migration Guide","title":"Details of changes","text":"","category":"section"},{"location":"migration/","page":"Migration Guide","title":"Migration Guide","text":"Previously the kind of contract, the implied quotes, the type of model, and how the fitting process worked were all combined into a single call (Yields.Par). This minimized the amount of code needed to construct a yield curve, but left it fairly cumbersome to extend the package. For example, for every new yield curve model, methods for Par, CMT, OIS, Zero, ... had to be defined. Additionally, all of the inputs needed to be yields - specifying a price was not available as an argument to fit. ","category":"page"},{"location":"migration/","page":"Migration Guide","title":"Migration Guide","text":"With the new design of the package, creating a completely new model is much easier, as only the model itself and the valuation primitives need to be defined. For example, defining a new yield curve type that works to value contracts instrument quotes only requires defining the discount method. To allow the model to be fit requires only defining a default set of parameters to optimize with __default_optic:","category":"page"},{"location":"migration/","page":"Migration Guide","title":"Migration Guide","text":" using FinanceModels, FinanceCore\n using AccessibleOptimization \n using IntervalSets\n \nstruct ABDiscountLine{A} <: FinanceModels.Yield.AbstractYieldModel\n    a::A\n    b::A\nend\n\n# define the default constructor for convenience\nABDiscountLine() = ABDiscountLine(0.,0.)\n\nfunction FinanceCore.discount(m::ABDiscountLine,t)\n    #discount rate is approximated by a straight lined, floored at 0.0 and capped at 1.0\n    clamp(m.a*t + m.b, 0.0,1.0) \nend\n\n\n# `@optic` indicates what in our model variables needs to be updated (from AccessibleOptimization.jl)\n# `-1.0 .. 1.0` says to bound the search from negative to positive one (from IntervalSets.jl)\nFinanceModels.__default_optic(m::ABDiscountLine) = OptArgs([\n    @optic(_.a) => -1.0 .. 1.0,\n    @optic(_.b) => -1.0 .. 1.0,\n]...)\n\nquotes = ZCBPrice([0.9, 0.8, 0.7,0.6])\n\nm = fit(ABDiscountLine(),quotes)","category":"page"},{"location":"faq/#Frequently-Asked-Questions","page":"FAQs","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"faq/#How-can-I-handle-Dates-instead-of-real-timepoints?","page":"FAQs","title":"How can I handle Dates instead of real timepoints?","text":"","category":"section"},{"location":"faq/","page":"FAQs","title":"FAQs","text":"Currently, you must convert the Date into a real-valued timepoint for use within the models and contracts. Future releases may contemplate more explicit, built-in handling of dates. In the meantime, you may find these packages helpful if you need precise date-level accuracy:","category":"page"},{"location":"faq/","page":"FAQs","title":"FAQs","text":"Miletus.jl\nInterestRates.jl\nBusinessDays.jl\nDayCounts.jl\nQuantLib.jl","category":"page"},{"location":"faq/#Why-does-the-package-rely-on-using-Transducers?","page":"FAQs","title":"Why does the package rely on using Transducers?","text":"","category":"section"},{"location":"faq/","page":"FAQs","title":"FAQs","text":"Transducers are a way of defining logic to be applied to a reducible collection. They can compose together efficiently and the compiler can optimize them well. In rewriting the package from v3 to v4, Transducers vastly simplified the iteration and state handling needed when projecting the contracts. The performance remains excellent and made a lot of the internals much simpler.","category":"page"},{"location":"faq/","page":"FAQs","title":"FAQs","text":"Transducers are a rich and powerful way to express programs and can seem somewhat unfamiliar at first encounter. For users of FinanceModels, very of transducers are needed/exposed:","category":"page"},{"location":"faq/","page":"FAQs","title":"FAQs","text":"To regular end-users who just use what is given to them here, the transducers internals are effectively completely hidden\nTo moderately advanced users who want to extend the functionality, as the examples show the only real exposure here is a weird function name ( __foldl__) with for loop with a return signature that has some extra information.","category":"page"},{"location":"faq/","page":"FAQs","title":"FAQs","text":"A number of examples of extending the package are given on the FinanceModels.jl Guide page and the of course the source code itself offers examples of existing Projections and Contracts.","category":"page"},{"location":"faq/#I-have-another-question","page":"FAQs","title":"I have another question","text":"","category":"section"},{"location":"faq/","page":"FAQs","title":"FAQs","text":"Ask on the discussion forum here: https://github.com/JuliaActuary/FinanceModels.jl/discussions","category":"page"},{"location":"API/Spline/#FinanceModels.Spline-API-Reference","page":"Spline","title":"FinanceModels.Spline API Reference","text":"","category":"section"},{"location":"API/Spline/","page":"Spline","title":"Spline","text":"Modules = [FinanceModels.Spline]","category":"page"},{"location":"API/Spline/#Exported-API","page":"Spline","title":"Exported API","text":"","category":"section"},{"location":"API/Spline/","page":"Spline","title":"Spline","text":"Modules = [FinanceModels.Spline]\nPrivate = false","category":"page"},{"location":"API/Spline/#FinanceModels.Spline","page":"Spline","title":"FinanceModels.Spline","text":"Spline is a module which offers various degree splines used for fitting or bootstraping curves via the fit function.\n\nAvailable methods:\n\nSpline.BSpline(n) where n is the nth order. A spline function of order n is a piecewise polynomial function of degree n − 1. This means that, e.g., cubic polynomial is a fourth degree B-Spline.\n\nThis object is not a fitted spline itself, rather it is a placeholder object which will be a spline representing the data only after using within fit.\n\nand convienience methods which create a Spline.BSpline object of the appropriate order.\n\nSpline.Linear()\nSpline.Quadratic()\nSpline.Cubic()\n\n\n\n\n\n","category":"module"},{"location":"API/Spline/#Unexported-API","page":"Spline","title":"Unexported API","text":"","category":"section"},{"location":"API/Spline/","page":"Spline","title":"Spline","text":"Modules = [FinanceModels.Spline]\nPublic = false","category":"page"},{"location":"API/Spline/#FinanceModels.Spline.Cubic-Tuple{}","page":"Spline","title":"FinanceModels.Spline.Cubic","text":"Spline.Cubic()\n\nCreate a cubic B-spline. This object is not a fitted spline itself, rather it is a placeholder object which will be a spline representing the data only after using within fit.\n\nReturns\n\nA BSpline object representing a cubic B-spline.\n\nExamples\n\njulia> Spline.Cubic()\nBSpline(4)\n\n\n\n\n\n","category":"method"},{"location":"API/Spline/#FinanceModels.Spline.Linear-Tuple{}","page":"Spline","title":"FinanceModels.Spline.Linear","text":"Spline.Linear()\n\nCreate a linear B-spline. This object is not a fitted spline itself, rather it is a placeholder object which will be a spline representing the data only after using within fit.\n\nReturns\n\nA BSpline object representing a linear B-spline.\n\nExamples\n\njulia> Spline.Linear()\nBSpline(2)\n\n\n\n\n\n","category":"method"},{"location":"API/Spline/#FinanceModels.Spline.Quadratic-Tuple{}","page":"Spline","title":"FinanceModels.Spline.Quadratic","text":"Spline.Quadratic()\n\nCreate a quadratic B-spline. This object is not a fitted spline itself, rather it is a placeholder object which will be a spline representing the data only after using within fit.\n\nReturns\n\nA BSpline object representing a quadratic B-spline.\n\nExamples\n\njulia> Spline.Quadratic()\nBSpline(3)\n\n\n\n\n\n","category":"method"},{"location":"API/Spline/","page":"Spline","title":"Spline","text":"Please open an issue if you encounter any issues or confusion with the package.","category":"page"},{"location":"API/Volatility/#FinanceModels.Volatility-API-Reference","page":"Volatility","title":"FinanceModels.Volatility API Reference","text":"","category":"section"},{"location":"API/Volatility/","page":"Volatility","title":"Volatility","text":"Modules = [FinanceModels.Volatility]","category":"page"},{"location":"API/Volatility/#Exported-API","page":"Volatility","title":"Exported API","text":"","category":"section"},{"location":"API/Volatility/","page":"Volatility","title":"Volatility","text":"Modules = [FinanceModels.Volatility]\nPrivate = false","category":"page"},{"location":"API/Volatility/#Unexported-API","page":"Volatility","title":"Unexported API","text":"","category":"section"},{"location":"API/Volatility/","page":"Volatility","title":"Volatility","text":"Modules = [FinanceModels.Volatility]\nPublic = false","category":"page"},{"location":"API/Volatility/#FinanceModels.Volatility.Constant","page":"Volatility","title":"FinanceModels.Volatility.Constant","text":"Volatility.Constant(σ)\n\nA constant volatility per period. If σ is not explicitly passed, then it is set to zero.\n\n\n\n\n\n","category":"type"},{"location":"API/Volatility/","page":"Volatility","title":"Volatility","text":"Please open an issue if you encounter any issues or confusion with the package.","category":"page"},{"location":"API/FinanceCore/#FinanceCore-API-Reference","page":"FinanceCore","title":"FinanceCore API Reference","text":"","category":"section"},{"location":"API/FinanceCore/","page":"FinanceCore","title":"FinanceCore","text":"Modules = [FinanceCore]","category":"page"},{"location":"API/FinanceCore/#Exported-API","page":"FinanceCore","title":"Exported API","text":"","category":"section"},{"location":"API/FinanceCore/","page":"FinanceCore","title":"FinanceCore","text":"Modules = [FinanceCore]\nPrivate = false","category":"page"},{"location":"API/FinanceCore/#FinanceCore.Composite","page":"FinanceCore","title":"FinanceCore.Composite","text":"Summary ≡≡≡≡≡≡≡≡≡\n\nstruct Composite{A, B}\n\nA Composite{A,B} is a contract that is composed of two other contracts of type A and type B.  The maturity of the composite is the maximum of the maturities of the two components. \n\nIt is used to assemble arbitrarily complex contracts from simpler ones.\n\nFields ≡≡≡≡≡≡≡≡\n\na :: A\nb :: B\n\nSupertype Hierarchy ≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡\n\nComposite{A, B} <: FinanceCore.AbstractContract <: Any\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceCore/#FinanceCore.Continuous","page":"FinanceCore","title":"FinanceCore.Continuous","text":"Continuous()\n\nA type representing continuous interest compounding frequency.\n\nExamples\n\njulia> Rate(0.01,Continuous())\nRate(0.01, Continuous())\n\nSee also: Periodic\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceCore/#FinanceCore.Continuous-Tuple{Any}","page":"FinanceCore","title":"FinanceCore.Continuous","text":"julia> Continuous(0.01)\nRate(0.01, Continuous())\n\nSee also: Periodic\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.Periodic","page":"FinanceCore","title":"FinanceCore.Periodic","text":"Periodic(frequency)\n\nA type representing periodic interest compounding with the given frequency. \n\nfrequency will be converted to an Integer, and will round up to 8 decimal places (otherwise will throw an InexactError). \n\nExamples\n\nCreating a semi-annual bond equivalent yield:\n\njulia> Rate(0.01,Periodic(2))\nRate(0.01, Periodic(2))\n\nSee also: Continuous\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceCore/#FinanceCore.Periodic-Tuple{Any, Any}","page":"FinanceCore","title":"FinanceCore.Periodic","text":"Periodic(rate,frequency)\n\nA convenience constructor for Rate(rate,Periodic(frequency)).\n\nExamples\n\nCreating a semi-annual bond equivalent yield:\n\njulia> Periodic(0.01,2)\nRate(0.01, Periodic(2))\n\nSee also: Continuous\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.Quote","page":"FinanceCore","title":"FinanceCore.Quote","text":"Quote(price,instrument)\n\nThe price(<:Real) is the observed value , and the instrument is the instrument/contract that the price is for.\n\nThis can be used, e.g., to calibrate a valuation model to prices for the given instruments - see FinanceModels.jl for more details.\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceCore/#FinanceCore.Rate-Tuple{Any}","page":"FinanceCore","title":"FinanceCore.Rate","text":"Rate(rate[,frequency=1])\nRate(rate,frequency::Frequency)\n\nRate is a type that encapsulates an interest rate along with its compounding frequency.\n\nPeriodic rates can be constructed via Rate(rate,frequency) or Rate(rate,Periodic(frequency)). If not given a second argument, Rate(rate) is equivalent to Rate(rate,Periodic(1)).\n\nContinuous rates can be constructed via Rate(rate, Inf) or Rate(rate,Continuous()).\n\nExamples\n\njulia> Rate(0.01,Continuous())\nRate(0.01, Continuous())\n\njulia> Continuous(0.01)\nRate(0.01, Continuous())\n\njulia> Continuous()(0.01)\nRate(0.01, Continuous())\n\njulia> Rate(0.01,Periodic(2))\nRate(0.01, Periodic(2))\n\njulia> Periodic(0.01,2)\nRate(0.01, Periodic(2))\n\njulia> Periodic(2)(0.01)\nRate(0.01, Periodic(2))\n\njulia> Rate(0.01)\nRate(0.01, Periodic(1))\n\njulia> Rate(0.01,2)\nRate(0.01, Periodic(2))\n\njulia> Rate(0.01,Periodic(4))\nRate(0.01, Periodic(4))\n\njulia> Rate(0.01,Inf)\nRate(0.01, Continuous())\n\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.amount-Tuple{C} where C<:Cashflow","page":"FinanceCore","title":"FinanceCore.amount","text":"amount(x)\n\nIf is an object with an amount component (e.g. a Cashflow), will retrun that amount component, otherwise just x.\n\nExamples\n\njulia> FinanceCore.amount(Cashflow(1.,3.))\n1.0\n\njulia> FinanceCore.amount(1.)\n1.0\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.internal_rate_of_return-Tuple{Any}","page":"FinanceCore","title":"FinanceCore.internal_rate_of_return","text":"internal_rate_of_return(cashflows::vector)::Rate\ninternal_rate_of_return(cashflows::Vector, timepoints::Vector)::Rate\n\nCalculate the internalrateof_return with given timepoints. If no timepoints given, will assume that a series of equally spaced cashflows, assuming the first cashflow occurring at time zero and subsequent elements at time 1, 2, 3, ..., n. \n\nReturns a Rate type with periodic compounding once per period (e.g. annual effective if the timepoints given represent years). Get the scalar rate by calling Yields.rate() on the result.\n\nExample\n\njulia> internal_rate_of_return([-100,110],[0,1]) # e.g. cashflows at time 0 and 1\n0.10000000001652906\njulia> internal_rate_of_return([-100,110]) # implied the same as above\n0.10000000001652906\n\nSolver notes\n\nWill try to return a root within the range [-2,2]. If the fast solver does not find one matching this condition, then a more robust search will be performed over the [.99,2] range.\n\nThe solution returned will be in the range [-2,2], but may not be the one nearest zero. For a slightly slower, but more robust version, call ActuaryUtilities.irr_robust(cashflows,timepoints) directly.\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.irr","page":"FinanceCore","title":"FinanceCore.irr","text":"irr(cashflows::vector)\nirr(cashflows::Vector, timepoints::Vector)\n\nAn alias for `internal_rate_of_return`.\n\n\n\n\n\n","category":"function"},{"location":"API/FinanceCore/#FinanceCore.present_value-Tuple{Any, Any, Any}","page":"FinanceCore","title":"FinanceCore.present_value","text":"present_value(yield_model, cashflows[, timepoints=pairs(cashflows)])\n\nDiscount the cashflows vector at the given yield_model,  with the cashflows occurring at the times specified in timepoints. If no timepoints given, assumes that cashflows happen at the indices of the cashflows.\n\nIf your timepoints are dates, you can convert them into a floating point representation of the time interval using DayCounts.jl.\n\nExamples\n\njulia> present_value(0.1, [10,20],[0,1])\n28.18181818181818\njulia> present_value(Continuous(0.1), [10,20],[0,1])\n28.096748360719193\njulia> present_value(Continuous(0.1), [10,20],[1,2])\n25.422989241919232\njulia> present_value(Continuous(0.1), [10,20])\n25.422989241919232\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.rate-Tuple{Rate}","page":"FinanceCore","title":"FinanceCore.rate","text":"rate(r::Rate)\n\nReturns the untyped scalar interest rate represented by the Rate.\n\nExamples\n\njulia> r =Continuous(0.03)\nYields.Rate{Float64, Continuous}(0.03, Continuous())\n\njulia> rate(r)\n0.03\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.timepoint-Union{Tuple{C}, Tuple{C, Any}} where C<:Cashflow","page":"FinanceCore","title":"FinanceCore.timepoint","text":"timepoint(x,t)\n\nIf x is an object with a defined time component (e.g. a Cashflow), will return that time component, otherwise will return t. This is useful in handling situations where you want to handle either Cashflows or separate amount and time vectors.\n\nExample\n\njulia> FinanceCore.timepoint(Cashflow(1.,3.),\"ignored\")\n3.0\n\njulia> FinanceCore.timepoint(1.,4.)\n4.0\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#Unexported-API","page":"FinanceCore","title":"Unexported API","text":"","category":"section"},{"location":"API/FinanceCore/","page":"FinanceCore","title":"FinanceCore","text":"Modules = [FinanceCore]\nPublic = false","category":"page"},{"location":"API/FinanceCore/#Base.:*-Union{Tuple{T}, Tuple{N}, Tuple{Rate{N, T}, Real}} where {N, T<:Continuous}","page":"FinanceCore","title":"Base.:*","text":"*(Yields.Rate, T)\n*(T, Yields.Rate)\n\nThe multiplication of a Rate with a scalar will inherit the type of the Rate, or the first argument's type if both are Rates.\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#Base.:+-Union{Tuple{T}, Tuple{N}, Tuple{Rate{N, T}, Real}} where {N, T<:Continuous}","page":"FinanceCore","title":"Base.:+","text":"+(Yields.Rate, T<:Real)\n+(T<:Real, Yields.Rate)\n+(Yields.Rate,Yields.Rate)\n\nThe addition of a rate with a number will inherit the type of the Rate, or the first argument's type if both are Rates.\n\nExamples\n\njulia> Yields.Periodic(0.01,2) + Yields.Periodic(0.04,2)\nYields.Rate{Float64, Yields.Periodic}(0.05000000000000004, Yields.Periodic(2))\n\njulia> Yields.Periodic(0.04,2) + 0.01\nYields.Rate{Float64, Yields.Periodic}(0.05, Yields.Periodic(2))\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#Base.:--Union{Tuple{T}, Tuple{N}, Tuple{Rate{N, T}, Real}} where {N, T<:Continuous}","page":"FinanceCore","title":"Base.:-","text":"-(Yields.Rate, T<:Real)\n-(T<:Real, Yields.Rate)\n-(Yields.Rate, Yields.Rate)\n\nThe addition of a rate with a number will inherit the type of the Rate, or the first argument's type if both are Rates.\n\nExamples\n\njulia> Yields.Periodic(0.04,2) - Yields.Periodic(0.01,2)\nYields.Rate{Float64, Yields.Periodic}(0.030000000000000214, Yields.Periodic(2))\n\njulia> Yields.Periodic(0.04,2) - 0.01\nYields.Rate{Float64, Yields.Periodic}(0.03, Yields.Periodic(2))\n\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#Base.:/-Union{Tuple{T}, Tuple{N}, Tuple{Rate{N, T}, Real}} where {N, T<:Continuous}","page":"FinanceCore","title":"Base.:/","text":"/(x::Yields.Rate, y::Real)\n\nThe division of a Rate with a scalar will inherit the type of the Rate, or the first argument's type if both are Rates.\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#Base.:<-Union{Tuple{U}, Tuple{T}, Tuple{T, U}} where {T<:Rate, U<:Rate}","page":"FinanceCore","title":"Base.:<","text":"<(x::Rate,y::Rate)\n\nConvert the second argument to the periodicity of the first and compare the scalar rate values to determine if the first argument has a lower force of interest than the second.\n\nExamples\n\njulia> Yields.Periodic(0.03,100) < Yields.Continuous(0.03)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#Base.:>-Union{Tuple{U}, Tuple{T}, Tuple{T, U}} where {T<:Rate, U<:Rate}","page":"FinanceCore","title":"Base.:>","text":">(Rate,Rate)\n\nConvert the second argument to the periodicity of the first and compare the scalar rate values to determine if the first argument has a greater force of interest than the second.\n\nExamples\n\njulia> Yields.Periodic(0.03,100) > Yields.Continuous(0.03)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#Base.convert-Union{Tuple{T}, Tuple{T, Rate}} where T<:FinanceCore.Frequency","page":"FinanceCore","title":"Base.convert","text":"convert(cf::Frequency,r::Rate)\n\nReturns a Rate with an equivalent discount but represented with a different compounding frequency.\n\nExamples\n\njulia> r = Rate(Periodic(12),0.01)\nRate(0.01, Periodic(12))\n\njulia> convert(Periodic(1),r)\nRate(0.010045960887181016, Periodic(1))\n\njulia> convert(Continuous(),r)\nRate(0.009995835646701251, Continuous())\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/","page":"FinanceCore","title":"FinanceCore","text":"Please open an issue if you encounter any issues or confusion with the package.","category":"page"},{"location":"API/Equity/#FinanceModels.Equity-API-Reference","page":"Equity","title":"FinanceModels.Equity API Reference","text":"","category":"section"},{"location":"API/Equity/","page":"Equity","title":"Equity","text":"Modules = [FinanceModels.Equity]","category":"page"},{"location":"API/Equity/#Exported-API","page":"Equity","title":"Exported API","text":"","category":"section"},{"location":"API/Equity/","page":"Equity","title":"Equity","text":"Modules = [FinanceModels.Equity]\nPrivate = false","category":"page"},{"location":"API/Equity/#FinanceModels.Equity","page":"Equity","title":"FinanceModels.Equity","text":"The Equity module provides equity-related model definitions.\n\nSee also: the Volatility module.\n\n\n\n\n\n","category":"module"},{"location":"API/Equity/#Unexported-API","page":"Equity","title":"Unexported API","text":"","category":"section"},{"location":"API/Equity/","page":"Equity","title":"Equity","text":"Modules = [FinanceModels.Equity]\nPublic = false","category":"page"},{"location":"API/Equity/#FinanceModels.Equity.BlackScholesMerton","page":"Equity","title":"FinanceModels.Equity.BlackScholesMerton","text":"BlackScholesMerton(r, q, σ) <: AbstractEquityModel\n\nA struct representing the Black-Scholes-Merton model for equity prices.\n\nArguments\n\nr: The risk-free rate.\nq: The dividend yield.\nσ: The volatility model of the underlying asset (see Volatility module) \n\nFields\n\nr: The risk-free rate.\nq: The dividend yield.\nσ: The volatility model of the underlying asset (see Volatility module)\n\nWhen fitting, the volatility will be solved-for; volatility itself is a sub-model that will be optimized with a default optimization bound of 0.0 .. 10.0\n\nExamples\n\njulia> model = BlackScholesMerton(0.05, 0.02, 0.2)\nBlackScholesMerton{Float64, Float64, Float64}(0.05, 0.02, 0.2)\n\nValuing an option:\n\nm = Equity.BlackScholesMerton(0.01, 0.02, 0.15)\n\na = Option.EuroCall(CommonEquity(), 1.0, 1.0)\n\n@test pv(m, a) ≈ 0.05410094201902403\n\nFitting a set of option prices:\n\nqs = [\n    Quote(0.0541, a),\n    Quote(0.072636, b),\n]\nm = Equity.BlackScholesMerton(0.01, 0.02, Volatility.Constant())\nfit(m, qs)\n@test fit(m, qs).σ ≈ 0.15 atol = 1e-4\n\n\n\n\n\n\n","category":"type"},{"location":"API/Equity/","page":"Equity","title":"Equity","text":"Please open an issue if you encounter any issues or confusion with the package.","category":"page"},{"location":"Rates/#Rates","page":"Rates","title":"Rates","text":"","category":"section"},{"location":"Rates/","page":"Rates","title":"Rates","text":"We should first discuss Rates, which are reexported from FinanceCore.jl","category":"page"},{"location":"Rates/","page":"Rates","title":"Rates","text":"Rates are types that wrap scalar values to provide information about how to determine discount and accumulation factors. These allow for explicit handling of rate compounding conventions which, if not explicit, is often a source of errors in practice.","category":"page"},{"location":"Rates/","page":"Rates","title":"Rates","text":"There are two Frequency types:","category":"page"},{"location":"Rates/","page":"Rates","title":"Rates","text":"Yields.Periodic(m) for rates that compound m times per period (e.g. m times per year if working with annual rates).\nYields.Continuous() for continuously compounding rates.","category":"page"},{"location":"Rates/#Examples","page":"Rates","title":"Examples","text":"","category":"section"},{"location":"Rates/","page":"Rates","title":"Rates","text":"Continuous(0.05)       # 5% continuously compounded\nPeriodic(0.05,2)       # 5% compounded twice per period","category":"page"},{"location":"Rates/","page":"Rates","title":"Rates","text":"These are both subtypes of the parent Rate type and are instantiated as:","category":"page"},{"location":"Rates/","page":"Rates","title":"Rates","text":"Rate(0.05,Continuous())       # 5% continuously compounded\nRate(0.05,Periodic(2))        # 5% compounded twice per period","category":"page"},{"location":"Rates/","page":"Rates","title":"Rates","text":"Broadcast over a vector to create Rates with the given compounding:","category":"page"},{"location":"Rates/","page":"Rates","title":"Rates","text":"Periodic.([0.02,0.03,0.04],2) \nContinuous.([0.02,0.03,0.04]) ","category":"page"},{"location":"Rates/","page":"Rates","title":"Rates","text":"Rates can also be constructed by specifying the CompoundingFrequency and then passing a scalar rate:","category":"page"},{"location":"Rates/","page":"Rates","title":"Rates","text":"Periodic(1)(0.05)\nContinuous()(0.05)","category":"page"},{"location":"Rates/#Conversion","page":"Rates","title":"Conversion","text":"","category":"section"},{"location":"Rates/","page":"Rates","title":"Rates","text":"Convert rates between different types with convert. E.g.:","category":"page"},{"location":"Rates/","page":"Rates","title":"Rates","text":"r = Rate(0.01,Periodic(12))             # rate that compounds 12 times per rate period (ie monthly)\n\nconvert(Yields.Periodic(1),r)                  # convert monthly rate to annual effective\nconvert(Yields.Continuous(),r)          # convert monthly rate to continuous","category":"page"},{"location":"Rates/","page":"Rates","title":"Rates","text":"To get the scalar value out of the Rate, use FinanceModels.rate(r):","category":"page"},{"location":"Rates/","page":"Rates","title":"Rates","text":"julia> r = Rate(0.01,Periodic(12));   \njulia> rate(r)\n0.01\n","category":"page"},{"location":"Rates/#Arithmetic","page":"Rates","title":"Arithmetic","text":"","category":"section"},{"location":"Rates/","page":"Rates","title":"Rates","text":"Adding, subtracting, multiplying, dividing, and comparing rates is supported.","category":"page"},{"location":"introduction/#FinanceModels.jl-Guide","page":"Introduction","title":"FinanceModels.jl Guide","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"FinanceModels.jl provides a set of composable contracts, models, and functions that allow for modeling of both simple and complex financial instruments. The resulting models, such as discount rates or term structures, can then be used across the JuliaActuary ecosystem to perform actuarial and financial analysis.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"(Image: A conceptual sketch of FinanceModels.jl)","category":"page"},{"location":"introduction/#.-Cashflow-a-fundamental-financial-type","page":"Introduction","title":"1. Cashflow - a fundamental financial type","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Say you wanted to model a contract that paid quarterly payments, and those payments occurred starting 15 days from the valuation date (first payment time = 15/365 = 0.057)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Previously, you had two options:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Choose a discrete timestep to model (e.g. monthly, quarterly, annual) and then lump the cashflows into those timesteps. E.g. with monthly timesteps  of a unit payment of our contract, it might look like: [1,0,0,1,0,0...]\nKeep track of two vectors: one for the payment and one for the times. In this case, that might look like: cfs = [1,1,...];times = [0.057, 0.307...]","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The former has inaccuracies due to the simplified timing and logical complication related to mapping the contracts natural periodicity into an arbitrary modeling choice. The latter becomes unwieldy and fails to take advantage of Julia's type system. ","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The new solution: Cashflows. Our example above would become: [Cashflow(1,0.057), Cashflow(1,0.307),...]","category":"page"},{"location":"introduction/#.-**Contracts**-A-composable-way-to-represent-financial-instruments","page":"Introduction","title":"2. Contracts - A composable way to represent financial instruments","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Contracts are a composable way to represent financial instruments. They are, in essence, anything that is a collection of cashflows. Contracts can be combined to represent more complex instruments. For example, a bond can be represented as a collection of cashflows that correspond to the coupon payments and the principal repayment.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Examples:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"a Cashflow\nBonds:\nBond.Fixed, Bond.Floating\nOptions:\nOption.EuroCall and Option.EuroPut \nCompositional contracts:\nForwardto represent an instrument that is relative to a forward point in time.\nComposite to represent the combination of two other instruments.  ","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"In the future, this notion may be extended to liabilities (e.g. insurance policies in LifeContingencies.jl)","category":"page"},{"location":"introduction/#Creating-a-new-Contract","page":"Introduction","title":"Creating a new Contract","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"A contract is anything that creates a vector of Cashflows when collected. For example, let's create a bond which only pays down principle and offers no coupons.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"using FinanceModels,FinanceCore\n\n# Transducers is used to provide a more powerful, composable way to construct collections than the basic iteration interface\nusing Transducers: __foldl__, @next, complete\n\n\"\"\"\nA bond which pays down its par (one unit) in equal payments. \n\"\"\"\nstruct PrincipalOnlyBond{F<:FinanceCore.Frequency} <: FinanceModels.Bond.AbstractBond\n    frequency::F\n    maturity::Float64\nend\n\n# We extend the interface to say what should happen as the bond is projected\n# There's two parts to customize:\n# 1. any initialization or state to keep track of\n# 2. The loop where we decide what gets returned at each timestep\nfunction Transducers.__foldl__(rf, val, p::Projection{C,M,K}) where {C<:PrincipalOnlyBond,M,K}\n    # initialization stuff\n    b = p.contract # the contract within a projection\n    ts = Bond.coupon_times(b) # works since it's a FinanceModels.Bond.AbstractBond with a frequency and maturity\n    pmt = 1 / length(ts)\n\n    for t in ts\n        # the loop which returns a value\n        cf = Cashflow(pmt, t)\n        val = @next(rf, val, cf) # the value to return is the last argument\n    end\n    return complete(rf, val)\nend","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"That's it! then we can use this contract to fitting models, create projections, quotes, etc. Here we simply collect the bond into an array of cashflows:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> PrincipalOnlyBond(Periodic(2),5.) |> collect\n10-element Vector{Cashflow{Float64, Float64}}:\n Cashflow{Float64, Float64}(0.1, 0.5)\n Cashflow{Float64, Float64}(0.1, 1.0)\n Cashflow{Float64, Float64}(0.1, 1.5)\n Cashflow{Float64, Float64}(0.1, 2.0)\n Cashflow{Float64, Float64}(0.1, 2.5)\n Cashflow{Float64, Float64}(0.1, 3.0)\n Cashflow{Float64, Float64}(0.1, 3.5)\n Cashflow{Float64, Float64}(0.1, 4.0)\n Cashflow{Float64, Float64}(0.1, 4.5)\n Cashflow{Float64, Float64}(0.1, 5.0)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Note that all contracts in FinanceModels.jl are currently unit contracts in that they assume a unit par value. Scale assets down to unit values before constructing the default contracts.","category":"page"},{"location":"introduction/#More-complex-Contracts","page":"Introduction","title":"More complex Contracts","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"When the cashflow depends on a model. An example of this is a floating bond where the coupon paid depends on a view of forward rates. See Section 6 - Projections for how this is handled.","category":"page"},{"location":"introduction/#.-Quotes-The-observed-price-we-need-to-fit-a-model-to","page":"Introduction","title":"3. Quotes - The observed price we need to fit a model to","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Quotes are the observed prices that we need to fit a model to. They represent the market prices of financial instruments, such as bonds or swaps. In the context of the package, a quote is defined as a pair of a contract and a price.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"For example, a par yield bond paying a 4% coupon (paid as 2% twice per annum) implies a price at par (i.e. 1.0):","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> ParYield(Periodic(0.04,2),10)\nQuote{Float64, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}}(\n1.0, \nFinanceModels.Bond.Fixed{Periodic, Float64, Int64}(0.040000000000000036, Periodic(2), 10))\n","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"A number of convenience functions are included to construct a Quote:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"ZCBPrice and ZCBYield\nParYield\nCMTYield\nOISYield\nForwardYields","category":"page"},{"location":"introduction/#.-**Models**-Not-just-yield-curves-anymore","page":"Introduction","title":"4. Models - Not just yield curves anymore","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Yield Curves: all of Yields.jl yield models are included in the initial FinanceModels.jl release\nEquities and Options: The initial release includes BlackScholesMerton option pricing and one can use constant or spline volatility models\nOthers more to come in the future","category":"page"},{"location":"introduction/#Creating-a-new-model","page":"Introduction","title":"Creating a new model","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Here we'll do a complete implementation of a yield curve model where the discount rate is approximated by a straight line (often called an AB line from the y=ax+b formula.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":" using FinanceModels, FinanceCore\n using AccessibleOptimization \n using IntervalSets\n \nstruct ABDiscountLine{A} <: FinanceModels.Yield.AbstractYieldModel\n    a::A\n    b::A\nend\n\nABDiscountLine() = ABDiscountLine(0.,0.)\n\nfunction FinanceCore.discount(m::ABDiscountLine,t)\n    #discount rate is approximated by a straight line, floored at 0.0 and capped at 1.0\n    clamp(m.a*t + m.b, 0.0,1.0) \nend\n\n\n# `@optic` indicates what in our model variables needs to be updated (from AccessibleOptimization.jl)\n# `-1.0 .. 1.0` says to bound the search from negative to positive one (from IntervalSets.jl)\nFinanceModels.__default_optic(m::ABDiscountLine) = OptArgs([\n    @optic(_.a) => -1.0 .. 1.0,\n    @optic(_.b) => -1.0 .. 1.0,\n]...)\n\nquotes = ZCBPrice([0.9, 0.8, 0.7,0.6])\n\nm = fit(ABDiscountLine(),quotes)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Now, m is a model like any of the other yield curve models provided and can be used in that context. For example, calculating the price of the bonds contained within our quotes where we indeed recover the prices for our contrived example:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> map(q -> pv(m,q.instrument),quotes) \n4-element Vector{Float64}:\n 0.9\n 0.8\n 0.7\n 0.6","category":"page"},{"location":"introduction/#.-fit-The-standardized-API-for-all-models,-quotes,-and-methods","page":"Introduction","title":"5. fit - The standardized API for all models, quotes, and methods","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"       Model                                                               Method\n          |                                                                   |\n    |------------|                                                     |---------------|\nfit(Spline.Cubic(), CMTYield.([0.04,0.05,0.055,0.06,0055],[1,2,3,4,5]), Fit.Bootstrap())\n                    |-------------------------------------------------|\n                                              |\n                                              Quotes","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Model could be Spline.Linear(), Yield.NelsonSiegelSvensson(), Equity.BlackScholesMerton(...), etc.\nQuote could be CMTYields, ParYields, Option.Eurocall, etc.\nMethod could be Fit.Loss(x->x^2), Fit.Loss(x->abs(x)), Fit.Bootstrap(), etc.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The benefit of this versus the old Yields.jl API is:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Without a generic fit method, no obvious way to expose different curve construction methods (e.g. choice of model and method)\nThe fit is extensible. Users or other packages could define their own Models, Quotes, or Methods and integrate into the JuliaActuary ecosystem.\nThe fit formulation is very generic: the required methods are minimal to integrate in order to extend the functionality.","category":"page"},{"location":"introduction/#Customizing-model-fitting","page":"Introduction","title":"Customizing model fitting","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Model fitting can be customized:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The loss function (least squares, absolute difference, etc.) via the third argument to fit:\ne.g.fit(ABDiscountLine(), quotes, FIt.Loss(x -> abs(x))\nthe default is Fit.Loss(x->x^2)\nthe optimization algorithm by defining a method FinanceModels.__default_optim__(m::ABDiscountLine) = OptimizationOptimJL.Newton()\nyou may need to change the __default_optic to be unbounded (simply omit the => and subsequent bounds)\nThe default is OptimizationMetaheuristics.ECA()\nThe general algorithm can be customized by creating a new method for fit: ","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"function FinanceModels.fit(m::ABDiscountLine, quotes, ...)\n\t# custom code for fitting your model here\nend","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"As an example, the splines (Spline.Linear(), Spline.Cubic(),...) are defined to use bootstrap by default: fit(mod0::Spline.BSpline, quotes, method::Fit.Bootstrap)","category":"page"},{"location":"introduction/#Using-models-without-fitting","page":"Introduction","title":"Using models without fitting","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"While many of the examples show models being fit to observed prices, you can skip that step in practice if you want to define an assumed valuation model that does not intend to calibrate market prices.","category":"page"},{"location":"introduction/#.-Projections","page":"Introduction","title":"6. Projections","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"A Projection is a generic way to work with various data that you can project forward. For example, getting the series of cashflows associated with a contract.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"What is a Projection?","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"struct Projection{C,M,K} <: AbstractProjection\n    contract::C    # the contract (or set of contracts) we want to project\n    model::M       # the model that defines how the contract will behave\n    kind::K           # what kind of projetion do we want? only cashflows? \nend","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"contract is obvious, so let's talk more about the second two:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"model is the same kind of thing we discussed above. Some contracts (e.g. a floating rate bond). We can still decompose a floating rate bond into a set of cashflows, but we need a model. \nThere are also projections which don't need a model (e.g. fixed bonds) and for that there's the generic NullModel() \nkind defines what we'll return from the projection.\nCashflowProjection() says we just want a Cashflow[...] vector\n... but if we wanted to extend this such that we got a vector containing cashflows, capital factors, default rates, etc we could define a new projection type (e.g. we might call the above AssetDetailProjection()\nCurrently, only CashflowProjection() is defined by FinanceModels.jl","category":"page"},{"location":"introduction/#Contracts-that-depend-on-the-model-(or-multiple-models)","page":"Introduction","title":"Contracts that depend on the model (or multiple models)","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"For example, the cashflows you generate for a floating rate bond is the current reference rate. Or maybe you have a stochastic volatility model and want to project forward option values. This type of dependency is handled like this:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"define model as a relation that maps a key to a model. E.g. a Dict(\"SOFR\" => NelsonSiegelSvensson(...))\nwhen defining the logic for the reducible collection/foldl, you can reference the Projection.model by the associated key.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Here's how a floating bond is implemented:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The contract struct. The key would be \"SOFR\" in our example above.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"struct Floating{F<:FinanceCore.Frequency,N<:Real,M<:Timepoint,K} <: AbstractBond\n    coupon_rate::N # coupon_rate / frequency is the actual payment amount\n    frequency::F\n    maturity::M\n    key::K\nend","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"And how we can reference the associated model when projecting that contract. This is very similar to the definition of __foldl__ for our PrincipalOnlyBond, except we are paying a coupon and referencing the scenario rate.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"@inline function Transducers.__foldl__(rf, val, p::Projection{C,M,K}) where {C<:Bond.Floating,M,K}\n    b = p.contract\n    ts = Bond.coupon_times(b)\n    for t in ts\n        freq = b.frequency # e.g. `Periodic(2)`\n        freq_scalar = freq.frequency  # the 2 from `Periodic(2)`\n\n        # get the rate from the current time to next payment \n        # out of the model and convert it to the contract's periodicity\n        model = p.model[b.key]\n        reference_rate = rate(freq(forward(model, t, t + 1 / freq_scalar)))\n        coup = (reference_rate + b.coupon_rate) / freq_scalar\n        amt = if t == last(ts)\n            1.0 + coup\n        else\n            coup\n        end\n        cf = Cashflow(amt, t)\n        val = @next(rf, val, cf)\n    end\n    return complete(rf, val)\nend","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"In this post we've now defined two assets that can work seamlessly with projecting cashflows, fitting models, and determining valuations :)","category":"page"},{"location":"introduction/#.-ProjectionKinds","page":"Introduction","title":"7. ProjectionKinds","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"While CashflowProjection is the most common (and the only one built into the initial release of FinanceModels), a Projection can be created which handles different kinds of outputs in the same manner as projecting just basic cashflows. For example, you may want to output an amortization schedule, or a financial statement, or an account value roll-forward. The Projection is able to handle these custom outputs by dispatching on the third element in a Projection.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Let's extend the example of a principle-only bond from section 2 above. Our goal is to create a basic amortization schedule which shows the payment made and outstanding balance. ","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"First, we create a new subtype of ProjectionKind:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"struct AmortizationSchedule <: FinanceModels.ProjectionKind\nend","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"And then define the loop for the amortization schedule output:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"# note the dispatch on `AmortizationSchedule` in the next line\nfunction Transducers.__foldl__(rf, val, p::Projection{C,M,K}) where {C<:PrincipalOnlyBond,M,K<:AmortizationSchedule}\n    # initialization stuff\n    b = p.contract # the contract within a projection\n    ts = Bond.coupon_times(b) # works since it's a FinanceModels.Bond.AbstractBond with a frequency and maturity\n    pmt = 1 / length(ts)\n    balance = 1.0\n    for t in ts\n        # the loop wich returns a tuple of the relevant data\n        balance -= pmt\n        result = (time=t,payment=pmt,outstanding=balance)\n        val = @next(rf, val, result) # the value to return is the last argument\n    end\n    return complete(rf, val)\nend","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"We can now define the projection:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> p = Projection(\n           PrincipalOnlyBond(Periodic(2),5.),  # our contract\n           NullModel(),                       # the projection doesn't need a model, so use the null model\n           AmortizationSchedule(),            # specify the amortization schedule output\n           );\n","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"And then collect the values:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> collect(p)\n10-element Vector{NamedTuple{(:time, :payment, :outstanding), Tuple{Float64, Float64, Float64}}}:\n (time = 0.5, payment = 0.1, outstanding = 0.9)\n (time = 1.0, payment = 0.1, outstanding = 0.8)\n (time = 1.5, payment = 0.1, outstanding = 0.7000000000000001)\n (time = 2.0, payment = 0.1, outstanding = 0.6000000000000001)\n (time = 2.5, payment = 0.1, outstanding = 0.5000000000000001)\n (time = 3.0, payment = 0.1, outstanding = 0.40000000000000013)\n (time = 3.5, payment = 0.1, outstanding = 0.30000000000000016)\n (time = 4.0, payment = 0.1, outstanding = 0.20000000000000015)\n (time = 4.5, payment = 0.1, outstanding = 0.10000000000000014)\n (time = 5.0, payment = 0.1, outstanding = 1.3877787807814457e-16)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = FinanceModels","category":"page"},{"location":"#FinanceModels.jl","page":"Home","title":"FinanceModels.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage)","category":"page"},{"location":"","page":"Home","title":"Home","text":"FinanceModels.jl provides a set of composable contracts, models, and functions that allow for modeling of both simple and complex financial instruments. The resulting models, such as discount rates or term structures, can then be used across the JuliaActuary ecosystem to perform actuarial and financial analysis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Additionally, the models can be used to project contracts through time: most basically as a series of cashflows but more complex output can be defined for contracts.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: anim_fps2)","category":"page"},{"location":"#QuickStart","page":"Home","title":"QuickStart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using FinanceModels\n\n# a set of market-observed prices we wish to calibrate the model to\n# annual effective unless otherwise specified\nq_rate = ZCBYield([0.01,0.02,0.03]);\nq_spread = ZCBYield([0.01,0.01,0.01]);\n\n# bootstrap a linear spline yield model\nmodel_rate = fit(Spline.Linear(),q_rate,Fit.Bootstrap());⠀           \nmodel_spread = fit(Spline.Linear(),q_spread,Fit.Bootstrap());\n\n# the zero rate is the combination of the two underlying rates\nzero(m_spread + m_rate,1) # 0.02 annual effective rate \n\n# the discount is the same as if we added the underlying zero rates\ndiscount(m_spread + m_rate,0,3) ≈ discount(0.01 + 0.03,3)   # true\n\n# compute the present value of a contract (a cashflow of 10 at time 3)\npresent_value(m_rate,Cashflow(10,3)) # 9.15...","category":"page"},{"location":"#Overview-of-FinanceModels","page":"Home","title":"Overview of FinanceModels","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: A conceptual sketch of FinanceModels.jl)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Often we start with observed or assumed values for existing contracts. We want to then use those assumed values to extend the valuation logic to new contracts. For example, we may have a set of bond yields which we then want to discount a series of insurance obligations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In the language of FinanceModels, we would have a set of Quotes which are used to fit a Model. That model is then used to discount a new series of cashflows.","category":"page"},{"location":"","page":"Home","title":"Home","text":"That's just an example, and we can use the various components in different ways depending on the objective of the analysis.","category":"page"},{"location":"#Contracts-and-Quotes","page":"Home","title":"Contracts and Quotes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Contracts are a way to represent financial obligations. These can be valued using a model, projected into a future steam of values, or combined with assumed prices as a Quote.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Included are a number of primitives and convenience methods for contracts:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Existing structs:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Cashflow\nBond.Fixed\nBond.Floating\nForward (an obligation with a forward start time)\nComposite (combine two other contracts, e.g. into a swap)\nEuroCall\nCommonEquity","category":"page"},{"location":"","page":"Home","title":"Home","text":"Commonly, we deal with conventions that imply a contract and an observed price. For example, we may talk about a treasury yield of 0.03. This is a description that implies a Quoteed price for an underling fixed bond. In FinanceModels, we could use CMTYield(rate,tenor) which would create a Quote(price,Bond.Fixed(...)). In this way, we can conveniently create a number of Quotes which can be used to fit models. Such convenience methods include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ZCBYield\nZCBPrice\nCMTYield\nParYield\nParSwapYield\nForwardYield","category":"page"},{"location":"","page":"Home","title":"Home","text":"FinanceModels offers a way to define new contracts as well.","category":"page"},{"location":"#Cashflows","page":"Home","title":"Cashflows","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Cashflows obligation are themselves a contract, but other contracts can be considered as essentially anything that can be combined with assumptions (a model) to derive a collection of cashflows.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For example, a obligation that pays 1.75 at time 2 could be represented as: Cashflow(1.75,2). ","category":"page"},{"location":"#Models","page":"Home","title":"Models","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Models are objects that can be fit to observed prices and then subsequently used to make valuations of other cashflows/contracts.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Yield models include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Yield.Constant\nBootstrapped Splines\nYield.SmithWilson\nYield.NelsonSiegel\nYield.NelsonSiegelSvensson","category":"page"},{"location":"#Yield-related-functions","page":"Home","title":"Yield-related functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The models can be used to compute various rates of interest:","category":"page"},{"location":"","page":"Home","title":"Home","text":"discount(curve,from,to) or discount(curve,to) gives the discount factor\naccumulation(curve,from,to) or accumulation(curve,to) gives the accumulation factor\nzero(curve,time) or zero(curve,time,Frequency) gives the zero-coupon spot rate for the given time.\nforward(curve,from,to) gives the zero rate between the two given times\npar(curve,time;frequency=2) gives the coupon-paying par equivalent rate for the given time.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Other models include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"BlackScholesMerton derivative valuation","category":"page"},{"location":"#Projections","page":"Home","title":"Projections","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Most basically, we can project a contract into a series of Cashflows: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> b = Bond.Fixed(0.04,Periodic(2),3)\nFinanceModels.Bond.Fixed{Periodic, Float64, Int64}(0.04, Periodic(2), 3)\n\njulia> collect(b)\n6-element Vector{Cashflow{Float64, Float64}}:\n Cashflow{Float64, Float64}(0.02, 0.5)\n Cashflow{Float64, Float64}(0.02, 1.0)\n Cashflow{Float64, Float64}(0.02, 1.5)\n Cashflow{Float64, Float64}(0.02, 2.0)\n Cashflow{Float64, Float64}(0.02, 2.5)\n Cashflow{Float64, Float64}(1.02, 3.0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"However, Projections allow one to combine three elements which can be extended to define any desired output (such as amortization schedules, financial statement projections, or account value rollforwards). The three elements are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"the underlying contract of interest\nthe model which includes assumptions of how the contract will behave\na ProjectionKind which indicates the kind of output desired (cashflow stream, amortization schedule, etc...)","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A fixed bond that needs no valuation model (NullModel()) to define its projected gross cashflows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Projection(Bond.Fixed(0.04,Periodic(2),3),NullModel(),CashflowProjection())","category":"page"},{"location":"#Plotting-Projections","page":"Home","title":"Plotting Projections","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A CashflowProjection or a vector of Cashflows can be plotted with the Makie family of plotting packages.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using FinanceModels, CairoMakie\nproj = Projection(Bond.Fixed(0.10,Periodic(2),20),NullModel(),CashflowProjection())\n# a stem plot:\nstem(proj)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Will produce: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: A stem plot of bond cashflows)","category":"page"},{"location":"#Fitting-Models","page":"Home","title":"Fitting Models","text":"","category":"section"},{"location":"#Fitting-Models-2","page":"Home","title":"Fitting Models","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"       Model                                                               Method\n          |                                                                   |\n  \t|------------|                                                     |---------------|\nfit(Spline.Cubic(), CMTYield.([0.04,0.05,0.055,0.06,0055],[1,2,3,4,5]), Fit.Bootstrap())\n                    |-------------------------------------------------|\n                                              |\n                                              Quotes","category":"page"},{"location":"","page":"Home","title":"Home","text":"Model could be Spline.Linear(), Yield.NelsonSiegelSvensson(), Equity.BlackScholesMerton(...), etc.\nQuote could be CMTYields, ParYields, Option.Eurocall, etc.\nMethod could be Fit.Loss(x->x^2), Fit.Loss(x->abs(x)), Fit.Bootstrap(), etc.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This unified way to fit models offers a much simpler way to extend functionality to new models or contract types.","category":"page"},{"location":"#Using-Models","page":"Home","title":"Using Models","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"After being fit, models can be used to value contracts:","category":"page"},{"location":"","page":"Home","title":"Home","text":"present_value(model,cashflows)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Additionally, ActuaryUtilities.jl offers a number of other methods that can be used, such as duration, convexity, price which can be used for analysis with the fitted models.","category":"page"},{"location":"#Rates","page":"Home","title":"Rates","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Rates are types that wrap scalar values to provide information about how to determine discount and accumulation factors.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are two Frequency types:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Periodic(m) for rates that compound m times per period (e.g. m times per year if working with annual rates).\nContinuous() for continuously compounding rates.","category":"page"},{"location":"#Examples-2","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Continuous(0.05)       # 5% continuously compounded\nPeriodic(0.05,2)       # 5% compounded twice per period","category":"page"},{"location":"","page":"Home","title":"Home","text":"These are both subtypes of the parent Rate type and are instantiated as:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Rate(0.05,Continuous())       # 5% continuously compounded\nRate(0.05,Periodic(2))        # 5% compounded twice per period","category":"page"},{"location":"","page":"Home","title":"Home","text":"Rates can also be constructed by specifying the Frequency and then passing a scalar rate:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Periodic(1)(0.05)\nContinuous()(0.05)","category":"page"},{"location":"#Conversion","page":"Home","title":"Conversion","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Convert rates between different types with convert. E.g.:","category":"page"},{"location":"","page":"Home","title":"Home","text":"r = Rate(FinanceModels.Periodic(12),0.01)             # rate that compounds 12 times per rate period (ie monthly)\n\nconvert(FinanceModels.Periodic(1),r)                  # convert monthly rate to annual effective\nconvert(FinanceModels.Continuous(),r)          # convert monthly rate to continuous","category":"page"},{"location":"#Arithmetic","page":"Home","title":"Arithmetic","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Adding, substracting, multiplying, dividing, and comparing rates is supported.","category":"page"},{"location":"#Guide-and-Documentation","page":"Home","title":"Guide and Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A guide which explains more about the components of the package and from-scratch examples of extending the package is available in the documenation","category":"page"},{"location":"#Exported-vs-Un-exported-Functions","page":"Home","title":"Exported vs Un-exported Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Generally, CamelCase methods which construct a datatype are exported as they are unlikely to conflict with other parts of code that may be written. For example, rate is un-exported (it must be called with FinanceModels.rate(...)) because rate is likely a very commonly defined variable within actuarial and financial contexts and there is a high risk of conflicting with defined variables.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Consider using import FinanceModels which would require qualifying all methods, but alleviates any namespace conflicts and has the benefit of being explicit about the calls (internally we prefer this in the package design to keep dependencies and their usage clear). ","category":"page"},{"location":"#Internals","page":"Home","title":"Internals","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For time-variant FinanceModels (ie yield curves), the inputs are converted to spot rates and interpolated using quadratic B-splines by default (see documentation for alternatives, such as linear interpolations).","category":"page"},{"location":"#Combination-Implementation","page":"Home","title":"Combination Implementation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Combinations track two different curve objects and are not combined into a single underlying data structure. This means that you may achieve better performance if you combine the rates before constructing a FinanceModels representation. The exception to this is Constant curves, which do get combined into a single structure that is as performant as pre-combined rate structure.","category":"page"},{"location":"#Related-Packages","page":"Home","title":"Related Packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"InterestRates.jl specializes in fast rate calculations aimed at valuing fixed income contracts, with business-day-level accuracy.\nComparative comments: FinanceModels.jl does not try to provide as precise controls over the timing, structure, and interpolation of the curve. Instead, FinanceModels.jl provides a minimal, but flexible and intuitive interface for common modeling needs.","category":"page"},{"location":"Updates/#FinanceModels.jl","page":"FinanceModels.jl","title":"FinanceModels.jl","text":"","category":"section"},{"location":"Updates/#Design","page":"FinanceModels.jl","title":"Design","text":"","category":"section"},{"location":"Updates/","page":"FinanceModels.jl","title":"FinanceModels.jl","text":"Contracts represent insturments that ultimately obligate a payment of cashflows, which may or may not be scenario dependant. \nQuotes are observed or reference prices that may be used to fit models.\nModels are the combination of assumptions and logic that can then be used to realize the assumed cashflows that arise from a contract.","category":"page"},{"location":"Updates/#Motivation","page":"FinanceModels.jl","title":"Motivation","text":"","category":"section"},{"location":"Updates/","page":"FinanceModels.jl","title":"FinanceModels.jl","text":"FinanceModels.jl is the evolution of Yields.jl. Yields.jl was originally designed for very nice usage of term structures of yield curves, but three aspects held it back:","category":"page"},{"location":"Updates/","page":"FinanceModels.jl","title":"FinanceModels.jl","text":"The design was very oriented towards interest rates, and it was awkward to stick, e.g. volatility models into a package called Yields.jl\nThe API for contructing curves was inconsistent because there are different ways to construct a given curve and the inputs to constructing a simple bootstrapped curve with a spline through given yields vs a best-fit of a variety of instrumnets was simply a different paradigm.\nThere was a lack of ability to even express some types of contracts that are useful for model-fitting or modeling in general.","category":"page"},{"location":"Updates/#TODOs","page":"FinanceModels.jl","title":"TODOs","text":"","category":"section"},{"location":"Updates/","page":"FinanceModels.jl","title":"FinanceModels.jl","text":"bond.frequency.frequency is awkward\nCore contracts:\nComposite contact (e.g. Fixed + Float -> Swap)\nForward contact\nDerivatives?\ndistinguish between clean and dirty prices\nProjections\nEverythign is currently coerced to a F64/F64 Cashflow, but would like to be flexible with amount and timepoints\nHow to integrate Dates?\nCore methods:\nport Yields.jl methods\nErgonomics:\n\nPackage design:\npromote pv to FinanceCore given it's utility here\npromote Cashflow up to FC ","category":"page"}]
}

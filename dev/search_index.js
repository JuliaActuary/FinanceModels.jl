var documenterSearchIndex = {"docs":
[{"location":"Updates/#FinanceModels.jl","page":"FinanceModels.jl","title":"FinanceModels.jl","text":"","category":"section"},{"location":"Updates/#Design","page":"FinanceModels.jl","title":"Design","text":"Contracts represent insturments that ultimately obligate a payment of cashflows, which may or may not be scenario dependant.\nQuotes are observed or reference prices that may be used to fit models.\nModels are the combination of assumptions and logic that can then be used to realize the assumed cashflows that arise from a contract.","category":"section"},{"location":"Updates/#Motivation","page":"FinanceModels.jl","title":"Motivation","text":"FinanceModels.jl is the evolution of Yields.jl. Yields.jl was originally designed for very nice usage of term structures of yield curves, but three aspects held it back:\n\nThe design was very oriented towards interest rates, and it was awkward to stick, e.g. volatility models into a package called Yields.jl\nThe API for contructing curves was inconsistent because there are different ways to construct a given curve and the inputs to constructing a simple bootstrapped curve with a spline through given yields vs a best-fit of a variety of instrumnets was simply a different paradigm.\nThere was a lack of ability to even express some types of contracts that are useful for model-fitting or modeling in general.","category":"section"},{"location":"Updates/#TODOs","page":"FinanceModels.jl","title":"TODOs","text":"bond.frequency.frequency is awkward\nCore contracts:\nComposite contact (e.g. Fixed + Float -> Swap)\nForward contact\nDerivatives?\ndistinguish between clean and dirty prices\nProjections\nEverythign is currently coerced to a F64/F64 Cashflow, but would like to be flexible with amount and timepoints\nHow to integrate Dates?\nCore methods:\nport Yields.jl methods\nErgonomics\n\nPackage design:\npromote pv to FinanceCore given it's utility here\npromote Cashflow up to FC","category":"section"},{"location":"API/Option/#FinanceModels.Option-API-Reference","page":"Option","title":"FinanceModels.Option API Reference","text":"Modules = [FinanceModels.Option]","category":"section"},{"location":"API/Option/#Exported-API","page":"Option","title":"Exported API","text":"","category":"section"},{"location":"API/Option/#Unexported-API","page":"Option","title":"Unexported API","text":"Please open an issue if you encounter any issues or confusion with the package.","category":"section"},{"location":"API/Option/#FinanceModels.Option","page":"Option","title":"FinanceModels.Option","text":"\n\n\n\n","category":"module"},{"location":"API/Option/#FinanceModels.Option.EuroCall","page":"Option","title":"FinanceModels.Option.EuroCall","text":"EuroCall(contract,strike,maturity)\n\nA European call option on the given contract with the given strike and maturity.\n\nArguments\n\ncontract::AbstractContract -  The underlying contract.\nstrike::Real -  The strike price.\nmaturity::Union{Real,Date} -  The maturity of the option.\n\nSupertype Hierarchy ≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡\n\nEuroCall{S,K,M} <: FinanceCore.AbstractContract <: Any\n\n\n\n\n\n","category":"type"},{"location":"API/Option/#FinanceModels.Option.EuroPut","page":"Option","title":"FinanceModels.Option.EuroPut","text":"EuroPut(contract,strike,maturity)\n\nA European put option on the given contract with the given strike and maturity.\n\nArguments\n\ncontract::AbstractContract -  The underlying contract.\nstrike::Real -  The strike price.\nmaturity::Union{Real,Date} -  The maturity of the option.\n\nSupertype Hierarchy ≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡\n\nEuroPut{S,K,M} <: FinanceCore.AbstractContract <: Any\n\n\n\n\n\n","category":"type"},{"location":"API/Fit/#FinanceModels.Fit-API-Reference","page":"Fit","title":"FinanceModels.Fit API Reference","text":"Modules = [FinanceModels.Fit]","category":"section"},{"location":"API/Fit/#Exported-API","page":"Fit","title":"Exported API","text":"","category":"section"},{"location":"API/Fit/#Unexported-API","page":"Fit","title":"Unexported API","text":"Please open an issue if you encounter any issues or confusion with the package.","category":"section"},{"location":"API/Fit/#FinanceModels.Fit.Bootstrap","page":"Fit","title":"FinanceModels.Fit.Bootstrap","text":"Bootstrap()\n\nA singleton type which is passed to fit in order to bootstrap Splines. The curves are fit such that the spline passes through the zero rates of the curve. \n\nA subtype of FitMethod.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"API/Fit/#FinanceModels.Fit.Loss","page":"Fit","title":"FinanceModels.Fit.Loss","text":"Fit.Loss(function)\n\nfunction should be a loss measure, such as x->x^2 or x->abs(x). This is used by the optimization algorithm in fit to determine optimal parameters as defined by this loss function.\n\nA subtype of FitMethod.\n\nExamples\n\njulia> mod0 = Yield.Constant();\n\njulia> quotes = ZCBPrice([0.9, 0.8, 0.7,0.6]);\n\njulia> fit(mod0,quotes,Fit.Loss(x-x^2))\n\n              ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Yield Curve (FinanceModels.Yield.Constant)⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀           \n              ┌────────────────────────────────────────────────────────────┐           \n     0.120649 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ Zero rates\n              │⠀⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⣧⢰⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⣿⣾⠀⣀⣸⠀⢸⢳⣇⢀⣀⣀⣀⣀⣀⠀⡀⣀⣀⣀⡀⡀⣀⢀⣀⡀⡀⣀⢀⡀⣀⡀⢀⣀⡀⢀⡀⢀⣀⡀⢀⡀⠀⣀⡀⢀⡀⢀⣀⡀⢀⣀⠀⣀⡀⢀⣀⠀⢀│           \n              │⢠⢻⡟⡆⣿⡟⣦⠚⠀⢸⣾⠛⠛⠘⠛⠘⢲⡗⠛⠃⠛⠓⠓⠛⠚⠛⠑⠓⠛⠃⠓⠛⠑⠚⡟⠓⢻⡗⠚⠀⠓⠚⠑⠒⠃⠓⠚⠑⠚⠀⠓⠃⠘⠒⠃⠓⠃⠘⠒⠃│           \n              │⢸⢸⡇⢹⡏⠁⠉⠀⠀⠈⠉⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⠈⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n   Continuous │⢸⢸⡇⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⢸⠀⠁⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⢸⠀⠀⠘⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⡎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n     0.120649 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              └────────────────────────────────────────────────────────────┘           \n              ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀time⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀30⠀  \n\n\n\n\n\n\n","category":"type"},{"location":"contracts/#Contracts","page":"Contracts","title":"Contracts","text":"","category":"section"},{"location":"contracts/#**Contracts**-A-composable-way-to-represent-financial-instruments","page":"Contracts","title":"Contracts - A composable way to represent financial instruments","text":"Contracts are a composable way to represent financial instruments. They are, in essence, anything that is a collection of cashflows. Contracts can be combined to represent more complex instruments. For example, a bond can be represented as a collection of cashflows that correspond to the coupon payments and the principal repayment.\n\nExamples:\n\na Cashflow\nBonds:\nBond.Fixed, Bond.Floating\nOptions:\nOption.EuroCall and Option.EuroPut\nCompositional contracts:\nForwardto represent an instrument that is relative to a forward point in time.\nComposite to represent the combination of two other instruments.  \n\nIn the future, this notion may be extended to liabilities (e.g. insurance policies in LifeContingencies.jl)","category":"section"},{"location":"contracts/#Cashflow-a-fundamental-financial-type","page":"Contracts","title":"Cashflow - a fundamental financial type","text":"Say you wanted to model a contract that paid quarterly payments, and those payments occurred starting 15 days from the valuation date (first payment time = 15/365 = 0.057)\n\nPreviously, you had two options:\n\nChoose a discrete timestep to model (e.g. monthly, quarterly, annual) and then lump the cashflows into those timesteps. E.g. with monthly timesteps  of a unit payment of our contract, it might look like: [1,0,0,1,0,0...]\nKeep track of two vectors: one for the payment and one for the times. In this case, that might look like: cfs = [1,1,...];times = [0.057, 0.307...]\n\nThe former has inaccuracies due to the simplified timing and logical complication related to mapping the contracts natural periodicity into an arbitrary modeling choice. The latter becomes unwieldy and fails to take advantage of Julia's type system.\n\nThe new solution: Cashflows. Our example above would become: [Cashflow(1,0.057), Cashflow(1,0.307),...]","category":"section"},{"location":"contracts/#Creating-a-new-Contract","page":"Contracts","title":"Creating a new Contract","text":"A contract is anything that creates a vector of Cashflows when collected. For example, let's create a bond which only pays down principle and offers no coupons.\n\nusing FinanceModels,FinanceCore\n\n# Transducers is used to provide a more powerful, composible way to construct collections than the basic iteration interface\nusing Transducers: __foldl__, @next, complete\n\n\"\"\"\nA bond which pays down its par (one unit) in equal payments. \n\"\"\"\nstruct PrincipleOnlyBond{F<:FinanceCore.Frequency} <: FinanceModels.Bond.AbstractBond\n    frequency::F\n    maturity::Float64\nend\n\n# We extend the interface to say what should happen as the bond is projected\n# There's two parts to customize:\n# 1. any initialization or state to keep track of\n# 2. The loop where we decide what gets returned at each timestep\nfunction Transducers.__foldl__(rf, val, p::Projection{C,M,K}) where {C<:PrincipleOnlyBond,M,K}\n    # initialization stuff\n    b = p.contract # the contract within a projection\n    ts = Bond.coupon_times(b) # works since it's a FinanceModels.Bond.AbstractBond with a frequency and maturity\n    pmt = 1 / length(ts)\n\n    for t in ts\n        # the loop wich returns a value\n        cf = Cashflow(pmt, t)\n        val = @next(rf, val, cf) # the value to return is the last argument\n    end\n    return complete(rf, val)\nend\n\nThat's it! then we can use this fitting models, projections, quotes, etc. Here we simply collect the bond into an array of cashflows:\n\njulia> PrincipleOnlyBond(Periodic(2),5.) |> collect\n10-element Vector{Cashflow{Float64, Float64}}:\n Cashflow{Float64, Float64}(0.1, 0.5)\n Cashflow{Float64, Float64}(0.1, 1.0)\n Cashflow{Float64, Float64}(0.1, 1.5)\n Cashflow{Float64, Float64}(0.1, 2.0)\n Cashflow{Float64, Float64}(0.1, 2.5)\n Cashflow{Float64, Float64}(0.1, 3.0)\n Cashflow{Float64, Float64}(0.1, 3.5)\n Cashflow{Float64, Float64}(0.1, 4.0)\n Cashflow{Float64, Float64}(0.1, 4.5)\n Cashflow{Float64, Float64}(0.1, 5.0)\n\nNote that all contracts in FinanceModels.jl are currently unit contracts in that they assume a unit par value.","category":"section"},{"location":"contracts/#More-complex-Contracts","page":"Contracts","title":"More complex Contracts","text":"","category":"section"},{"location":"contracts/#Sets-of-contracts","page":"Contracts","title":"Sets of contracts","text":"Sets of contracts can be put in an AbstractArray contained (e.g. a Vector) and then handled together. For example, we combine two bonds as a portfolio to project together:\n\njulia> c1 = Bond.Fixed(0.05, Periodic(1), 2.0);\njulia> c2 = Bond.Fixed(0.04, Periodic(1), 2.0);\n\njulia> Projection([c1, c2]) |> collect\n4-element Vector{Cashflow{Float64, Float64}}:\n Cashflow{Float64, Float64}(0.05, 1.0)\n Cashflow{Float64, Float64}(1.05, 2.0)\n Cashflow{Float64, Float64}(0.04, 1.0)\n Cashflow{Float64, Float64}(1.04, 2.0)","category":"section"},{"location":"contracts/#Transformations","page":"Contracts","title":"Transformations","text":"Contracts (<:AbstractContract) and Projections can be modified to be scaled or transformed using the transformations in Transducers.jl after importing that package.\n\nMost commonly, this is likely simply chaining Map(...) calls. Two use-cases of this may be to (1) scale the contract by a factor or (2) change the sign of the contract to indicate an obligation/liability instead of an asset. Examples of this:\n\njulia> using Transducers, FinanceModels\n\njulia> Bond.Fixed(0.05,Periodic(1),3) |> collect\n3-element Vector{Cashflow{Float64, Float64}}:\n Cashflow{Float64, Float64}(0.05, 1.0)\n Cashflow{Float64, Float64}(0.05, 2.0)\n Cashflow{Float64, Float64}(1.05, 3.0)\n\njulia> Bond.Fixed(0.05,Periodic(1),3) |> Map(-) |> collect\n3-element Vector{Cashflow{Float64, Float64}}:\n Cashflow{Float64, Float64}(-0.05, 1.0)\n Cashflow{Float64, Float64}(-0.05, 2.0)\n Cashflow{Float64, Float64}(-1.05, 3.0)\n\njulia> Bond.Fixed(0.05,Periodic(1),3) |> Map(-) |> Map(x->x*2) |> collect\n3-element Vector{Cashflow{Float64, Float64}}:\n Cashflow{Float64, Float64}(-0.1, 1.0)\n Cashflow{Float64, Float64}(-0.1, 2.0)\n Cashflow{Float64, Float64}(-2.1, 3.0)\n\nAnother example of this is how InterestRateSwap[@ref] is implemented. It's simply a Composite contract of a positive fixed rate bond and a negative floating rate bond:\n\nfunction InterestRateSwap(curve, tenor; model_key=\"OIS\")\n    fixed_rate = par(curve, tenor; frequency=4)\n    fixed_leg = Bond.Fixed(rate(fixed_rate), Periodic(4), tenor)\n    float_leg = Bond.Floating(0.0, Periodic(4), tenor, model_key) |> Map(-)\n    return Composite(fixed_leg, float_leg)\nend","category":"section"},{"location":"contracts/#Cashflows-are-model-dependent","page":"Contracts","title":"Cashflows are model dependent","text":"An example of this is a floating bond where the coupon paid depends on a view of forward rates. See this section in the overview on projections for how this is handled.","category":"section"},{"location":"contracts/#Available-Contracts-and-Modules","page":"Contracts","title":"Available Contracts & Modules","text":"See the Modules in the left navigation for details on available contracts/models/functions.","category":"section"},{"location":"models/#Models,-Valuation,-Projections,-and-Fitting","page":"Models, Valuation, and Fitting","title":"Models, Valuation, Projections, and Fitting","text":"","category":"section"},{"location":"models/#Introduction","page":"Models, Valuation, and Fitting","title":"Introduction","text":"Conceptually, we have an iterative process:\n\nWe use models to value contracts\nWe use observed (or assumed) prices to calibrate models\n\nThus the discussion of model calibration and valuation of contracts is inextricably linked together.","category":"section"},{"location":"models/#Yield-(Interest-Rate)-models","page":"Models, Valuation, and Fitting","title":"Yield (Interest Rate) models","text":"","category":"section"},{"location":"models/#Rates","page":"Models, Valuation, and Fitting","title":"Rates","text":"We should first discuss Rates, which are reexported from FinanceCore.jl\n\nRates are types that wrap scalar values to provide information about how to determine discount and accumulation factors. These allow for explicit handling of rate compounding conventions which, if not explicit, is often a source of errors in practice.\n\nThere are two Frequency types:\n\nYields.Periodic(m) for rates that compound m times per period (e.g. m times per year if working with annual rates).\nYields.Continuous() for continuously compounding rates.","category":"section"},{"location":"models/#Examples","page":"Models, Valuation, and Fitting","title":"Examples","text":"Continuous(0.05)       # 5% continuously compounded\nPeriodic(0.05,2)       # 5% compounded twice per period\n\nThese are both subtypes of the parent Rate type and are instantiated as:\n\nRate(0.05,Continuous())       # 5% continuously compounded\nRate(0.05,Periodic(2))        # 5% compounded twice per period\n\nBroadcast over a vector to create Rates with the given compounding:\n\nPeriodic.([0.02,0.03,0.04],2) \nContinuous.([0.02,0.03,0.04]) \n\nRates can also be constructed by specifying the CompoundingFrequency and then passing a scalar rate:\n\nPeriodic(1)(0.05)\nContinuous()(0.05)","category":"section"},{"location":"models/#Conversion","page":"Models, Valuation, and Fitting","title":"Conversion","text":"Convert rates between different types with convert. E.g.:\n\nr = Rate(0.01,Periodic(12))             # rate that compounds 12 times per rate period (ie monthly)\n\nconvert(Yields.Periodic(1),r)                  # convert monthly rate to annual effective\nconvert(Yields.Continuous(),r)          # convert monthly rate to continuous\n\nTo get the scalar value out of the Rate, use FinanceModels.rate(r):\n\njulia> r = Rate(0.01,Periodic(12));   \njulia> rate(r)\n0.01\n","category":"section"},{"location":"models/#Available-Models-Yields","page":"Models, Valuation, and Fitting","title":"Available Models - Yields","text":"FinanceModels.Yield.Constant\nBootstrapped Splines\nFinanceModels.Yield.SmithWilson\nFinanceModels.Yield.NelsonSiegel\nFinanceModels.Yield.NelsonSiegelSvensson","category":"section"},{"location":"models/#Arithmetic","page":"Models, Valuation, and Fitting","title":"Arithmetic","text":"Adding, subtracting, multiplying, dividing, and comparing rates is supported.\n\nYield models can also be composed. Here is an example of fitting rates and spread separately and then adding the two models together:\n\njulia> q_rate = ZCBYield([0.01,0.02,0.03]);\n\njulia> q_spread = ZCBYield([0.01,0.01,0.01]);\n\njulia> m_rate = fit(Spline.Linear(),q_rate,Fit.Bootstrap());⠀           \n\njulia> m_spread = fit(Spline.Linear(),q_spread,Fit.Bootstrap());\n\njulia> forward(m_spread + m_rate,0,1)\nRate{Float64, Continuous}(0.01980262729617973, Continuous())\n\njulia> forward(m_spread + m_rate,0,1) |> Periodic(1)\nRate{Float64, Periodic}(0.020000000000000018, Periodic(1))\n\njulia> discount(m_spread + m_rate,0,3)\n0.8889963586709149\n\njulia> discount(0.04,3)\n0.8889963586709148\n\nwarning: Caution with Spreads\nIt is fairly common to see spreads and rates provided separately where both are quoted in par convention. For example, US Treasury par rates with the associated par risk spreads. Because par rates are dependent on the amount and path of rates preceeding the given tenor, it is not valid to construct a \"spread curve\" with par rates and then use it in composition with a \"rate curve\".That is, while the zero rates and spreads in the preceeding example allow for additive or subtractive composition, it is not the case for par rates and spreads. Note the different discount factors produced:q_rate = ParYield([0.01,0.02,0.03]);\nq_spread = ParYield([0.01,0.01,0.01]);\nq_yield = ParYield([0.02,0.03,0.04]);\n\nm_rate = fit(Spline.Linear(),q_rate,Fit.Bootstrap());         \nm_spread = fit(Spline.Linear(),q_spread,Fit.Bootstrap());\nm_yield = fit(Spline.Linear(),q_yield,Fit.Bootstrap());\n\n# The curves are different!\ndiscount(m_spread + m_rate,3)\n# 0.8889963586709149\n\ndiscount(m_yield,3)\n# 0.8864366955434709","category":"section"},{"location":"models/#Creating-New-Yield-Models","page":"Models, Valuation, and Fitting","title":"Creating New Yield Models","text":"See the FinanceModels.jl Guide for an example of creating a model from scratch. Some additional aspects to note:\n\nThe only method that must be defined to calculate the FinanceCore.present_value of something is FinanceCore.discount. Other methods will be inferred.\nOther methods that are imputed by default, but can be extended include: FinanceCore.accumulation, FinanceModels.forward, FinanceModels.par, FinanceModels.zero, and FinanceModels.rate.","category":"section"},{"location":"models/#Equity-and-Volatility-Models","page":"Models, Valuation, and Fitting","title":"Equity and Volatility Models","text":"","category":"section"},{"location":"models/#Available-Models-Option-Valuation","page":"Models, Valuation, and Fitting","title":"Available Models - Option Valuation","text":"FinanceModels.Equity.BlackScholesMerton","category":"section"},{"location":"models/#Available-Models-Volatility","page":"Models, Valuation, and Fitting","title":"Available Models - Volatility","text":"FinanceModels.Volatility.Constant","category":"section"},{"location":"models/#Creating-new-Volatility-Models","page":"Models, Valuation, and Fitting","title":"Creating new Volatility Models","text":"A volatility model must extend volatility(vol::Volatility.MyNewModel, strike_ratio, time_to_maturity).","category":"section"},{"location":"API/Yield/#FinanceModels.Yield-API-Reference","page":"Yield","title":"FinanceModels.Yield API Reference","text":"Modules = [FinanceModels.Yield]","category":"section"},{"location":"API/Yield/#Exported-API","page":"Yield","title":"Exported API","text":"","category":"section"},{"location":"API/Yield/#Unexported-API","page":"Yield","title":"Unexported API","text":"Please open an issue if you encounter any issues or confusion with the package.","category":"section"},{"location":"API/Yield/#Base.zero-Union{Tuple{YC}, Tuple{YC, Any}} where YC<:FinanceModels.Yield.AbstractYieldModel","page":"Yield","title":"Base.zero","text":"zero(curve,time)\n\nReturn the zero rate for the curve at the given time.\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#FinanceCore.discount-Union{Tuple{T}, Tuple{T, Any, Any}} where T<:FinanceModels.Yield.AbstractYieldModel","page":"Yield","title":"FinanceCore.discount","text":"discount(yc, to)\ndiscount(yc, from,to)\n\nThe discount factor for the yield curve yc for times from through to.\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#FinanceCore.forward-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T<:FinanceModels.Yield.AbstractYieldModel","page":"Yield","title":"FinanceCore.forward","text":"forward(yc, from, to)˚\n\nThe forward Rate implied by the yield curve yc between times from and to.\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#FinanceModels.Yield.par-Tuple{Any, Any}","page":"Yield","title":"FinanceModels.Yield.par","text":"par(curve,time;frequency=2)\n\nCalculate the par yield for maturity time for the given curve and frequency. Returns a Rate object with periodicity corresponding to the frequency. The exception to this is if time is less than what the payments allowed by frequency (e.g. a time 0.5 but with frequency 1) will effectively assume frequency equal to 1 over time.\n\nExamples\n\njulia> c = Yields.Constant(0.04);\n\njulia> Yields.par(c,4)\nYields.Rate{Float64, Yields.Periodic}(0.03960780543711406, Yields.Periodic(2))\n\njulia> Yields.par(c,4;frequency=1)\nYields.Rate{Float64, Yields.Periodic}(0.040000000000000036, Yields.Periodic(1))\n\njulia> Yields.par(c,0.6;frequency=4)\nYields.Rate{Float64, Yields.Periodic}(0.039413626195875295, Yields.Periodic(4))\n\njulia> Yields.par(c,0.2;frequency=4)\nYields.Rate{Float64, Yields.Periodic}(0.039374942589460726, Yields.Periodic(5))\n\njulia> Yields.par(c,2.5)\nYields.Rate{Float64, Yields.Periodic}(0.03960780543711406, Yields.Periodic(2))\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#FinanceModels.Yield.CompositeYield","page":"Yield","title":"FinanceModels.Yield.CompositeYield","text":"CompositeYield(curve1,curve2,operation)\n\nCreates a datastructure that will perform the given operation after independently calculating the effects of the two curves.  Can only be created via the public API by using the +, -, *, and / operatations on AbstractYield objects.\n\nAs this is double the normal operations when performing calculations, if you are using the curve in performance critical locations, you should consider transforming the inputs and  constructing a single curve object ahead of time.\n\nCurves can be added or subtracted together, but note that this is not always the same thing as adding or subtracting spreads with rates. If spreads and base rates are expressed as zero rates, then the curve addition/subtraction has the same effect as re-fitting the yield model with the rate+spread inputs added together first. Non-zero rates (e.g. par rates) do not have this same property. Zero-coupon rates have a direct, linear relationship with the underlying discount factors. Par-coupon rates have a complex, non-linear relationship with the underlying discount factors and so the curve addition/subtraction does not work the same way.\n\nExamples\n\nrates = [0.01, 0.01, 0.03, 0.05, 0.07, 0.16, 0.35, 0.92, 1.40, 1.74, 2.31, 2.41] ./ 100\nspreads = [0.01, 0.01, 0.03, 0.05, 0.07, 0.16, 0.35, 0.92, 1.40, 1.74, 2.31, 2.41] ./ 100\nmats = [1 / 12, 2 / 12, 3 / 12, 6 / 12, 1, 2, 3, 5, 7, 10, 20, 30]\n\n\n### Zero coupon rates/spreads\n\nq_rf_z = ZCBYield.(rates,mats)\nq_s_z = ZCBYield.(spreads,mats)\nq_y_z = ZCBYield.(rates + spreads,mats)\n\nc_rf_z = fit(Spline.Linear(),q_rf_z,Fit.Bootstrap())\nc_s_z = fit(Spline.Linear(),q_s_z,Fit.Bootstrap())\nc_y_z = fit(Spline.Linear(),q_y_z,Fit.Bootstrap())\n\n# adding curves when the spreads were zero spreads works\n@test discount(c_rf_z+c_s_z,20) ≈ discount(c_y_z,20)\n\n\n### Par coupon rates/spreads\n\nq_rf = CMTYield.(rates,mats)\nq_s = CMTYield.(spreads,mats)\nq_y = CMTYield.(rates + spreads,mats)\n\nc_rf = fit(Spline.Linear(),q_rf,Fit.Bootstrap())\nc_s = fit(Spline.Linear(),q_s,Fit.Bootstrap())\nc_y = fit(Spline.Linear(),q_y,Fit.Bootstrap())\n\n# adding curves when the spreads were par spreads does not work\n@test !(discount(c_rf+c_s,20) ≈ discount(c_y,20))\n\n\n\n\n\n","category":"type"},{"location":"API/Yield/#FinanceModels.Yield.Constant","page":"Yield","title":"FinanceModels.Yield.Constant","text":"Constant(rate)\n\nA yield curve representing a flat term structure. rate can be a Rate object or a Real object.\n\nIf fiting with the default FinanceModels.jl settings, the solver will attempt to fit a discount rate with the range of: -1.0 .. 1.0\n\n\n\n\n\n","category":"type"},{"location":"API/Yield/#FinanceModels.Yield.ForwardStarting","page":"Yield","title":"FinanceModels.Yield.ForwardStarting","text":"ForwardStarting(curve,forwardstart)\n\nRebase a curve so that discount/accumulation/etc. are re-based so that time zero from the new curves perspective is the given forwardstart time.\n\nExamples\n\njulia> zero = [5.0, 5.8, 6.4, 6.8] ./ 100\njulia> maturity = [0.5, 1.0, 1.5, 2.0]\njulia> curve = Yields.Zero(zero, maturity)\njulia> fwd = Yields.ForwardStarting(curve, 1.0)\n\njulia> FinanceCore.discount(curve,1,2)\n0.9275624570410582\n\njulia> FinanceCore.discount(fwd,1) # `curve` has effectively been reindexed to `1.0`\n0.9275624570410582\n\nExtended Help\n\nWhile ForwardStarting could be nested so that, e.g. the third period's curve is the one-period forward of the second period's curve, it will be more efficient to reuse the initial curve from a runtime and compiler perspective.\n\nForwardStarting is not used to construct a curve based on forward rates. \n\n\n\n\n\n","category":"type"},{"location":"API/Yield/#FinanceModels.Yield.MonotoneConvex","page":"Yield","title":"FinanceModels.Yield.MonotoneConvex","text":"MonotoneConvex(rates, times)\n\nA Monotone Convex yield curve model implementing the Hagan-West interpolation method.\n\nThis interpolation method guarantees:\n\nContinuous forward rates\nPositive forward rates (when input rates imply positive forwards)\nMonotone convex forward curves that match discrete forward rates at knot points\n\nThe implementation follows the Hagan-West method as described in WILMOTT magazine.\n\nExamples\n\nprices = [0.98, 0.955, 0.92, 0.88, 0.830]\ntimes = [1, 2, 3, 4, 5]\nrates = @. -log(prices) / times\n\nc = Yield.MonotoneConvex(rates, times)\nzero(c, 2.5)  # Get the zero rate at t=2.5\ndiscount(c, 2.5)  # Get the discount factor at t=2.5\n\nReferences\n\nHagan & West, \"Interpolation Methods for Curve Construction\", WILMOTT magazine\nDehlbom, \"Interpolation of the yield curve\" (http://uu.diva-portal.org/smash/get/diva2:1477828/FULLTEXT01.pdf)\n\n\n\n\n\n","category":"type"},{"location":"API/Yield/#FinanceModels.Yield.NelsonSiegel","page":"Yield","title":"FinanceModels.Yield.NelsonSiegel","text":"NelsonSiegel(β₀, β₁, β₂, τ₁)\nNelsonSiegel(τ₁=1.0) # used in fitting\n\nA Nelson-Siegel yield curve model  Parameters of Nelson and Siegel (1987) parametric model, along with default parameter ranges used in the fitting:\n\nβ₀ represents a long-term interest rate: -10.0 .. 10.0\nβ₁ represents a time-decay component: -10.0 .. 10.0\nβ₂ represents a hump: -10.0 .. 10.0\nτ₁ controls the location of the hump: 0.0 .. 100.0\n\nExamples\n\njulia> β₀, β₁, β₂, τ₁ = 0.6, -1.2, -1.9, 3.0\njulia> nsm = Yields.NelsonSiegel.(β₀, β₁, β₂, τ₁)\n\n# Extended Help\n\nNelsonSiegel has generally been replaced by NelsonSiegelSvensson, which is a more flexible model.\n\n## References\n- https://onriskandreturn.com/2019/12/01/nelson-siegel-yield-curve-model/\n- https://www.bis.org/publ/bppdf/bispap25.pdf\n\n\n\n\n\n\n","category":"type"},{"location":"API/Yield/#FinanceModels.Yield.NelsonSiegelSvensson","page":"Yield","title":"FinanceModels.Yield.NelsonSiegelSvensson","text":"NelsonSiegelSvensson(τ₁, τ₂, β₀, β₁, β₂, β₃)\nNelsonSiegelSvensson(τ₁=1.0, τ₂=1.0)\n\nReturn the NelsonSiegelSvensson yield curve. The rates should be continuous zero spot rates. If rates are not Rates, then they will be interpreted as Continuous Rates.\n\nParameters of Svensson (1994) parametric model, along with the default parameter bounds used in the fit routine:\n\nτ₁ controls the location of the hump: 0.0 .. 100.0\nτ₁ controls the location of the second hump: 0.0 .. 100.0\nβ₀ represents a long-term interest rate: -10.0 .. 10.0\nβ₁ represents a time-decay component: -10.0 .. 10.0\nβ₂ represents a hump: -10.0 .. 10.0\nβ₃ represents a second hump: -10.0 .. 10.0\n\nExamples\n\njulia> β₀, β₁, β₂, β₃, τ₁, τ₂ = 0.6, -1.2, -2.1, 3.0, 1.5\njulia> nssm = NelsonSiegelSvensson.NelsonSiegelSvensson.(β₀, β₁, β₂, β₃, τ₁, τ₂)\n\n# Extended Help\n\nNelson-Siegel-Svensson Pros:\n\n- Simplicity: With only six parameters, the model is quite parsimonious and easy to estimate. It's also easier to interpret and communicate than more complex models.\n- Economic Interpretability: Each of the model's components can be given an economic interpretation, with parameters representing long term rate, short term rate, the rates of decay towards the long term rate, and humps in the yield curve.\n\nNelson-Siegel-Svensson Cons:\n\n- Unusual Curves: NSS makes some assumptions about the shape of the yield curve (e.g. generally has a hump in short to medium term maturities). It might not be the best choice for fitting unusual curves.\n- Arbitrage Opportunities: The NSS model does not guarantee absence of arbitrage opportunities. More sophisticated models, like the ones based on no-arbitrage conditions, might provide better pricing accuracy in some contexts.\n- Sensitivity: Similar inputs may produce different parameters due to the highly convex, non-linear region to solve for the parameters. Entities like the ECB will partially mitigate this by using the prior business day's parameters as the starting point for the current day's yield curve.\n\n## References\n- https://onriskandreturn.com/2019/12/01/nelson-siegel-yield-curve-model/\n- https://www.bis.org/publ/bppdf/bispap25.pdf\n\n\n\n\n\n\n","category":"type"},{"location":"API/Yield/#FinanceModels.Yield.SmithWilson","page":"Yield","title":"FinanceModels.Yield.SmithWilson","text":"Yield.SmithWilson(u, qb; ufr=ufr, α=α)\nYield.SmithWilson(;ufr=ufr, α=α)\n\nCreate a yield curve object that implements the Smith-Wilson interpolation/extrapolation scheme.\n\nTo calibrate a curve, you generally want to construct the object without the u and qb arguments and call fit in conjunction with Quotes (fit requires no third parameter for SmithWilson curves). See Examples for what this looks like.  Positional arguments to construct a curve:\n\nA curve can be with u is the timepoints coming from the calibration, and qb is the internal parameterization of the curve that ensures that the calibration is correct. Users may prefer the other constructors but this mathematical constructor is also available.\n\nRequired keyword arguments:\n\nufr is the Ultimate Forward Rate, the forward interest rate to which the yield curve tends, in continuous compounding convention. \nα is the parameter that governs the speed of convergence towards the Ultimate Forward Rate. It can be typed with \\alpha[TAB]\n\nExamples\n\ntimes = [1.0, 2.5, 5.6]\nprices = [0.9, 0.7, 0.5]\nqs = ZCBPrice.(prices, times)\n\nufr = 0.03\nα = 0.1\n\nmodel = fit(Yield.SmithWilson(ufr=ufr, α=α), qs)\n\nExtended Help\n\nReferences\n\nSmith-Wilson Yields Curves\nA Technical Note on the Smith-Wilson Method\n\n\n\n\n\n","category":"type"},{"location":"API/Yield/#Base.:*-Tuple{FinanceModels.Yield.AbstractYieldModel, FinanceModels.Yield.AbstractYieldModel}","page":"Yield","title":"Base.:*","text":"Yields.AbstractYieldModel * Yields.AbstractYieldModel\n\nThe multiplication of two yields will create a CompositeYield. For rate, discount, and accumulation purposes the spot rates of the two curves will be added together. This can be useful, for example, if you wanted to after-tax a yield.\n\nExamples\n\njulia> m = Yields.Constant(0.01) * 0.79;\n\njulia> accumulation(m,1)\n1.0079\n\njulia> accumulation(.01*.79,1)\n1.0079\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#Base.:+-Tuple{FinanceModels.Yield.AbstractYieldModel, FinanceModels.Yield.AbstractYieldModel}","page":"Yield","title":"Base.:+","text":"Yields.AbstractYieldModel + Yields.AbstractYieldModel\n\nThe addition of two yields will create a CompositeYield. For rate, discount, and accumulation purposes the spot rates of the two curves will be added together.\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#Base.:--Tuple{FinanceModels.Yield.AbstractYieldModel, FinanceModels.Yield.AbstractYieldModel}","page":"Yield","title":"Base.:-","text":"Yields.AbstractYieldModel - Yields.AbstractYieldModel\n\nThe subtraction of two yields will create a CompositeYield. For rate, discount, and accumulation purposes the spot rates of the second curves will be subtracted from the first.\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#Base.:/-Tuple{FinanceModels.Yield.AbstractYieldModel, FinanceModels.Yield.AbstractYieldModel}","page":"Yield","title":"Base.:/","text":"Yields.AbstractYieldModel / Yields.AbstractYieldModel\n\nThe division of two yields will create a CompositeYield. For rate, discount, and accumulation purposes the spot rates of the two curves will have the first divided by the second. This can be useful, for example, if you wanted to gross-up a yield to be pre-tax.\n\nExamples\n\njulia> m = Yields.Constant(0.01) / 0.79;\n\njulia> accumulation(d,1)\n1.0126582278481013\n\njulia> accumulation(.01/.79,1)\n1.0126582278481013\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#FinanceCore.accumulation-Tuple{FinanceModels.Yield.AbstractYieldModel, Any}","page":"Yield","title":"FinanceCore.accumulation","text":"accumulation(yc, from, to)\n\nThe accumulation factor for the yield curve yc for times from through to.\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#FinanceModels.Yield.H-Union{Tuple{T}, Tuple{Any, T, T}} where T","page":"Yield","title":"FinanceModels.Yield.H","text":"H(α, t1, t2)\n\nThe Smith-Wilson H function implemented in a faster way.\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#FinanceModels.Yield.H_ordered-Tuple{Any, Any, Any}","page":"Yield","title":"FinanceModels.Yield.H_ordered","text":"H_ordered(α, t_min, t_max)\n\nThe Smith-Wilson H function with ordered arguments (for better performance than using min and max).\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#FinanceModels.Yield.__i_time-Tuple{Any, Any}","page":"Yield","title":"FinanceModels.Yield.__i_time","text":"returns the index associated with the time t, an initial rate vector, and a time vector\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#FinanceModels.Yield.__monotone_convex_fs-Tuple{Any, Any}","page":"Yield","title":"FinanceModels.Yield.__monotone_convex_fs","text":"returns a pair of vectors (f and fᵈ) used in Monotone Convex Yield Curve fitting\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#FinanceModels.Yield.g-NTuple{4, Any}","page":"Yield","title":"FinanceModels.Yield.g","text":"g(x, f⁻, f, fᵈ)\n\nCompute the deviation of the instantaneous forward rate from the discrete forward rate at normalized position x ∈ [0, 1] within an interval. Following Hagan-West, g(x) = f(x) - fᵈ with boundary conditions g₀ = f⁻ - fᵈ and g₁ = f - fᵈ that determine the sector-specific polynomial used for interpolation.\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#FinanceModels.Yield.g_rate-NTuple{4, Any}","page":"Yield","title":"FinanceModels.Yield.g_rate","text":"g_rate(x, f⁻, f, fᵈ)\n\nCompute the integrated deviation G(x) = ∫₀ˣ g(u) du, which captures how the instantaneous forward curve deviates from the discrete forward across an interval. This quantity feeds into the zero-rate relation r(t) = fᵈ + (Δt / t) ⋅ G(x) used by the Hagan-West construction.\n\n\n\n\n\n","category":"method"},{"location":"API/Bond/#FinanceModels.Bond-API-Reference","page":"Bond","title":"FinanceModels.Bond API Reference","text":"Modules = [FinanceModels.Bond]","category":"section"},{"location":"API/Bond/#Exported-API","page":"Bond","title":"Exported API","text":"","category":"section"},{"location":"API/Bond/#Unexported-API","page":"Bond","title":"Unexported API","text":"Please open an issue if you encounter any issues or confusion with the package.","category":"section"},{"location":"API/Bond/#FinanceModels.Bond","page":"Bond","title":"FinanceModels.Bond","text":"The Bond module provide a number of fixed-income contracts and related methods.\n\n\n\n\n\n","category":"module"},{"location":"API/Bond/#FinanceModels.Bond.CMTYield-Tuple{Any, Any}","page":"Bond","title":"FinanceModels.Bond.CMTYield","text":"CMTYield(yield,maturity)\nCMTYield(yield::Vector)\n\nReturns a Quote for the correpsonding bond implied by the given bond equivalent yield, and assumes that instruments <= one year maturity` pay no coupons and that the rest pay semi-annual.\n\nUse broadcasting to create a set of quotes given a collection of FinanceModels and maturities, e.g. CMTYield.(FinanceModels,maturities).\n\nSee also FinanceCore.Quote, Bond.Fixed\n\nExamples\n\njulia> CMTYield(0.05,10)\nQuote{Float64, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}}(1.0, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}(0.05, Periodic(2), 10))\n\n\n\n\n\n","category":"method"},{"location":"API/Bond/#FinanceModels.Bond.ParSwapYield-Tuple{Any, Any}","page":"Bond","title":"FinanceModels.Bond.ParSwapYield","text":"ParSwapYield(yield, maturity; frequency=Periodic(4))\n\nSame as ParYield, except the frequency is four times per period by default.\n\n\n\n\n\n","category":"method"},{"location":"API/Bond/#FinanceModels.Bond.ParYield-Tuple{Any, Any}","page":"Bond","title":"FinanceModels.Bond.ParYield","text":"ParYield(yield, maturity; frequency=Periodic(2)) ParYield(yield::Vector)\n\nTakes bond equivalent FinanceModels, and assumes that instruments <= one year maturity pay no coupons and that the rest pay semi-annual. Alternative, you may pass a Rate as the yield and the coupon frequency will be inferred from the Rate's frequency. \n\nUse broadcasting to create a set of quotes given a collection of FinanceModels and maturities, e.g. ParYield.(FinanceModels,maturities).\n\nExamples\n\njulia> ParYield(0.05,10)\nQuote{Float64, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}}(1.0, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}(0.05, Periodic(2), 10))\n\n\n\n\n\n","category":"method"},{"location":"API/Bond/#FinanceModels.Bond.ZCBPrice-Tuple{Any, Any}","page":"Bond","title":"FinanceModels.Bond.ZCBPrice","text":"ZCBPrice(discount,maturity)\nZCBPrice(yield::Vector)\n\nTakes spot/zero discount factors and returns a Quote for the cashflow occuring at the given maturity.\n\nUse broadcasting to create a set of quotes given a collection of prices and maturities, e.g. ZCBPrice.(FinanceModels,maturities).\n\nSee also ZCBYield\n\nExamples\n\n\njulia> ZCBPrice(0.5,10)\nQuote{Float64, Cashflow{Float64, Int64}}(0.5, Cashflow{Float64, Int64}(1.0, 10))\n\njulia> ZCBPrice([0.9,0.8,0.75])\n3-element Vector{Quote{Float64, Cashflow{Float64, Int64}}}:\n Quote{Float64, Cashflow{Float64, Int64}}(0.9, Cashflow{Float64, Int64}(1.0, 1))\n Quote{Float64, Cashflow{Float64, Int64}}(0.8, Cashflow{Float64, Int64}(1.0, 2))\n Quote{Float64, Cashflow{Float64, Int64}}(0.75, Cashflow{Float64, Int64}(1.0, 3))\n \n\n\n\n\n\n","category":"method"},{"location":"API/Bond/#FinanceModels.Bond.ZCBYield-Tuple{Any, Any}","page":"Bond","title":"FinanceModels.Bond.ZCBYield","text":"ZCBYield(yield,maturity)\nZCBYield(yield::Vector)\n\nReturns a Quote for the cashflow occuring at the given maturity and the quoted value is derived from the given yield.\n\nTakes zero (sometimes called \"spot\") rates. Assumes annual effective compounding (Periodic(1)) unless given aRate` with a different compounding frequency.\n\nUse broadcasting to create a set of quotes given a collection of FinanceModels and maturities, e.g. ZCBYield.(FinanceModels,maturities).\n\nSee also ZCBPrice\n\nExamples\n\njulia> ZCBYield(0.05,30)\nQuote{Float64, Cashflow{Float64, Int64}}(0.23137744865585788, Cashflow{Float64, Int64}(1.0, 30))\n\njulia> ZCBYield(Periodic(0.05,1),30)\nQuote{Float64, Cashflow{Float64, Int64}}(0.23137744865585788, Cashflow{Float64, Int64}(1.0, 30))\n\njulia> ZCBYield(Continuous(0.05),30)\nQuote{Float64, Cashflow{Float64, Int64}}(0.22313016014842982, Cashflow{Float64, Int64}(1.0, 30))\n\njulia> ZCBYield([0.04,0.05,0.045])\n3-element Vector{Quote{Float64, Cashflow{Float64, Int64}}}:\n Quote{Float64, Cashflow{Float64, Int64}}(0.9615384615384615, Cashflow{Float64, Int64}(1.0, 1))\n Quote{Float64, Cashflow{Float64, Int64}}(0.9070294784580498, Cashflow{Float64, Int64}(1.0, 2))\n Quote{Float64, Cashflow{Float64, Int64}}(0.8762966040549094, Cashflow{Float64, Int64}(1.0, 3))\n\n\n\n\n\n","category":"method"},{"location":"API/Bond/#FinanceModels.Bond.Fixed","page":"Bond","title":"FinanceModels.Bond.Fixed","text":"Bond.Fixed(coupon_rate,frequency<:FinanceCore.Frequency,maturity)\n\nAn object representing a fixed coupon bond. coupon_rate / frequency is the actual payment amount.\n\nNote that there are a number of convienience constructors which return a Quote for a Bond.Fixed: \n\nParYield\nParSwapYield\nCMTYield\nOISYield\n\nSee also FinanceCore.Quote.\n\nExamples\n\njulia> Bond.Fixed(0.05,Periodic(2),3)\nFinanceModels.Bond.Fixed{Periodic, Float64, Int64}(0.05, Periodic(2), 3)\n\njulia> Bond.Fixed(0.05,Periodic(2),3) |> collect\n6-element Vector{Cashflow{Float64, Float64}}:\n Cashflow{Float64, Float64}(0.025, 0.5)\n Cashflow{Float64, Float64}(0.025, 1.0)\n Cashflow{Float64, Float64}(0.025, 1.5)\n Cashflow{Float64, Float64}(0.025, 2.0)\n Cashflow{Float64, Float64}(0.025, 2.5)\n Cashflow{Float64, Float64}(1.025, 3.0)\n\n\njulia> ParYield(0.05,10)\nQuote{Float64, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}}(1.0, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}(0.05, Periodic(2), 10))\n\n\n\n\n\n","category":"type"},{"location":"API/Bond/#FinanceModels.Bond.Floating","page":"Bond","title":"FinanceModels.Bond.Floating","text":"Bond.Floating(coupon_rate,frequency<:FinanceCore.Frequency,maturity,model_key)\n\nAn object representing a floating coupon bond. (coupon_rate + reference rate) / frequency is the actual payment amount, where the reference rate requires a Projection with a key/value pair where the key is the model_key argument and the value is the model which produces the reference rate.\n\nSee also FinanceCore.Quote.\n\nExamples\n\njulia> p = Projection(\n        Bond.Floating(0.02, Periodic(1), 3.0, \"SOFR\"),\n        Dict(\"SOFR\" => Yield.Constant(0.05)),  # note the key/value store used for the model in the projection\n        CashflowProjection(),\n    );\n\njulia> collect(p)\n3-element Vector{Cashflow{Float64, Float64}}:\n    Cashflow{Float64, Float64}(0.07000000000000005, 1.0)\n    Cashflow{Float64, Float64}(0.07000000000000005, 2.0)\n    Cashflow{Float64, Float64}(1.07, 3.0)\n\n\n\n\n\n","category":"type"},{"location":"API/Bond/#FinanceModels.Bond.ForwardYields","page":"Bond","title":"FinanceModels.Bond.ForwardYields","text":"ForwardYields(yields,times)\n\nReturns a vector of Quote corresponding to the yield at the given forward times. \n\nExamples\n\njulia> FinanceModels.Bond.ForwardYields([0.01,0.02],[1.,3.])\n2-element Vector{Quote{Float64, Cashflow{Float64, Float64}}}:\n Quote{Float64, Cashflow{Float64, Float64}}(0.9900990099009901, Cashflow{Float64, Float64}(1.0, 1.0))\n Quote{Float64, Cashflow{Float64, Float64}}(0.9423223345470445, Cashflow{Float64, Float64}(1.0, 3.0))\n\n\n\n\n\n","category":"function"},{"location":"API/Bond/#FinanceModels.Bond.OISYield-Tuple{Any, Any}","page":"Bond","title":"FinanceModels.Bond.OISYield","text":"OISYield(yield, maturity)\n\nReturns the implied Quote for the fixed bond implied by the given yield and maturity. Assumes that maturities less than or equal to 12 months are settled once (per Hull textbook, 4.7), otherwise quarterly and that the FinanceModels given are bond equivalent.\n\nUse broadcasting to create a set of quotes given a collection of FinanceModels and maturities, e.g. OISYield.(FinanceModels,maturities).\n\nSee also FinanceCore.Quote, Bond.Fixed\n\nExamples\n\njulia> OISYield(0.05,10)\nQuote{Float64, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}}(1.0, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}(0.05, Periodic(4), 10))\n\n\n\n\n\n","category":"method"},{"location":"API/Bond/#FinanceModels.Bond.coupon_times-Tuple{Any, Any}","page":"Bond","title":"FinanceModels.Bond.coupon_times","text":"coupon_times(maturity, frequency)\n\nGenerate coupon times for a bond with the given maturity and frequency.\n\nArguments\n\nmaturity::Real: The maturity of the bond.\nfrequency::Real: The coupon frequency of the bond.\n\nReturns\n\nAn array of coupon times for the bond.\n\nExamples\n\njulia-repl julia> Bond.coupon_times(10, 2) 0.5:0.5:10.0 julia> Bond.coupon_times(Bond.Fixed(0.05,Periodic(4),20)) 0.25:0.25:20.0`\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceModels/#FinanceModels-API-Reference","page":"FinanceModels","title":"FinanceModels API Reference","text":"Modules = [FinanceModels]","category":"section"},{"location":"API/FinanceModels/#Exported-API","page":"FinanceModels","title":"Exported API","text":"","category":"section"},{"location":"API/FinanceModels/#Unexported-API","page":"FinanceModels","title":"Unexported API","text":"Please open an issue if you encounter any issues or confusion with the package.","category":"section"},{"location":"API/FinanceModels/#FinanceModels.CashflowProjection","page":"FinanceModels","title":"FinanceModels.CashflowProjection","text":"CashflowProjection()\n\nA concrete subtype of ProjectionKind which is the projection which returns only a reducible collection of Cashflows. Use in conjunction with a Projection.\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceModels/#FinanceModels.CommonEquity","page":"FinanceModels","title":"FinanceModels.CommonEquity","text":"CommonEquity()\n\nA singleton type representing a unit stock.\n\nSee also: Option.\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceModels/#FinanceModels.Forward","page":"FinanceModels","title":"FinanceModels.Forward","text":"Forward(time,instrument)\n\nThe instrument is relative to the Forward time. e.g. if you have a Forward(1.0, Cashflow(1.0, 3.0)) then the instrument is a cashflow that pays 1.0 at time 4.0\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceModels/#FinanceModels.NullModel","page":"FinanceModels","title":"FinanceModels.NullModel","text":"NullModel()\n\nA singleton type representing a placeholder model for when you don't really need a model. For example: determining nominal cashflows for fixed income contract.\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceModels/#FinanceModels.Projection","page":"FinanceModels","title":"FinanceModels.Projection","text":"Projection(contract,model,kind)\n\nThe set of contracts and assumptions (model) to project the kind of output desired. Some assets require a projection in order to be valued (e.g. a floating rate bond).\n\nIf attempting to collect or otherwise reduce a contract (<:AbstractContract), by default it will get wrapped into a Projection(contract,NullModel(),CashflowProjection())\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceModels/#FinanceCore.internal_rate_of_return-Tuple{Quote}","page":"FinanceModels","title":"FinanceCore.internal_rate_of_return","text":"FinanceCore.internal_rate_of_return(q::Quote)\n\nReturn the internal rate of return (yield to maturity) implied by the quote's price and cashflows.\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceModels/#FinanceCore.present_value","page":"FinanceModels","title":"FinanceCore.present_value","text":"present_value(model,contract,current_time=0.0)\npresent_value(model,projection,current_time=0.0)\n\nReturn the value of the contract as corresponding with the valuation assumptions embedded in the model for the given contract or projection with CashflowProjection kind.\n\nExamples\n\nm = Equity.BlackScholesMerton(0.01, 0.02, 0.15)\n\na = Option.EuroCall(CommonEquity(), 1.0, 1.0)\n\npv(m, a) # ≈ 0.05410094201902403\n\n\n\n\n\n","category":"function"},{"location":"API/FinanceModels/#FinanceModels.InterestRateSwap-Tuple{Any, Any}","page":"FinanceModels","title":"FinanceModels.InterestRateSwap","text":"InterestRateSwap(curve, tenor; model_key=\"OIS\")\n\nA convenience method for creating an interest rate swap given a curve and a tenor via a Composite contract consisting of receiving a fixed bond and paying (i.e. the negative of) a floating bond.\n\nThe notional is a unit (1.0) amount and assumed to settle four times per period.\n\nA Projection, with an indexable model_key is still needed to project a swap. See examples below for what this looks like.\n\nExamples\n\n\njulia> curve = Yield.Constant(0.05);\n\njulia> swap = InterestRateSwap(curve,10);\n\njulia> Projection(swap,Dict(\"OIS\" => curve),CashflowProjection()) |> collect\n80-element Vector{Cashflow{Float64, Float64}}:\nCashflow{Float64, Float64}(0.012272234429039353, 0.25)\nCashflow{Float64, Float64}(0.012272234429039353, 0.5)\n⋮\nCashflow{Float64, Float64}(-0.012272234429039353, 9.75)\nCashflow{Float64, Float64}(-1.0122722344290391, 10.0)\n\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceModels/#FinanceModels.fit-Union{Tuple{F}, Tuple{Any, Any}, Tuple{Any, Any, F}} where F<:FinanceModels.Fit.Loss","page":"FinanceModels","title":"FinanceModels.fit","text":"fit(\n    model, \n    quotes, \n    method=Fit.Loss(x -> x^2);\n    variables=__default_optic(model), \n    optimizer=__default_optim(model)\n    )\n\nFit a model to a collection of quotes using a loss function and optimization method.\n\nArguments\n\nmodel: The initial model to fit, which is generally an instantiated but un-optimized model.\nquotes: A collection of quotes to fit the model to.\nmethod::F=Fit.Loss(x -> x^2): The loss function to use for fitting the model. Defaults to the squared loss function. \nmethod can also be Bootstrap(). If this is the case, model should be a spline such as Spline.Linear(), Spline.Cubic()...\nvariables=__default_optic(model): The variables to optimize over. This is a tuple of optic => interval pairs specifying which parameters of the model can vary. See extended help for more.\noptimizer=__default_optim(model): The optimization algorithm to use. The default optimization for a given model is LBFGS() from Optim.jl (via OptimizationOptimJL), a quasi-Newton method with automatic differentiation via ForwardDiff. See extended help for more on customizing the solver.\n\nThe optimization routine will then attempt to modify parameters of model to best fit the quoted prices of the contracts underlying the quotes by calling present_value(model,contract). The optimization will minimize the loss function specified within Fit.Loss(...). \n\nDifferent types of quotes are appropriate for different kinds of models. For example, if you try to value a set of equtiy EuroCalls with a Yield.Constant, you will get an error because the present_value(m<:Yield.Constant,o<:EuroCall) is not defined.\n\nReturns\n\nThe fitted model.\n\nExamples\n\njulia> model = Yield.Constant();\n\njulia> quotes = ZCBPrice([0.9, 0.8, 0.7,0.6]);\n\njulia> fit(model,quotes)\n\n              ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Yield Curve (FinanceModels.Yield.Constant)⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀           \n              ┌────────────────────────────────────────────────────────────┐           \n     0.120649 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ Zero rates\n              │⠀⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⣧⢰⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⣿⣾⠀⣀⣸⠀⢸⢳⣇⢀⣀⣀⣀⣀⣀⠀⡀⣀⣀⣀⡀⡀⣀⢀⣀⡀⡀⣀⢀⡀⣀⡀⢀⣀⡀⢀⡀⢀⣀⡀⢀⡀⠀⣀⡀⢀⡀⢀⣀⡀⢀⣀⠀⣀⡀⢀⣀⠀⢀│           \n              │⢠⢻⡟⡆⣿⡟⣦⠚⠀⢸⣾⠛⠛⠘⠛⠘⢲⡗⠛⠃⠛⠓⠓⠛⠚⠛⠑⠓⠛⠃⠓⠛⠑⠚⡟⠓⢻⡗⠚⠀⠓⠚⠑⠒⠃⠓⠚⠑⠚⠀⠓⠃⠘⠒⠃⠓⠃⠘⠒⠃│           \n              │⢸⢸⡇⢹⡏⠁⠉⠀⠀⠈⠉⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⠈⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n   Continuous │⢸⢸⡇⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⢸⠀⠁⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⢸⠀⠀⠘⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⡎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n     0.120649 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              └────────────────────────────────────────────────────────────┘           \n              ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀time⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀30⠀  \n\n\nExtended help\n\nCustomizing the Solver\n\nThe default solver is LBFGS() from Optim.jl (via OptimizationOptimJL). This is a quasi-Newton method that uses automatic differentiation (ForwardDiff) to compute gradients efficiently.\n\nAny solver from OptimizationOptimJL can be used, e.g. fit(...; optimizer=OptimizationOptimJL.Newton()) or fit(...; optimizer=OptimizationOptimJL.NelderMead()).\nMore documentation is available from the upstream packages:\nOptim.jl\nOptimization.jl\nAccessibleModels.jl\n\nDefining the variables\n\nAn arbitrarily complex model may be the object we intend to fit - how does fit know what free variables are able to be solved for within the given model? variables is a tuple of optic => interval pairs. What does this mean?\n\nAn optic (or \"lens\") is a way to define an accessor to a given object. Example:\n\njulia> using Accessors, AccessibleModels, IntervalSets\n\njulia> obj = (a = \"AA\", b = \"BB\");\n\njulia> lens = @optic _.a\n(@optic _.a)\n\njulia> lens(obj)\n\"AA\"\n\nAn optic argument is a tuple of optic => interval pairs. For example, we might have a model as follows where we want  fit to optimize parameters a and b:\n\nstruct MyModel <:FinanceModels.AbstractModel\n     a \n     b \nend\n\n__default_optic(m::MyModel) = (\n    @optic(_.a) => 0.0 .. 100.0,\n    @optic(_.b) => -10.0 .. 10.0,\n)\n\nIn this way, fit know which arbitrary parameters in a given object may be modified. Technically, we are not modifying the immutable MyModel, but instead efficiently creating a new instance. This is enabled by AccessibleModels.jl.\n\nNote that not all optimization algorithms want a bounded interval. In that case, simply leave off the paired range. The prior example would then become:\n\n__default_optic(m::MyModel) = (\n    (@optic(_.a),),\n    (@optic(_.b),),\n)\n\n```\n\nAdditional Examples\n\nSee the tutorials in the package documentation for FinanceModels.jl or the docstrings of FinanceModels.jl's available model types.\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceModels/#FinanceModels.ProjectionKind","page":"FinanceModels","title":"FinanceModels.ProjectionKind","text":"abstract type ProjectionKind\n\nAn abstract type that controls what gets produced from the model.\n\nSubtypes of ProjectionKind define the level of detail in the output of the model. For example, if you just want cashflows or you want a full amortization schedule, you might define an AmortizationSchedule kind which shows principle, interest, etc.\n\nAfter defining a new ProjectionKind, you need to define the how the projection works for that new output by extending either:\n\nfunction Transducers.asfoldable(p::Projection{C,M,K}) where {C<:Cashflow,M,K<:CashflowProjection}\n    ...\nend\n\nor \n\nfunction Transducers.__foldl__(rf, val, p::Projection{C,M,K}) where {C<:Cashflow,M,K<:CashflowProjection}\n    ...\nend\n\nThere are examples of this in the documentation.\n\nExamples\n\n```julia julia> struct CashflowProjection <: ProjectionKind end CashflowProjection\n\njulia> struct AmortizationSchedule <: ProjectionKind end AmortizationSchedule\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceModels/#FinanceModels.__default_optic-Tuple{FinanceModels.Yield.Constant}","page":"FinanceModels","title":"FinanceModels.__default_optic","text":"__default_optic(model)\n\nReturns the variables to optimize over for the given model. This is an optic/lens specifying which parameters of the model can vary. See extended help for more. An optic argument is a tuple of optic => interval pairs specifying which model parameters to optimize and their bounds.\n\nExamples\n\nWe might have a model as follows where we want fit to optize parameters a and b:\n\nstruct MyModel <:FinanceModels.AbstractModel\n        a \n        b \nend\n\n__default_optic(m::MyModel) = (\n    @optic(_.a) => 0.0 .. 100.0,\n    @optic(_.b) => -10.0 .. 10.0,\n)\n\nExtended help\n\nAn arbitrarily complex model may be the object we intend to fit - how does fit know what free variables are able to be solved for within the given model? variables is a tuple of optic => interval pairs. What does this mean?\n\nAn optic (or \"lens\") is a way to define an accessor to a given object. Example:\n\njulia> using Accessors, AccessibleModels, IntervalSets\n\njulia> obj = (a = \"AA\", b = \"BB\");\n\njulia> lens = @optic _.a\n(@optic _.a)\n\njulia> lens(obj)\n\"AA\"\n\nAn optic argument is a tuple of optic => interval pairs. For example, we might have a model as follows where we want  fit to optize parameters a and b:\n\nstruct MyModel <:FinanceModels.AbstractModel\n        a \n        b \nend\n\n__default_optic(m::MyModel) = (\n    @optic(_.a) => 0.0 .. 100.0,\n    @optic(_.b) => -10.0 .. 10.0,\n)\n\nIn this way, fit know which arbitrary parameters in a given object may be modified. Technically, we are not modifying the immutable MyModel, but instead efficiently creating a new instance. This is enabled by AccessibleModels.jl.\n\nNote that not all optimization algorithms want a bounded interval. In that case, simply leave off the paired range. The prior example would then become:\n\n__default_optic(m::MyModel) = (\n    (@optic(_.a),),\n    (@optic(_.b),),\n)\n\n```\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceModels/#FinanceModels.__rewrap-Tuple{Transducers.Reduction, Any}","page":"FinanceModels","title":"FinanceModels.__rewrap","text":"__rewrap(from::Transducers.Reduction, to)\n__rewrap(from, to)\n\nUsed to unwrap a Reduction which is a composition of contracts and a transducer and apply the transducers to the associated projection instead of the transducer.\n\nFor example, on its own a contract is not project-able, but wrapped in a (default) Projection it can be. But it may also be a lot more convienent  to construct contracts which have scaling or negated modifications and let that flow into a projection.\n\nExamples\n\njulia> Bond.Fixed(0.05,Periodic(1),3) |> collect\n3-element Vector{Cashflow{Float64, Float64}}:\n Cashflow{Float64, Float64}(0.05, 1.0)\n Cashflow{Float64, Float64}(0.05, 2.0)\n Cashflow{Float64, Float64}(1.05, 3.0)\n\njulia> Bond.Fixed(0.05,Periodic(1),3) |> Map(-) |> collect\n3-element Vector{Cashflow{Float64, Float64}}:\n Cashflow{Float64, Float64}(-0.05, 1.0)\n Cashflow{Float64, Float64}(-0.05, 2.0)\n Cashflow{Float64, Float64}(-1.05, 3.0)\n\njulia> Bond.Fixed(0.05,Periodic(1),3) |> Map(-) |> Map(x->x*2) |> collect\n3-element Vector{Cashflow{Float64, Float64}}:\n Cashflow{Float64, Float64}(-0.1, 1.0)\n Cashflow{Float64, Float64}(-0.1, 2.0)\n Cashflow{Float64, Float64}(-2.1, 3.0)\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceModels/#FinanceModels.cashflows_timepoints-Tuple{Any}","page":"FinanceModels","title":"FinanceModels.cashflows_timepoints","text":"cashflows_timepoints(contracts)\ncashflows_timepoints(quotes)\n\nCreate a matrix of cashflows and a vector of timepoints for a collection of quotes or contracts. Timepoints need not be spaced evenly.\n\nThis is used when constructing SmithWilson yield curves.\n\nArguments\n\ncontracts or quotes: A collection of <:AbstractContracts or Quotes.\n\nReturns\n\nA tuple (m, times) where m is a matrix of cashflows and times is a vector of timepoints.\n\nExamples\n\njulia> FinanceModels.cashflows_timepoints(ParYield.([0.04,0.02,0.04],[1,4,4]))\n([0.02 0.01 0.02; 1.02 0.01 0.02; … ; 0.0 0.01 0.02; 0.0 1.01 1.02], [0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0])\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceModels/#FinanceModels.eurocall-Tuple{}","page":"FinanceModels","title":"FinanceModels.eurocall","text":"eurocall(;S=1.,K=1.,τ=1,r,σ,q=0.)\n\nCalculate the Black-Scholes implied option price for a european call, where:\n\nS is the current asset price\nK is the strike or exercise price\nτ is the time remaining to maturity (can be typed with \\tau[tab])\nr is the continuously compounded risk free rate\nσ is the (implied) volatility (can be typed with \\sigma[tab])\nq is the continuously paid dividend rate\n\nRates should be input as rates (not percentages), e.g.: 0.05 instead of 5 for a rate of five percent.\n\n!!! Experimental: this function is well-tested, but the derivatives functionality (API) may change in a future version of ActuaryUtilities.\n\nExtended Help\n\nThis is the same as the formulation presented in the dividend extension of the BS model in Wikipedia.\n\nOther general comments:\n\nSwap/OIS curves are generally better sources for r than government debt (e.g. US Treasury) due to the collateralized nature of swap instruments.\n(Implied) volatility is characterized by a curve that is a function of the strike price (among other things), so take care when using \nYields.jl can assist with converting rates to continuously compounded if you need to perform conversions.\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceModels/#FinanceModels.europut-Tuple{}","page":"FinanceModels","title":"FinanceModels.europut","text":"europut(;S=1.,K=1.,τ=1,r,σ,q=0.)\n\nCalculate the Black-Scholes implied option price for a european call, where:\n\nS is the current asset price\nK is the strike or exercise price\nτ is the time remaining to maturity (can be typed with \\tau[tab])\nr is the continuously compounded risk free rate\nσ is the (implied) volatility (can be typed with \\sigma[tab])\nq is the continuously paid dividend rate\n\nRates should be input as rates (not percentages), e.g.: 0.05 instead of 5 for a rate of five percent.\n\n!!! Experimental: this function is well-tested, but the derivatives functionality (API) may change in a future version of ActuaryUtilities.\n\nExtended Help\n\nThis is the same as the formulation presented in the dividend extension of the BS model in Wikipedia.\n\nOther general comments:\n\nSwap/OIS curves are generally better sources for r than government debt (e.g. US Treasury) due to the collateralized nature of swap instruments.\n(Implied) volatility is characterized by a curve that is a function of the strike price (among other things), so take care when using \nYields.jl can assist with converting rates to continuously compounded if you need to perform conversions.\n\n\n\n\n\n","category":"method"},{"location":"migration/#Migration-Guide","page":"Migration Guide","title":"Migration Guide","text":"","category":"section"},{"location":"migration/#v3-to-v4","page":"Migration Guide","title":"v3 to v4","text":"","category":"section"},{"location":"migration/#Yields.jl-is-now-FinanceModels.jl","page":"Migration Guide","title":"Yields.jl is now FinanceModels.jl","text":"This re-write accomplishes three primary things:\n\nProvide a composable set of contracts and Quotes\nThose contracts, when combined with a model produce a Cashflow via a flexibly defined Projection\nmodels can be fit with a new unified API: fit(model_type,quotes,fit_method)","category":"section"},{"location":"migration/#Migrating-Code","page":"Migration Guide","title":"Migrating Code","text":"","category":"section"},{"location":"migration/#Update-Dependencies","page":"Migration Guide","title":"Update Dependencies","text":"You should remove Yields from your project's dependencies and add FinanceModels instead. (link to Pkg documentation on how to do this)","category":"section"},{"location":"migration/#API-Changes","page":"Migration Guide","title":"API Changes","text":"Previously, the API pattern was, e.g.:\n\nmodel = Yields.Par(SmitWilson(...), rates,timepoints)\n\nNow, follow the pattern of:\n\nDefine the quotes you want to fit the model to\nfit the model to those quotes\n\nExample:\n\nquotes = ParYield.(rates,timepoints)\nmodel = fit(SmithWilson(),quotes)","category":"section"},{"location":"migration/#Details-of-changes","page":"Migration Guide","title":"Details of changes","text":"Previously the kind of contract, the implied quotes, the type of model, and how the fitting process worked were all combined into a single call (Yields.Par). This minimized the amount of code needed to construct a yield curve, but left it fairly cumbersome to extend the package. For example, for every new yield curve model, methods for Par, CMT, OIS, Zero, ... had to be defined. Additionally, all of the inputs needed to be yields - specifying a price was not available as an argument to fit.\n\nWith the new design of the package, creating a completely new model is much easier, as only the model itself and the valuation primitives need to be defined. For example, defining a new yield curve type that works to value contracts instrument quotes only requires defining the discount method. To allow the model to be fit requires only defining a default set of parameters to optimize with __default_optic:\n\n using FinanceModels, FinanceCore\n using AccessibleModels \n using IntervalSets\n \nstruct ABDiscountLine{A} <: FinanceModels.Yield.AbstractYieldModel\n    a::A\n    b::A\nend\n\n# define the default constructor for convenience\nABDiscountLine() = ABDiscountLine(0.,0.)\n\nfunction FinanceCore.discount(m::ABDiscountLine,t)\n    #discount rate is approximated by a straight lined, floored at 0.0 and capped at 1.0\n    clamp(m.a*t + m.b, 0.0,1.0) \nend\n\n\n# `@optic` indicates what in our model variables needs to be updated (from AccessibleModels.jl)\n# `-1.0 .. 1.0` says to bound the search from negative to positive one (from IntervalSets.jl)\nFinanceModels.__default_optic(m::ABDiscountLine) = (\n    @optic(_.a) => -1.0 .. 1.0,\n    @optic(_.b) => -1.0 .. 1.0,\n)\n\nquotes = ZCBPrice([0.9, 0.8, 0.7,0.6])\n\nm = fit(ABDiscountLine(),quotes)","category":"section"},{"location":"faq/#Frequently-Asked-Questions","page":"FAQs","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"faq/#How-can-I-handle-Dates-instead-of-real-timepoints?","page":"FAQs","title":"How can I handle Dates instead of real timepoints?","text":"Currently, you must convert the Date into a real-valued timepoint for use within the models and contracts. Future releases may contemplate more explicit, built-in handling of dates. In the meantime, you may find these packages helpful if you need precise date-level accuracy:\n\nMiletus.jl\nInterestRates.jl\nBusinessDays.jl\nDayCounts.jl\nQuantLib.jl","category":"section"},{"location":"faq/#Why-does-the-package-rely-on-using-Transducers?","page":"FAQs","title":"Why does the package rely on using Transducers?","text":"Transducers are a way of defining logic to be applied to a reducible collection. They can compose together efficiently and the compiler can optimize them well. In rewriting the package from v3 to v4, Transducers vastly simplified the iteration and state handling needed when projecting the contracts. The performance remains excellent and made a lot of the internals much simpler.\n\nTransducers are a rich and powerful way to express programs and can seem somewhat unfamiliar at first encounter. For users of FinanceModels, very of transducers are needed/exposed:\n\nTo regular end-users who just use what is given to them here, the transducers internals are effectively completely hidden\nTo moderately advanced users who want to extend the functionality, as the examples show the only real exposure here is a weird function name ( __foldl__) with for loop with a return signature that has some extra information.\n\nA number of examples of extending the package are given on the FinanceModels.jl Guide page and the of course the source code itself offers examples of existing Projections and Contracts.","category":"section"},{"location":"faq/#Composite-Yield/Discount-Curves","page":"FAQs","title":"Composite Yield/Discount Curves","text":"Curves can be added or subtracted together, but note that this is not always the same thing as adding or subtracting spreads with rates. If spreads and base rates are expressed as zero rates, then the curve addition/subtraction has the same effect as re-fitting the yield model with the rate+spread inputs added together first. Non-zero rates (e.g. par rates) do not have this same property. Zero-coupon rates have a direct, linear relationship with the underlying discount factors. Par-coupon rates have a complex, non-linear relationship with the underlying discount factors and so the curve addition/subtraction does not work the same way.\n\nExample:\n\nusing FinanceModels\nusing Test\n\n\nrates = [0.01, 0.01, 0.03, 0.05, 0.07, 0.16, 0.35, 0.92, 1.40, 1.74, 2.31, 2.41] ./ 100\nspreads = [0.01, 0.01, 0.03, 0.05, 0.07, 0.16, 0.35, 0.92, 1.40, 1.74, 2.31, 2.41] ./ 100\nmats = [1 / 12, 2 / 12, 3 / 12, 6 / 12, 1, 2, 3, 5, 7, 10, 20, 30]\n\n\n### Zero coupon rates/spreads\n\nq_rf_z = ZCBYield.(rates,mats)\nq_s_z = ZCBYield.(spreads,mats)\nq_y_z = ZCBYield.(rates + spreads,mats)\n\nc_rf_z = fit(Spline.Linear(),q_rf_z,Fit.Bootstrap())\nc_s_z = fit(Spline.Linear(),q_s_z,Fit.Bootstrap())\nc_y_z = fit(Spline.Linear(),q_y_z,Fit.Bootstrap())\n\n# adding curves when the spreads were zero spreads DOES works\ndiscount(c_rf_z+c_s_z,20) ≈ discount(c_y_z,20) #true\n\n\n### Par coupon rates/spreads\n\nq_rf = CMTYield.(rates,mats)\nq_s = CMTYield.(spreads,mats)\nq_y = CMTYield.(rates + spreads,mats)\n\nc_rf = fit(Spline.Linear(),q_rf,Fit.Bootstrap())\nc_s = fit(Spline.Linear(),q_s,Fit.Bootstrap())\nc_y = fit(Spline.Linear(),q_y,Fit.Bootstrap())\n\n# adding curves when the spreads were par spreads does NOT work\ndiscount(c_rf+c_s,20) ≈ discount(c_y,20) # false\n\n\n","category":"section"},{"location":"faq/#I-have-another-question","page":"FAQs","title":"I have another question","text":"Ask on the discussion forum here: https://github.com/JuliaActuary/FinanceModels.jl/discussions","category":"section"},{"location":"API/Spline/#FinanceModels.Spline-API-Reference","page":"Spline","title":"FinanceModels.Spline API Reference","text":"Modules = [FinanceModels.Spline]","category":"section"},{"location":"API/Spline/#Exported-API","page":"Spline","title":"Exported API","text":"","category":"section"},{"location":"API/Spline/#Unexported-API","page":"Spline","title":"Unexported API","text":"Please open an issue if you encounter any issues or confusion with the package.","category":"section"},{"location":"API/Spline/#FinanceModels.Spline","page":"Spline","title":"FinanceModels.Spline","text":"Spline is a module which offers various degree splines used for fitting or bootstraping curves via the fit function.\n\nAvailable methods:\n\nSpline.BSpline(n) where n is the nth order. A nth-order B-Spline is analogous to an (n-1)th order polynomial spline. That is, a 3rd/4th order BSpline is very similar to a quadratic/cubic spline respectively. BSplines are global in that a change in one point affects the entire spline (though the spline still passes through the other given points still).\nSpline.PolynomialSpline(n) where n is the nth order.\n\nThis object is not a fitted spline itself, rather it is a placeholder object which will be a spline representing the data only after using within fit.\n\nConvenience methods which create a Spline.BSpline object of the appropriate order:\n\nSpline.Linear() equals BSpline(2)\nSpline.Quadratic() equals BSpline(3)\nSpline.Cubic() equals BSpline(4)\n\nNotes on Fitting:\n\nfit(spline,quotes) will fit entire curve at once, with knots equal to the maturity points of the Quotes\nfit(spline, quotes, Fit.Bootstrap()) will curve one knot at a time, with knots equal to the maturity points of the Quotes\n\nGenerally, the former will be preferred for performance reasons.\n\nExamples\n\nusing FinanceModels\nusing BenchmarkTools\nrates = [0.07, 0.16, 0.35, 0.92, 1.4, 1.74, 2.31, 2.41] ./ 100\nmats = [1, 2, 3, 5, 7, 10, 20, 30]\n\nqs = CMTYield.(rates, mats)\nc = fit(Spline.Linear(), qs) # will fit entire curve at once, with knots equal to the maturity points of the `Quote`s\nc = fit(Spline.Linear(), qs, Fit.Bootstrap()) # will curve one knot at a time, with knots equal to the maturity points of the `Quote`s\n\n\n\n\n\n\n","category":"module"},{"location":"API/Spline/#FinanceModels.Spline.Cubic-Tuple{}","page":"Spline","title":"FinanceModels.Spline.Cubic","text":"Spline.Cubic()\n\nCreate a cubic B-spline. This object is not a fitted spline itself, rather it is a placeholder object which will be a spline representing the data only after using within fit.\n\nReturns\n\nA BSpline object representing a cubic B-spline.\n\nExamples\n\njulia> Spline.Cubic()\nBSpline(4)\n\n\n\n\n\n","category":"method"},{"location":"API/Spline/#FinanceModels.Spline.Linear-Tuple{}","page":"Spline","title":"FinanceModels.Spline.Linear","text":"Spline.Linear()\n\nCreate a linear B-spline. This object is not a fitted spline itself, rather it is a placeholder object which will be a spline representing the data only after using within fit.\n\nReturns\n\nA BSpline object representing a linear B-spline.\n\nExamples\n\njulia> Spline.Linear()\nBSpline(2)\n\n\n\n\n\n","category":"method"},{"location":"API/Spline/#FinanceModels.Spline.Quadratic-Tuple{}","page":"Spline","title":"FinanceModels.Spline.Quadratic","text":"Spline.Quadratic()\n\nCreate a quadratic B-spline. This object is not a fitted spline itself, rather it is a placeholder object which will be a spline representing the data only after using within fit.\n\nReturns\n\nA BSpline object representing a quadratic B-spline.\n\nExamples\n\njulia> Spline.Quadratic()\nBSpline(3)\n\n\n\n\n\n","category":"method"},{"location":"API/Volatility/#FinanceModels.Volatility-API-Reference","page":"Volatility","title":"FinanceModels.Volatility API Reference","text":"Modules = [FinanceModels.Volatility]","category":"section"},{"location":"API/Volatility/#Exported-API","page":"Volatility","title":"Exported API","text":"","category":"section"},{"location":"API/Volatility/#Unexported-API","page":"Volatility","title":"Unexported API","text":"Please open an issue if you encounter any issues or confusion with the package.","category":"section"},{"location":"API/Volatility/#FinanceModels.Volatility.Constant","page":"Volatility","title":"FinanceModels.Volatility.Constant","text":"Volatility.Constant(σ)\n\nA constant volatility per period. If σ is not explicitly passed, then it is set to zero.\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceCore/#FinanceCore-API-Reference","page":"FinanceCore","title":"FinanceCore API Reference","text":"Modules = [FinanceCore]","category":"section"},{"location":"API/FinanceCore/#Exported-API","page":"FinanceCore","title":"Exported API","text":"","category":"section"},{"location":"API/FinanceCore/#Unexported-API","page":"FinanceCore","title":"Unexported API","text":"Please open an issue if you encounter any issues or confusion with the package.","category":"section"},{"location":"API/FinanceCore/#FinanceCore.Cashflow","page":"FinanceCore","title":"FinanceCore.Cashflow","text":"Cashflow(amount,time)\n\nA Cahflow{A,B} is a contract that pays an amount at time. \n\nCashflows can be:\n\nnegated with the unary - operator. \nadded/subtracted together but note that the time must be isapprox equal.\nmultiplied/divided by a scalar.\n\nSupertype Hierarchy ≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡\n\nCashflow{A<:Real, B<:Timepoint} <: FinanceCore.AbstractContract <: Any\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceCore/#FinanceCore.Composite","page":"FinanceCore","title":"FinanceCore.Composite","text":"Composite(A,B)\n\nSummary ≡≡≡≡≡≡≡≡≡\n\nstruct Composite{A, B}\n\nA Composite{A,B} is a contract that is composed of two other contracts of type A and type B.  The maturity of the composite is the maximum of the maturities of the two components. \n\nIt is used to assemble arbitrarily complex contracts from simpler ones.\n\nFields ≡≡≡≡≡≡≡≡\n\na :: A\nb :: B\n\nSupertype Hierarchy ≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡\n\nComposite{A, B} <: FinanceCore.AbstractContract <: Any\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceCore/#FinanceCore.Continuous","page":"FinanceCore","title":"FinanceCore.Continuous","text":"Continuous()\n\nA type representing continuous interest compounding frequency.\n\nExamples\n\njulia> Rate(0.01,Continuous())\nRate(0.01, Continuous())\n\nSee also: Periodic\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceCore/#FinanceCore.Continuous-Tuple{Any}","page":"FinanceCore","title":"FinanceCore.Continuous","text":"julia> Continuous(0.01)\nRate(0.01, Continuous())\n\nSee also: Periodic\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.Periodic","page":"FinanceCore","title":"FinanceCore.Periodic","text":"Periodic(frequency)\n\nA type representing periodic interest compounding with the given frequency. \n\nfrequency will be converted to an Integer, and will round up to 8 decimal places (otherwise will throw an InexactError). \n\nExamples\n\nCreating a semi-annual bond equivalent yield:\n\njulia> Rate(0.01,Periodic(2))\nRate(0.01, Periodic(2))\n\nSee also: Continuous\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceCore/#FinanceCore.Periodic-Tuple{Any, Any}","page":"FinanceCore","title":"FinanceCore.Periodic","text":"Periodic(rate,frequency)\n\nA convenience constructor for Rate(rate,Periodic(frequency)).\n\nExamples\n\nCreating a semi-annual bond equivalent yield:\n\njulia> Periodic(0.01,2)\nRate(0.01, Periodic(2))\n\nSee also: Continuous\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.Quote","page":"FinanceCore","title":"FinanceCore.Quote","text":"Quote(price,instrument)\n\nThe price(<:Real) is the observed value , and the instrument is the instrument/contract that the price is for.\n\nThis can be used, e.g., to calibrate a valuation model to prices for the given instruments - see FinanceModels.jl for more details.\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceCore/#FinanceCore.Rate-Tuple{Any}","page":"FinanceCore","title":"FinanceCore.Rate","text":"Rate(rate[,frequency=1])\nRate(rate,frequency::Frequency)\n\nRate is a type that encapsulates an interest rate along with its compounding frequency.\n\nPeriodic rates can be constructed via Rate(rate,frequency) or Rate(rate,Periodic(frequency)). If not given a second argument, Rate(rate) is equivalent to Rate(rate,Periodic(1)).\n\nContinuous rates can be constructed via Rate(rate, Inf) or Rate(rate,Continuous()).\n\nExamples\n\njulia> Rate(0.01,Continuous())\nRate(0.01, Continuous())\n\njulia> Continuous(0.01)\nRate(0.01, Continuous())\n\njulia> Continuous()(0.01)\nRate(0.01, Continuous())\n\njulia> Rate(0.01,Periodic(2))\nRate(0.01, Periodic(2))\n\njulia> Periodic(0.01,2)\nRate(0.01, Periodic(2))\n\njulia> Periodic(2)(0.01)\nRate(0.01, Periodic(2))\n\njulia> Rate(0.01)\nRate(0.01, Periodic(1))\n\njulia> Rate(0.01,2)\nRate(0.01, Periodic(2))\n\njulia> Rate(0.01,Periodic(4))\nRate(0.01, Periodic(4))\n\njulia> Rate(0.01,Inf)\nRate(0.01, Continuous())\n\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.accumulation-Tuple{Any, Any}","page":"FinanceCore","title":"FinanceCore.accumulation","text":"accumulation(rate, t)\naccumulation(rate, from, to)\n\nAccumulate rate for a time t or for an interval (from, to). If rate is not a Rate, it will be assumed to be a Periodic rate compounded once per period, i.e. Periodic(rate,1). \n\n# Examples\n\njulia> accumulation(0.03, 10)\n1.3439163793441222\n\njulia> accumulation(Periodic(0.03, 2), 10)\n1.3468550065500535\n\njulia> accumulation(Continuous(0.03), 10)\n1.3498588075760032\n\njulia> accumulation(0.03, 5, 10)\n1.1592740743\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.amount-Tuple{C} where C<:Cashflow","page":"FinanceCore","title":"FinanceCore.amount","text":"amount(x)\n\nIf is an object with an amount component (e.g. a Cashflow), will retrun that amount component, otherwise just x.\n\nExamples\n\njulia> FinanceCore.amount(Cashflow(1.,3.))\n1.0\n\njulia> FinanceCore.amount(1.)\n1.0\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.compounding-Tuple{Rate}","page":"FinanceCore","title":"FinanceCore.compounding","text":"compounding(r::Rate)\n\nReturns the compounding frequency of the Rate.\n\nExamples\n\njulia> r = Continuous(0.03)\nRate(0.03, Continuous())\n\njulia> compounding(r)\nContinuous()\n\njulia> r = Periodic(0.05, 2)\nRate(0.05, Periodic(2))\n\njulia> compounding(r)\nPeriodic(2)\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.discount-Tuple{Any, Any}","page":"FinanceCore","title":"FinanceCore.discount","text":"discount(rate, t)\ndiscount(rate, from, to)\n\nDiscount rate for a time t or for an interval (from, to). If rate is not a Rate, it will be assumed to be a Periodic rate compounded once per period, i.e. Periodic(rate,1). \n\nExamples\n\njulia> discount(0.03, 10)\n0.7440939148967249\n\njulia> discount(Periodic(0.03, 2), 10)\n0.7424704182237725\n\njulia> discount(Continuous(0.03), 10)\n0.7408182206817179\n\njulia> discount(0.03, 5, 10)\n0.8626087843841639\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.internal_rate_of_return-Tuple{AbstractVector{<:Real}}","page":"FinanceCore","title":"FinanceCore.internal_rate_of_return","text":"internal_rate_of_return(cashflows::vector)::Rate\ninternal_rate_of_return(cashflows::Vector, timepoints::Vector)::Rate\n\nCalculate the internalrateof_return with given timepoints. If no timepoints given, will assume that a series of equally spaced cashflows, assuming the first cashflow occurring at time zero and subsequent elements at time 1, 2, 3, ..., n. \n\nReturns a Rate type with periodic compounding once per period (e.g. annual effective if the timepoints given represent years). Get the scalar rate by calling Yields.rate() on the result.\n\nExample\n\njulia> internal_rate_of_return([-100,110],[0,1]) # e.g. cashflows at time 0 and 1\n0.10000000001652906\njulia> internal_rate_of_return([-100,110]) # implied the same as above\n0.10000000001652906\n\nSolver notes\n\nWill try to return a root within the range [-2,2]. If the fast solver does not find one matching this condition, then a more robust search will be performed over the [.99,2] range.\n\nThe solution returned will be in the range [-2,2], but may not be the one nearest zero. For a slightly slower, but more robust version, call ActuaryUtilities.irr_robust(cashflows,timepoints) directly.\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.irr","page":"FinanceCore","title":"FinanceCore.irr","text":"irr(cashflows::vector)\nirr(cashflows::Vector, timepoints::Vector)\n\nAn alias for `internal_rate_of_return`.\n\n\n\n\n\n","category":"function"},{"location":"API/FinanceCore/#FinanceCore.present_value-Tuple{Any, Any, Any}","page":"FinanceCore","title":"FinanceCore.present_value","text":"present_value(yield_model, cashflows[, timepoints=pairs(cashflows)])\n\nDiscount the cashflows vector at the given yield_model,  with the cashflows occurring at the times specified in timepoints. If no timepoints given, assumes that cashflows happen at the indices of the cashflows.\n\nIf your timepoints are dates, you can convert them into a floating point representation of the time interval using DayCounts.jl.\n\nExamples\n\njulia> present_value(0.1, [10,20],[0,1])\n28.18181818181818\njulia> present_value(Continuous(0.1), [10,20],[0,1])\n28.096748360719193\njulia> present_value(Continuous(0.1), [10,20],[1,2])\n25.422989241919232\njulia> present_value(Continuous(0.1), [10,20])\n25.422989241919232\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.rate-Tuple{Rate{<:Any, Continuous}}","page":"FinanceCore","title":"FinanceCore.rate","text":"rate(r::Rate)\n\nReturns the untyped scalar interest rate represented by the Rate.\n\nExamples\n\njulia> r =Continuous(0.03)\nYields.Rate{Float64, Continuous}(0.03, Continuous())\n\njulia> rate(r)\n0.03\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.timepoint-Union{Tuple{C}, Tuple{C, Any}} where C<:Cashflow","page":"FinanceCore","title":"FinanceCore.timepoint","text":"timepoint(x,t)\n\nIf x is an object with a defined time component (e.g. a Cashflow), will return that time component, otherwise will return t. This is useful in handling situations where you want to handle either Cashflows or separate amount and time vectors.\n\nExample\n\njulia> FinanceCore.timepoint(Cashflow(1.,3.),\"ignored\")\n3.0\n\njulia> FinanceCore.timepoint(1.,4.)\n4.0\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.Timepoint","page":"FinanceCore","title":"FinanceCore.Timepoint","text":"Timepoint(a)\n\nSummary ≡≡≡≡≡≡≡≡≡\n\nTimepoint is a type alias for Union{T,Dates.Date} that can be used to represent a point in time. It can be either a Dates.Date or a Real number. If defined as a real number, the interpretation is the number of (fractional) periods since time zero.\n\nCurrently, the usage of Dates.Date is not well supported across the JuliaActuary ecosystem but this type is in place such that it can be built upon further.\n\nSupertype Hierarchy ≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡\n\nTimepoint{T} = Union{T,Dates.Date} <: Any\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceCore/#Base.:*-Union{Tuple{T}, Tuple{N}, Tuple{Rate{N, T}, Real}} where {N, T<:Continuous}","page":"FinanceCore","title":"Base.:*","text":"*(Yields.Rate, T)\n*(T, Yields.Rate)\n\nThe multiplication of a Rate with a scalar will inherit the type of the Rate, or the first argument's type if both are Rates.\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#Base.:+-Union{Tuple{T}, Tuple{N}, Tuple{Rate{N, T}, Real}} where {N, T<:Continuous}","page":"FinanceCore","title":"Base.:+","text":"+(Yields.Rate, T<:Real)\n+(T<:Real, Yields.Rate)\n+(Yields.Rate,Yields.Rate)\n\nThe addition of a rate with a number will inherit the type of the Rate, or the first argument's type if both are Rates.\n\nExamples\n\njulia> Yields.Periodic(0.01,2) + Yields.Periodic(0.04,2)\nYields.Rate{Float64, Yields.Periodic}(0.05000000000000004, Yields.Periodic(2))\n\njulia> Yields.Periodic(0.04,2) + 0.01\nYields.Rate{Float64, Yields.Periodic}(0.05, Yields.Periodic(2))\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#Base.:--Union{Tuple{T}, Tuple{N}, Tuple{Rate{N, T}, Real}} where {N, T<:Continuous}","page":"FinanceCore","title":"Base.:-","text":"-(Yields.Rate, T<:Real)\n-(T<:Real, Yields.Rate)\n-(Yields.Rate, Yields.Rate)\n\nThe addition of a rate with a number will inherit the type of the Rate, or the first argument's type if both are Rates.\n\nExamples\n\njulia> Yields.Periodic(0.04,2) - Yields.Periodic(0.01,2)\nYields.Rate{Float64, Yields.Periodic}(0.030000000000000214, Yields.Periodic(2))\n\njulia> Yields.Periodic(0.04,2) - 0.01\nYields.Rate{Float64, Yields.Periodic}(0.03, Yields.Periodic(2))\n\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#Base.:/-Union{Tuple{T}, Tuple{N}, Tuple{Rate{N, T}, Real}} where {N, T<:Continuous}","page":"FinanceCore","title":"Base.:/","text":"/(x::Yields.Rate, y::Real)\n\nThe division of a Rate with a scalar will inherit the type of the Rate, or the first argument's type if both are Rates.\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#Base.convert-Union{Tuple{T}, Tuple{T, Rate}} where T<:FinanceCore.Frequency","page":"FinanceCore","title":"Base.convert","text":"convert(cf::Frequency,r::Rate)\n\nReturns a Rate with an equivalent discount but represented with a different compounding frequency.\n\nExamples\n\njulia> r = Rate(Periodic(12),0.01)\nRate(0.01, Periodic(12))\n\njulia> convert(Periodic(1),r)\nRate(0.010045960887181016, Periodic(1))\n\njulia> convert(Continuous(),r)\nRate(0.009995835646701251, Continuous())\n\n\n\n\n\n","category":"method"},{"location":"API/Equity/#FinanceModels.Equity-API-Reference","page":"Equity","title":"FinanceModels.Equity API Reference","text":"Modules = [FinanceModels.Equity]","category":"section"},{"location":"API/Equity/#Exported-API","page":"Equity","title":"Exported API","text":"","category":"section"},{"location":"API/Equity/#Unexported-API","page":"Equity","title":"Unexported API","text":"Please open an issue if you encounter any issues or confusion with the package.","category":"section"},{"location":"API/Equity/#FinanceModels.Equity","page":"Equity","title":"FinanceModels.Equity","text":"The Equity module provides equity-related model definitions.\n\nSee also: the Volatility module.\n\n\n\n\n\n","category":"module"},{"location":"API/Equity/#FinanceModels.Equity.BlackScholesMerton","page":"Equity","title":"FinanceModels.Equity.BlackScholesMerton","text":"BlackScholesMerton(r, q, σ) <: AbstractEquityModel\n\nA struct representing the Black-Scholes-Merton model for equity prices.\n\nArguments\n\nr: The risk-free rate (continuously compounded scalar or a FinanceCore.Rate type).\nq: The dividend yield (continuously compounded scalar or a FinanceCore.Rate type).\nσ: The volatility model of the underlying asset (see Volatility module) \n\nFields\n\nr: The risk-free rate.\nq: The dividend yield.\nσ: The volatility model of the underlying asset (see Volatility module)\n\nWhen fitting, the volatility will be solved-for; volatility itself is a sub-model that will be optimized with a default optimization bound of 0.0 .. 10.0\n\nExamples\n\njulia> model = BlackScholesMerton(0.05, 0.02, 0.2)\nBlackScholesMerton{Float64, Float64, Float64}(0.05, 0.02, 0.2)\n\nValuing an option:\n\nm = Equity.BlackScholesMerton(0.01, 0.02, 0.15)\n\na = Option.EuroCall(CommonEquity(), 1.0, 1.0)\n\n@test pv(m, a) ≈ 0.05410094201902403\n\nFitting a set of option prices:\n\nqs = [\n    Quote(0.0541, a),\n    Quote(0.072636, b),\n]\nm = Equity.BlackScholesMerton(0.01, 0.02, Volatility.Constant())\nfit(m, qs)\n@test fit(m, qs).σ ≈ 0.15 atol = 1e-4\n\n\n\n\n\n\n","category":"type"},{"location":"API/Equity/#FinanceModels.Equity.volatility-Tuple{FinanceModels.Volatility.Constant, Any, Any}","page":"Equity","title":"FinanceModels.Equity.volatility","text":"volatility(volatility_model,strike_ratio,time_to_maturity)\n\nReturns the volatility associated with the money-ness (strike/price ratio) and time to maturity.\n\n\n\n\n\n","category":"method"},{"location":"Rates/#Rates","page":"Rates","title":"Rates","text":"We should first discuss Rates, which are reexported from FinanceCore.jl\n\nRates are types that wrap scalar values to provide information about how to determine discount and accumulation factors. These allow for explicit handling of rate compounding conventions which, if not explicit, is often a source of errors in practice.\n\nThere are two Frequency types:\n\nYields.Periodic(m) for rates that compound m times per period (e.g. m times per year if working with annual rates).\nYields.Continuous() for continuously compounding rates.","category":"section"},{"location":"Rates/#Examples","page":"Rates","title":"Examples","text":"Continuous(0.05)       # 5% continuously compounded\nPeriodic(0.05,2)       # 5% compounded twice per period\n\nThese are both subtypes of the parent Rate type and are instantiated as:\n\nRate(0.05,Continuous())       # 5% continuously compounded\nRate(0.05,Periodic(2))        # 5% compounded twice per period\n\nBroadcast over a vector to create Rates with the given compounding:\n\nPeriodic.([0.02,0.03,0.04],2) \nContinuous.([0.02,0.03,0.04]) \n\nRates can also be constructed by specifying the CompoundingFrequency and then passing a scalar rate:\n\nPeriodic(1)(0.05)\nContinuous()(0.05)","category":"section"},{"location":"Rates/#Conversion","page":"Rates","title":"Conversion","text":"Convert rates between different types with convert. E.g.:\n\nr = Rate(0.01,Periodic(12))             # rate that compounds 12 times per rate period (ie monthly)\n\nconvert(Yields.Periodic(1),r)                  # convert monthly rate to annual effective\nconvert(Yields.Continuous(),r)          # convert monthly rate to continuous\n\nTo get the scalar value out of the Rate, use FinanceModels.rate(r):\n\njulia> r = Rate(0.01,Periodic(12));   \njulia> rate(r)\n0.01\n","category":"section"},{"location":"Rates/#Arithmetic","page":"Rates","title":"Arithmetic","text":"Adding, subtracting, multiplying, dividing, and comparing rates is supported.","category":"section"},{"location":"introduction/#FinanceModels.jl-Guide","page":"Introduction","title":"FinanceModels.jl Guide","text":"FinanceModels.jl provides a set of composable contracts, models, and functions that allow for modeling of both simple and complex financial instruments. The resulting models, such as discount rates or term structures, can then be used across the JuliaActuary ecosystem to perform actuarial and financial analysis.\n\n(Image: A conceptual sketch of FinanceModels.jl)","category":"section"},{"location":"introduction/#1.-Cashflow-a-fundamental-financial-type","page":"Introduction","title":"1. Cashflow - a fundamental financial type","text":"Say you wanted to model a contract that paid quarterly payments, and those payments occurred starting 15 days from the valuation date (first payment time = 15/365 = 0.057)\n\nPreviously, you had two options:\n\nChoose a discrete timestep to model (e.g. monthly, quarterly, annual) and then lump the cashflows into those timesteps. E.g. with monthly timesteps  of a unit payment of our contract, it might look like: [1,0,0,1,0,0...]\nKeep track of two vectors: one for the payment and one for the times. In this case, that might look like: cfs = [1,1,...];times = [0.057, 0.307...]\n\nThe former has inaccuracies due to the simplified timing and logical complication related to mapping the contracts natural periodicity into an arbitrary modeling choice. The latter becomes unwieldy and fails to take advantage of Julia's type system.\n\nThe new solution: Cashflows. Our example above would become: [Cashflow(1,0.057), Cashflow(1,0.307),...]","category":"section"},{"location":"introduction/#2.-**Contracts**-A-composable-way-to-represent-financial-instruments","page":"Introduction","title":"2. Contracts - A composable way to represent financial instruments","text":"Contracts are a composable way to represent financial instruments. They are, in essence, anything that is a collection of cashflows. Contracts can be combined to represent more complex instruments. For example, a bond can be represented as a collection of cashflows that correspond to the coupon payments and the principal repayment.\n\nExamples:\n\na Cashflow\nBonds:\nBond.Fixed, Bond.Floating\nOptions:\nOption.EuroCall and Option.EuroPut\nCompositional contracts:\nForwardto represent an instrument that is relative to a forward point in time.\nComposite to represent the combination of two other instruments.  \n\nIn the future, this notion may be extended to liabilities (e.g. insurance policies in LifeContingencies.jl)","category":"section"},{"location":"introduction/#Creating-a-new-Contract","page":"Introduction","title":"Creating a new Contract","text":"A contract is anything that creates a vector of Cashflows when collected. For example, let's create a bond which only pays down principle and offers no coupons.\n\nusing FinanceModels,FinanceCore\n\n# Transducers is used to provide a more powerful, composable way to construct collections than the basic iteration interface\nusing Transducers: __foldl__, @next, complete\n\n\"\"\"\nA bond which pays down its par (one unit) in equal payments. \n\"\"\"\nstruct PrincipalOnlyBond{F<:FinanceCore.Frequency} <: FinanceModels.Bond.AbstractBond\n    frequency::F\n    maturity::Float64\nend\n\n# We extend the interface to say what should happen as the bond is projected\n# There's two parts to customize:\n# 1. any initialization or state to keep track of\n# 2. The loop where we decide what gets returned at each timestep\nfunction Transducers.__foldl__(rf, val, p::Projection{C,M,K}) where {C<:PrincipalOnlyBond,M,K}\n    # initialization stuff\n    b = p.contract # the contract within a projection\n    ts = Bond.coupon_times(b) # works since it's a FinanceModels.Bond.AbstractBond with a frequency and maturity\n    pmt = 1 / length(ts)\n\n    for t in ts\n        # the loop which returns a value\n        cf = Cashflow(pmt, t)\n        val = @next(rf, val, cf) # the value to return is the last argument\n    end\n    return complete(rf, val)\nend\n\nThat's it! then we can use this contract to fitting models, create projections, quotes, etc. Here we simply collect the bond into an array of cashflows:\n\njulia> PrincipalOnlyBond(Periodic(2),5.) |> collect\n10-element Vector{Cashflow{Float64, Float64}}:\n Cashflow{Float64, Float64}(0.1, 0.5)\n Cashflow{Float64, Float64}(0.1, 1.0)\n Cashflow{Float64, Float64}(0.1, 1.5)\n Cashflow{Float64, Float64}(0.1, 2.0)\n Cashflow{Float64, Float64}(0.1, 2.5)\n Cashflow{Float64, Float64}(0.1, 3.0)\n Cashflow{Float64, Float64}(0.1, 3.5)\n Cashflow{Float64, Float64}(0.1, 4.0)\n Cashflow{Float64, Float64}(0.1, 4.5)\n Cashflow{Float64, Float64}(0.1, 5.0)\n\nNote that all contracts in FinanceModels.jl are currently unit contracts in that they assume a unit par value. Scale assets down to unit values before constructing the default contracts.","category":"section"},{"location":"introduction/#More-complex-Contracts","page":"Introduction","title":"More complex Contracts","text":"When the cashflow depends on a model. An example of this is a floating bond where the coupon paid depends on a view of forward rates. See Section 6 - Projections for how this is handled.","category":"section"},{"location":"introduction/#3.-Quotes-The-observed-price-we-need-to-fit-a-model-to","page":"Introduction","title":"3. Quotes - The observed price we need to fit a model to","text":"Quotes are the observed prices that we need to fit a model to. They represent the market prices of financial instruments, such as bonds or swaps. In the context of the package, a quote is defined as a pair of a contract and a price.\n\nFor example, a par yield bond paying a 4% coupon (paid as 2% twice per annum) implies a price at par (i.e. 1.0):\n\njulia> ParYield(Periodic(0.04,2),10)\nQuote{Float64, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}}(\n1.0, \nFinanceModels.Bond.Fixed{Periodic, Float64, Int64}(0.040000000000000036, Periodic(2), 10))\n\n\nA number of convenience functions are included to construct a Quote:\n\nZCBPrice and ZCBYield\nParYield\nCMTYield\nOISYield\nForwardYields","category":"section"},{"location":"introduction/#4.-**Models**-Not-just-yield-curves-anymore","page":"Introduction","title":"4. Models - Not just yield curves anymore","text":"Yield Curves: all of Yields.jl yield models are included in the initial FinanceModels.jl release\nEquities and Options: The initial release includes BlackScholesMerton option pricing and one can use constant or spline volatility models\nOthers more to come in the future","category":"section"},{"location":"introduction/#Creating-a-new-model","page":"Introduction","title":"Creating a new model","text":"Here we'll do a complete implementation of a yield curve model where the discount rate is approximated by a straight line (often called an AB line from the y=ax+b formula.\n\n using FinanceModels, FinanceCore\n using AccessibleModels \n using IntervalSets\n \nstruct ABDiscountLine{A} <: FinanceModels.Yield.AbstractYieldModel\n    a::A\n    b::A\nend\n\nABDiscountLine() = ABDiscountLine(0.,0.)\n\nfunction FinanceCore.discount(m::ABDiscountLine,t)\n    #discount rate is approximated by a straight line, floored at 0.0 and capped at 1.0\n    clamp(m.a*t + m.b, 0.0,1.0) \nend\n\n\n# `@optic` indicates what in our model variables needs to be updated (from AccessibleModels.jl)\n# `-1.0 .. 1.0` says to bound the search from negative to positive one (from IntervalSets.jl)\nFinanceModels.__default_optic(m::ABDiscountLine) = (\n    @optic(_.a) => -1.0 .. 1.0,\n    @optic(_.b) => -1.0 .. 1.0,\n)\n\nquotes = ZCBPrice([0.9, 0.8, 0.7,0.6])\n\nm = fit(ABDiscountLine(),quotes)\n\nNow, m is a model like any of the other yield curve models provided and can be used in that context. For example, calculating the price of the bonds contained within our quotes where we indeed recover the prices for our contrived example:\n\njulia> map(q -> pv(m,q.instrument),quotes) \n4-element Vector{Float64}:\n 0.9\n 0.8\n 0.7\n 0.6","category":"section"},{"location":"introduction/#5.-fit-The-standardized-API-for-all-models,-quotes,-and-methods","page":"Introduction","title":"5. fit - The standardized API for all models, quotes, and methods","text":"       Model                                                               Method\n          |                                                                   |\n    |------------|                                                     |---------------|\nfit(Spline.Cubic(), CMTYield.([0.04,0.05,0.055,0.06,0055],[1,2,3,4,5]), Fit.Bootstrap())\n                    |-------------------------------------------------|\n                                              |\n                                              Quotes\n\nModel could be Spline.Linear(), Yield.NelsonSiegelSvensson(), Equity.BlackScholesMerton(...), etc.\nQuote could be CMTYields, ParYields, Option.Eurocall, etc.\nMethod could be Fit.Loss(x->x^2), Fit.Loss(x->abs(x)), Fit.Bootstrap(), etc.\n\nThe benefit of this versus the old Yields.jl API is:\n\nWithout a generic fit method, no obvious way to expose different curve construction methods (e.g. choice of model and method)\nThe fit is extensible. Users or other packages could define their own Models, Quotes, or Methods and integrate into the JuliaActuary ecosystem.\nThe fit formulation is very generic: the required methods are minimal to integrate in order to extend the functionality.","category":"section"},{"location":"introduction/#Customizing-model-fitting","page":"Introduction","title":"Customizing model fitting","text":"Model fitting can be customized:\n\nThe loss function (least squares, absolute difference, etc.) via the third argument to fit:\ne.g.fit(ABDiscountLine(), quotes, FIt.Loss(x -> abs(x))\nthe default is Fit.Loss(x->x^2)\nthe optimization algorithm by defining a method FinanceModels.__default_optim__(m::ABDiscountLine) = OptimizationOptimJL.Newton()\nyou may need to change the __default_optic to be unbounded (simply omit the => and subsequent bounds)\nThe default is OptimizationMetaheuristics.ECA()\nThe general algorithm can be customized by creating a new method for fit:\n\nfunction FinanceModels.fit(m::ABDiscountLine, quotes, ...)\n # custom code for fitting your model here\nend\n\nAs an example, the splines (Spline.Linear(), Spline.Cubic(),...) are defined to use bootstrap by default: fit(mod0::Spline.BSpline, quotes, method::Fit.Bootstrap)","category":"section"},{"location":"introduction/#Using-models-without-fitting","page":"Introduction","title":"Using models without fitting","text":"While many of the examples show models being fit to observed prices, you can skip that step in practice if you want to define an assumed valuation model that does not intend to calibrate market prices.","category":"section"},{"location":"introduction/#6.-Projections","page":"Introduction","title":"6. Projections","text":"A Projection is a generic way to work with various data that you can project forward. For example, getting the series of cashflows associated with a contract.\n\nWhat is a Projection?\n\nstruct Projection{C,M,K} <: AbstractProjection\n    contract::C    # the contract (or set of contracts) we want to project\n    model::M       # the model that defines how the contract will behave\n    kind::K           # what kind of projetion do we want? only cashflows? \nend\n\ncontract is obvious, so let's talk more about the second two:\n\nmodel is the same kind of thing we discussed above. Some contracts (e.g. a floating rate bond). We can still decompose a floating rate bond into a set of cashflows, but we need a model.\nThere are also projections which don't need a model (e.g. fixed bonds) and for that there's the generic NullModel()\nkind defines what we'll return from the projection.\nCashflowProjection() says we just want a Cashflow[...] vector\n... but if we wanted to extend this such that we got a vector containing cashflows, capital factors, default rates, etc we could define a new projection type (e.g. we might call the above AssetDetailProjection()\nCurrently, only CashflowProjection() is defined by FinanceModels.jl","category":"section"},{"location":"introduction/#Contracts-that-depend-on-the-model-(or-multiple-models)","page":"Introduction","title":"Contracts that depend on the model (or multiple models)","text":"For example, the cashflows you generate for a floating rate bond is the current reference rate. Or maybe you have a stochastic volatility model and want to project forward option values. This type of dependency is handled like this:\n\ndefine model as a relation that maps a key to a model. E.g. a Dict(\"SOFR\" => NelsonSiegelSvensson(...))\nwhen defining the logic for the reducible collection/foldl, you can reference the Projection.model by the associated key.\n\nHere's how a floating bond is implemented:\n\nThe contract struct. The key would be \"SOFR\" in our example above.\n\nstruct Floating{F<:FinanceCore.Frequency,N<:Real,M<:Timepoint,K} <: AbstractBond\n    coupon_rate::N # coupon_rate / frequency is the actual payment amount\n    frequency::F\n    maturity::M\n    key::K\nend\n\nAnd how we can reference the associated model when projecting that contract. This is very similar to the definition of __foldl__ for our PrincipalOnlyBond, except we are paying a coupon and referencing the scenario rate.\n\n@inline function Transducers.__foldl__(rf, val, p::Projection{C,M,K}) where {C<:Bond.Floating,M,K}\n    b = p.contract\n    ts = Bond.coupon_times(b)\n    for t in ts\n        freq = b.frequency # e.g. `Periodic(2)`\n        freq_scalar = freq.frequency  # the 2 from `Periodic(2)`\n\n        # get the rate from the current time to next payment \n        # out of the model and convert it to the contract's periodicity\n        model = p.model[b.key]\n        reference_rate = rate(freq(forward(model, t, t + 1 / freq_scalar)))\n        coup = (reference_rate + b.coupon_rate) / freq_scalar\n        amt = if t == last(ts)\n            1.0 + coup\n        else\n            coup\n        end\n        cf = Cashflow(amt, t)\n        val = @next(rf, val, cf)\n    end\n    return complete(rf, val)\nend\n\nIn this post we've now defined two assets that can work seamlessly with projecting cashflows, fitting models, and determining valuations :)","category":"section"},{"location":"introduction/#7.-ProjectionKinds","page":"Introduction","title":"7. ProjectionKinds","text":"While CashflowProjection is the most common (and the only one built into the initial release of FinanceModels), a Projection can be created which handles different kinds of outputs in the same manner as projecting just basic cashflows. For example, you may want to output an amortization schedule, or a financial statement, or an account value roll-forward. The Projection is able to handle these custom outputs by dispatching on the third element in a Projection.\n\nLet's extend the example of a principle-only bond from section 2 above. Our goal is to create a basic amortization schedule which shows the payment made and outstanding balance.\n\nFirst, we create a new subtype of ProjectionKind:\n\nstruct AmortizationSchedule <: FinanceModels.ProjectionKind\nend\n\nAnd then define the loop for the amortization schedule output:\n\n# note the dispatch on `AmortizationSchedule` in the next line\nfunction Transducers.__foldl__(rf, val, p::Projection{C,M,K}) where {C<:PrincipalOnlyBond,M,K<:AmortizationSchedule}\n    # initialization stuff\n    b = p.contract # the contract within a projection\n    ts = Bond.coupon_times(b) # works since it's a FinanceModels.Bond.AbstractBond with a frequency and maturity\n    pmt = 1 / length(ts)\n    balance = 1.0\n    for t in ts\n        # the loop wich returns a tuple of the relevant data\n        balance -= pmt\n        result = (time=t,payment=pmt,outstanding=balance)\n        val = @next(rf, val, result) # the value to return is the last argument\n    end\n    return complete(rf, val)\nend\n\nWe can now define the projection:\n\njulia> p = Projection(\n           PrincipalOnlyBond(Periodic(2),5.),  # our contract\n           NullModel(),                       # the projection doesn't need a model, so use the null model\n           AmortizationSchedule(),            # specify the amortization schedule output\n           );\n\n\nAnd then collect the values:\n\njulia> collect(p)\n10-element Vector{NamedTuple{(:time, :payment, :outstanding), Tuple{Float64, Float64, Float64}}}:\n (time = 0.5, payment = 0.1, outstanding = 0.9)\n (time = 1.0, payment = 0.1, outstanding = 0.8)\n (time = 1.5, payment = 0.1, outstanding = 0.7000000000000001)\n (time = 2.0, payment = 0.1, outstanding = 0.6000000000000001)\n (time = 2.5, payment = 0.1, outstanding = 0.5000000000000001)\n (time = 3.0, payment = 0.1, outstanding = 0.40000000000000013)\n (time = 3.5, payment = 0.1, outstanding = 0.30000000000000016)\n (time = 4.0, payment = 0.1, outstanding = 0.20000000000000015)\n (time = 4.5, payment = 0.1, outstanding = 0.10000000000000014)\n (time = 5.0, payment = 0.1, outstanding = 1.3877787807814457e-16)","category":"section"},{"location":"#FinanceModels.jl","page":"Home","title":"FinanceModels.jl","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage)\n\nFinanceModels.jl provides a set of composable contracts, models, and functions that allow for modeling of both simple and complex financial instruments. The resulting models, such as discount rates or term structures, can then be used across the JuliaActuary ecosystem to perform actuarial and financial analysis.\n\nAdditionally, the models can be used to project contracts through time: most basically as a series of cashflows but more complex output can be defined for contracts.\n\n(Image: anim_fps2)","category":"section"},{"location":"#QuickStart","page":"Home","title":"QuickStart","text":"using FinanceModels\n\n# a set of market-observed prices we wish to calibrate the model to\n# annual effective unless otherwise specified\nq_rate = ZCBYield([0.01,0.02,0.03]);\nq_spread = ZCBYield([0.01,0.01,0.01]);\n\n# bootstrap a linear spline yield model\nmodel_rate = fit(Spline.Linear(),q_rate,Fit.Bootstrap());⠀           \nmodel_spread = fit(Spline.Linear(),q_spread,Fit.Bootstrap());\n\n# the zero rate is the combination of the two underlying rates\nzero(m_spread + m_rate,1) # 0.02 annual effective rate \n\n# the discount is the same as if we added the underlying zero rates\ndiscount(m_spread + m_rate,0,3) ≈ discount(0.01 + 0.03,3)   # true\n\n# compute the present value of a contract (a cashflow of 10 at time 3)\npresent_value(m_rate,Cashflow(10,3)) # 9.15...","category":"section"},{"location":"#Overview-of-FinanceModels","page":"Home","title":"Overview of FinanceModels","text":"(Image: A conceptual sketch of FinanceModels.jl)\n\nOften we start with observed or assumed values for existing contracts. We want to then use those assumed values to extend the valuation logic to new contracts. For example, we may have a set of bond yields which we then want to discount a series of insurance obligations.\n\nIn the language of FinanceModels, we would have a set of Quotes which are used to fit a Model. That model is then used to discount a new series of cashflows.\n\nThat's just an example, and we can use the various components in different ways depending on the objective of the analysis.","category":"section"},{"location":"#Contracts-and-Quotes","page":"Home","title":"Contracts and Quotes","text":"Contracts are a way to represent financial obligations. These can be valued using a model, projected into a future steam of values, or combined with assumed prices as a Quote.\n\nIncluded are a number of primitives and convenience methods for contracts:\n\nExisting structs:\n\nCashflow\nBond.Fixed\nBond.Floating\nForward (an obligation with a forward start time)\nComposite (combine two other contracts, e.g. into a swap)\nEuroCall\nCommonEquity\n\nCommonly, we deal with conventions that imply a contract and an observed price. For example, we may talk about a treasury yield of 0.03. This is a description that implies a Quoteed price for an underling fixed bond. In FinanceModels, we could use CMTYield(rate,tenor) which would create a Quote(price,Bond.Fixed(...)). In this way, we can conveniently create a number of Quotes which can be used to fit models. Such convenience methods include:\n\nZCBYield\nZCBPrice\nCMTYield\nParYield\nParSwapYield\nForwardYield\n\nFinanceModels offers a way to define new contracts as well.","category":"section"},{"location":"#Cashflows","page":"Home","title":"Cashflows","text":"A Cashflows obligation are themselves a contract, but other contracts can be considered as essentially anything that can be combined with assumptions (a model) to derive a collection of cashflows.\n\nFor example, a obligation that pays 1.75 at time 2 could be represented as: Cashflow(1.75,2).","category":"section"},{"location":"#Models","page":"Home","title":"Models","text":"Models are objects that can be fit to observed prices and then subsequently used to make valuations of other cashflows/contracts.\n\nYield models include:\n\nYield.Constant\nBootstrapped Splines\nYield.SmithWilson\nYield.NelsonSiegel\nYield.NelsonSiegelSvensson","category":"section"},{"location":"#Yield-related-functions","page":"Home","title":"Yield-related functions","text":"The models can be used to compute various rates of interest:\n\ndiscount(curve,from,to) or discount(curve,to) gives the discount factor\naccumulation(curve,from,to) or accumulation(curve,to) gives the accumulation factor\nzero(curve,time) or zero(curve,time,Frequency) gives the zero-coupon spot rate for the given time.\nforward(curve,from,to) gives the zero rate between the two given times\npar(curve,time;frequency=2) gives the coupon-paying par equivalent rate for the given time.\n\nOther models include:\n\nBlackScholesMerton derivative valuation","category":"section"},{"location":"#Plotting-of-Yield-Curves","page":"Home","title":"Plotting of Yield Curves","text":"In interactive sessions (e.g. REPL, Notebooks, VS Code, etc.) you can get a pretty printing of yield curves by also using UnicodePlots.jl, for example:\n\njulia> using FinanceModels\njulia> q_rate = ZCBYield.([0.01, 0.02, 0.03,0.04,0.03],[1,3,5,10,20]);\njulia> fit(Spline.PolynomialSpline(3), q_rate, Fit.Bootstrap())\nFinanceModels.Yield.Spline{DataInterpolations.CubicSpline{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, true, Float64}}([0.009950330853168092, 0.009950330853168092, 0.019802627296179747, 0.02955880224154443, 0.0, 1.0, 2.0, 3.0])\n\njulia> using UnicodePlots \njulia> fit(Spline.PolynomialSpline(3), q_rate, Fit.Bootstrap()) # after importing UnicodePlots\n              ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Yield Curve (FinanceModels.Yield.Spline)⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀           \n              ┌────────────────────────────────────────────────────────────┐           \n         0.04 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⠤⠖⠒⠊⠉⠉⠉⠒⠒⠢⠤⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ Zero rates\n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⠔⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠑⠒⢄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠖⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠑⠢⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡔⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠒⢄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⢠⠎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠓⠤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⢠⠎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠑⠦⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⢠⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠓⠦⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀│           \n   Continuous │⠀⠀⠀⠀⠀⢠⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠒⠒⠦⠤⠤⠤⠤│           \n              │⠀⠀⠀⠀⢀⠎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⢀⡎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⢀⠎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠒⠒⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n            0 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              └────────────────────────────────────────────────────────────┘           \n              ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀time⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀30⠀           \n\n\n[!NOTE] This was built-in prior to v4.9 of FinanceModels. It has been split out to materially speed up using FinanceModels.","category":"section"},{"location":"#Projections","page":"Home","title":"Projections","text":"Most basically, we can project a contract into a series of Cashflows:\n\njulia> b = Bond.Fixed(0.04,Periodic(2),3)\nFinanceModels.Bond.Fixed{Periodic, Float64, Int64}(0.04, Periodic(2), 3)\n\njulia> collect(b)\n6-element Vector{Cashflow{Float64, Float64}}:\n Cashflow{Float64, Float64}(0.02, 0.5)\n Cashflow{Float64, Float64}(0.02, 1.0)\n Cashflow{Float64, Float64}(0.02, 1.5)\n Cashflow{Float64, Float64}(0.02, 2.0)\n Cashflow{Float64, Float64}(0.02, 2.5)\n Cashflow{Float64, Float64}(1.02, 3.0)\n\nHowever, Projections allow one to combine three elements which can be extended to define any desired output (such as amortization schedules, financial statement projections, or account value rollforwards). The three elements are:\n\nthe underlying contract of interest\nthe model which includes assumptions of how the contract will behave\na ProjectionKind which indicates the kind of output desired (cashflow stream, amortization schedule, etc...)","category":"section"},{"location":"#Examples","page":"Home","title":"Examples","text":"A fixed bond that needs no valuation model (NullModel()) to define its projected gross cashflows:\n\nProjection(Bond.Fixed(0.04,Periodic(2),3),NullModel(),CashflowProjection())","category":"section"},{"location":"#Plotting-Projections","page":"Home","title":"Plotting Projections","text":"A CashflowProjection or a vector of Cashflows can be plotted with the Makie family of plotting packages.\n\nusing FinanceModels, CairoMakie\nproj = Projection(Bond.Fixed(0.10,Periodic(2),20),NullModel(),CashflowProjection())\n# a stem plot:\nstem(proj)\n\nWill produce:\n\n(Image: A stem plot of bond cashflows)","category":"section"},{"location":"#Fitting-Models","page":"Home","title":"Fitting Models","text":"","category":"section"},{"location":"#Fitting-Models-2","page":"Home","title":"Fitting Models","text":"       Model                                                               Method\n          |                                                                   |\n   |------------|                                                     |---------------|\nfit(Spline.Cubic(), CMTYield.([0.04,0.05,0.055,0.06,0055],[1,2,3,4,5]), Fit.Bootstrap())\n                    |-------------------------------------------------|\n                                              |\n                                              Quotes\n\nModel could be Spline.Linear(), Yield.NelsonSiegelSvensson(), Equity.BlackScholesMerton(...), etc.\nQuote could be CMTYields, ParYields, Option.Eurocall, etc.\nMethod could be Fit.Loss(x->x^2), Fit.Loss(x->abs(x)), Fit.Bootstrap(), etc.\n\nThis unified way to fit models offers a much simpler way to extend functionality to new models or contract types.","category":"section"},{"location":"#Using-Models","page":"Home","title":"Using Models","text":"After being fit, models can be used to value contracts:\n\npresent_value(model,cashflows)\n\nAdditionally, ActuaryUtilities.jl offers a number of other methods that can be used, such as duration, convexity, price which can be used for analysis with the fitted models.","category":"section"},{"location":"#Rates","page":"Home","title":"Rates","text":"Rates are types that wrap scalar values to provide information about how to determine discount and accumulation factors.\n\nThere are two Frequency types:\n\nPeriodic(m) for rates that compound m times per period (e.g. m times per year if working with annual rates).\nContinuous() for continuously compounding rates.","category":"section"},{"location":"#Examples-2","page":"Home","title":"Examples","text":"Continuous(0.05)       # 5% continuously compounded\nPeriodic(0.05,2)       # 5% compounded twice per period\n\nThese are both subtypes of the parent Rate type and are instantiated as:\n\nRate(0.05,Continuous())       # 5% continuously compounded\nRate(0.05,Periodic(2))        # 5% compounded twice per period\n\nRates can also be constructed by specifying the Frequency and then passing a scalar rate:\n\nPeriodic(1)(0.05)\nContinuous()(0.05)","category":"section"},{"location":"#Conversion","page":"Home","title":"Conversion","text":"Convert rates between different types with convert. E.g.:\n\nr = Rate(FinanceModels.Periodic(12),0.01)             # rate that compounds 12 times per rate period (ie monthly)\n\nconvert(FinanceModels.Periodic(1),r)                  # convert monthly rate to annual effective\nconvert(FinanceModels.Continuous(),r)          # convert monthly rate to continuous","category":"section"},{"location":"#Arithmetic","page":"Home","title":"Arithmetic","text":"Adding, substracting, multiplying, dividing, and comparing rates is supported.","category":"section"},{"location":"#Guide-and-Documentation","page":"Home","title":"Guide and Documentation","text":"A guide which explains more about the components of the package and from-scratch examples of extending the package is available in the documenation","category":"section"},{"location":"#Exported-vs-Un-exported-Functions","page":"Home","title":"Exported vs Un-exported Functions","text":"Generally, CamelCase methods which construct a datatype are exported as they are unlikely to conflict with other parts of code that may be written. For example, rate is un-exported (it must be called with FinanceModels.rate(...)) because rate is likely a very commonly defined variable within actuarial and financial contexts and there is a high risk of conflicting with defined variables.\n\nConsider using import FinanceModels which would require qualifying all methods, but alleviates any namespace conflicts and has the benefit of being explicit about the calls (internally we prefer this in the package design to keep dependencies and their usage clear).","category":"section"},{"location":"#Internals","page":"Home","title":"Internals","text":"For time-variant FinanceModels (ie yield curves), the inputs are converted to spot rates and interpolated using quadratic B-splines by default (see documentation for alternatives, such as linear interpolations).","category":"section"},{"location":"#Combination-Implementation","page":"Home","title":"Combination Implementation","text":"Combinations track two different curve objects and are not combined into a single underlying data structure. This means that you may achieve better performance if you combine the rates before constructing a FinanceModels representation. The exception to this is Constant curves, which do get combined into a single structure that is as performant as pre-combined rate structure.","category":"section"},{"location":"#Related-Packages","page":"Home","title":"Related Packages","text":"InterestRates.jl specializes in fast rate calculations aimed at valuing fixed income contracts, with business-day-level accuracy.\nComparative comments: FinanceModels.jl does not try to provide as precise controls over the timing, structure, and interpolation of the curve. Instead, FinanceModels.jl provides a minimal, but flexible and intuitive interface for common modeling needs.","category":"section"},{"location":"extensions/#UnicodePlots.jl-for-Interactive-Session-Yield-Curve-Plotting","page":"Extensions","title":"UnicodePlots.jl for Interactive Session Yield Curve Plotting","text":"In interactive sessions (e.g. REPL, Notebooks, VS Code, etc.) you can get a pretty printing of yield curves by also using UnicodePlots.jl, for example:\n\njulia> using FinanceModels\njulia> q_rate = ZCBYield.([0.01, 0.02, 0.03,0.04,0.03],[1,3,5,10,20]);\njulia> fit(Spline.PolynomialSpline(3), q_rate, Fit.Bootstrap())\nFinanceModels.Yield.Spline{DataInterpolations.CubicSpline{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, true, Float64}}([0.009950330853168092, 0.009950330853168092, 0.019802627296179747, 0.02955880224154443, 0.0, 1.0, 2.0, 3.0])\n\njulia> using UnicodePlots \njulia> fit(Spline.PolynomialSpline(3), q_rate, Fit.Bootstrap()) # after importing UnicodePlots\n              ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Yield Curve (FinanceModels.Yield.Spline)⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀           \n              ┌────────────────────────────────────────────────────────────┐           \n         0.04 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⠤⠖⠒⠊⠉⠉⠉⠒⠒⠢⠤⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ Zero rates\n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⠔⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠑⠒⢄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠖⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠑⠢⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡔⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠒⢄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⢠⠎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠓⠤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⢠⠎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠑⠦⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⢠⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠓⠦⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀│           \n   Continuous │⠀⠀⠀⠀⠀⢠⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠒⠒⠦⠤⠤⠤⠤│           \n              │⠀⠀⠀⠀⢀⠎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⢀⡎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⢀⠎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠒⠒⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n            0 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              └────────────────────────────────────────────────────────────┘           \n              ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀time⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀30⠀           \n\n\n[!NOTE] This was built-in prior to v4.9 of FinanceModels. It has been split out to materially speed up using FinanceModels.","category":"section"},{"location":"extensions/#Makie-for-Cashflow-Plotting","page":"Extensions","title":"Makie for Cashflow Plotting","text":"A CashflowProjection or a vector of Cashflows can be plotted with the Makie family of plotting packages. For example:\n\nusing FinanceModels, CairoMakie\nproj = Projection(Bond.Fixed(0.10,Periodic(2),20),NullModel(),CashflowProjection())\n# a stem plot:\nstem(proj)\n\nWill produce:\n\n(Image: A stem plot of bond cashflows)","category":"section"}]
}

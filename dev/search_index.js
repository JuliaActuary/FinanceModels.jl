var documenterSearchIndex = {"docs":
[{"location":"faq/#Frequently-Asked-Questions","page":"FAQs","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"faq/#How-can-I-handle-Dates-instead-of-real-timepoints?","page":"FAQs","title":"How can I handle Dates instead of real timepoints?","text":"","category":"section"},{"location":"faq/","page":"FAQs","title":"FAQs","text":"Currently, you must convert the Date into a real-valued timepoint for use within the models and contracts. Future releases may contemplate more explicit, built-in handling of dates. In the meantime, you may find these packages helpful if you need precise date-level accuracy:","category":"page"},{"location":"faq/","page":"FAQs","title":"FAQs","text":"Miletus.jl\nInterestRates.jl\nBusinessDays.jl\nDayCounts.jl\nQuantLib.jl","category":"page"},{"location":"faq/#Why-does-the-package-rely-on-using-Transducers?","page":"FAQs","title":"Why does the package rely on using Transducers?","text":"","category":"section"},{"location":"faq/","page":"FAQs","title":"FAQs","text":"Transducers are a way of defining logic to be applied to a reducible collection. They can compose together efficiently and the compiler can optimize them well. In rewriting the package from v3 to v4, Transducers vastly simplified the iteration and state handling needed when projecting the contracts. The performance remains excellent and made a lot of the internals much simpler.","category":"page"},{"location":"faq/","page":"FAQs","title":"FAQs","text":"Transducers are a rich and powerful way to express programs and can seem somewhat unfamiliar at first encounter. For users of FinanceModels, very of transducers are needed/exposed:","category":"page"},{"location":"faq/","page":"FAQs","title":"FAQs","text":"To regular end-users who just use what is given to them here, the transducers internals are effectively completely hidden\nTo moderately advanced users who want to extend the functionality, as the examples show the only real exposure here is a weird function name ( __foldl__) with for loop with a return signature that has some extra information.","category":"page"},{"location":"faq/","page":"FAQs","title":"FAQs","text":"A number of examples of extending the package are given on the Guide page and the of course the source code itself offers examples of existing Projections and Contracts.","category":"page"},{"location":"faq/#I-have-another-question","page":"FAQs","title":"I have another question","text":"","category":"section"},{"location":"faq/","page":"FAQs","title":"FAQs","text":"Ask on the discussion forum here: https://github.com/JuliaActuary/Yields.jl/discussions","category":"page"},{"location":"guide/#FinanceModels.jl-Guide","page":"Guide","title":"FinanceModels.jl Guide","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"FinanceModels.jl provides a set of composable contracts, models, and functions that allow for modeling of both simple and complex financial instruments. The resulting models, such as discount rates or term structures, can then be used across the JuliaActuary ecosystem to perform actuarial and financial analysis.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"(Image: A conceptual sketch of FinanceModels.jl)","category":"page"},{"location":"guide/#.-Cashflow-a-fundamental-financial-type","page":"Guide","title":"1. Cashflow - a fundamental financial type","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Say you wanted to model a contract that paid quarterly payments, and those payments occurred starting 15 days from the valuation date (first payment time = 15/365 = 0.057)","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Previously, you had two options:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Choose a discrete timestep to model (e.g. monthly, quarterly, annual) and then lump the cashflows into those timesteps. E.g. with monthly timesteps  of a unit payment of our contract, it might look like: [1,0,0,1,0,0...]\nKeep track of two vectors: one for the payment and one for the times. In this case, that might look like: cfs = [1,1,...];times = [0.057, 0.307...]","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"The former has inaccuracies due to the simplified timing and logical complication related to mapping the contracts natural periodicity into an arbitrary modeling choice. The latter becomes unwieldy and fails to take advantage of Julia's type system. ","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"The new solution: Cashflows. Our example above would become: [Cashflow(1,0.057), Cashflow(1,0.307),...]","category":"page"},{"location":"guide/#.-**Contracts**-A-composable-way-to-represent-financial-instruments","page":"Guide","title":"2. Contracts - A composable way to represent financial instruments","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Contracts are a composable way to represent financial instruments. They are, in essence, anything that is a collection of cashflows. Contracts can be combined to represent more complex instruments. For example, a bond can be represented as a collection of cashflows that correspond to the coupon payments and the principal repayment.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Examples:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"a Cashflow\nBonds:\nBond.Fixed, Bond.Floating\nOptions:\nOption.EuroCall and Option.EuroPut \nCompositional contracts:\nForwardto represent an instrument that is relative to a forward point in time.\nComposite to represent the combination of two other instruments.  ","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"In the future, this notion may be extended to liabilities (e.g. insurance policies in LifeContingencies.jl)","category":"page"},{"location":"guide/#Creating-a-new-Contract","page":"Guide","title":"Creating a new Contract","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"A contract is anything that creates a vector of Cashflows when collected. For example, let's create a bond which only pays down principle and offers no coupons.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"using FinanceModels,FinanceCore\n\n# Transducers is used to provide a more powerful, composable way to construct collections than the basic iteration interface\nusing Transducers: __foldl__, @next, complete\n\n\"\"\"\nA bond which pays down its par (one unit) in equal payments. \n\"\"\"\nstruct PrincipalOnlyBond{F<:FinanceCore.Frequency} <: FinanceModels.Bond.AbstractBond\n    frequency::F\n    maturity::Float64\nend\n\n# We extend the interface to say what should happen as the bond is projected\n# There's two parts to customize:\n# 1. any initialization or state to keep track of\n# 2. The loop where we decide what gets returned at each timestep\nfunction Transducers.__foldl__(rf, val, p::Projection{C,M,K}) where {C<:PrincipalOnlyBond,M,K}\n    # initialization stuff\n    b = p.contract # the contract within a projection\n    ts = Bond.coupon_times(b) # works since it's a FinanceModels.Bond.AbstractBond with a frequency and maturity\n    pmt = 1 / length(ts)\n\n    for t in ts\n        # the loop which returns a value\n        cf = Cashflow(pmt, t)\n        val = @next(rf, val, cf) # the value to return is the last argument\n    end\n    return complete(rf, val)\nend","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"That's it! then we can use this contract to fitting models, create projections, quotes, etc. Here we simply collect the bond into an array of cashflows:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"julia> PrincipalOnlyBond(Periodic(2),5.) |> collect\n10-element Vector{Cashflow{Float64, Float64}}:\n Cashflow{Float64, Float64}(0.1, 0.5)\n Cashflow{Float64, Float64}(0.1, 1.0)\n Cashflow{Float64, Float64}(0.1, 1.5)\n Cashflow{Float64, Float64}(0.1, 2.0)\n Cashflow{Float64, Float64}(0.1, 2.5)\n Cashflow{Float64, Float64}(0.1, 3.0)\n Cashflow{Float64, Float64}(0.1, 3.5)\n Cashflow{Float64, Float64}(0.1, 4.0)\n Cashflow{Float64, Float64}(0.1, 4.5)\n Cashflow{Float64, Float64}(0.1, 5.0)","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Note that all contracts in FinanceModels.jl are currently unit contracts in that they assume a unit par value. Scale assets down to unit values before constructing the default contracts.","category":"page"},{"location":"guide/#More-complex-Contracts","page":"Guide","title":"More complex Contracts","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"When the cashflow depends on a model. An example of this is a floating bond where the coupon paid depends on a view of forward rates. See Section 6 - Projections for how this is handled.","category":"page"},{"location":"guide/#.-Quotes-The-observed-price-we-need-to-fit-a-model-to","page":"Guide","title":"3. Quotes - The observed price we need to fit a model to","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Quotes are the observed prices that we need to fit a model to. They represent the market prices of financial instruments, such as bonds or swaps. In the context of the package, a quote is defined as a pair of a contract and a price.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"For example, a par yield bond paying a 4% coupon (paid as 2% twice per annum) implies a price at par (i.e. 1.0):","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"julia> ParYield(Periodic(0.04,2),10)\nQuote{Float64, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}}(\n1.0, \nFinanceModels.Bond.Fixed{Periodic, Float64, Int64}(0.040000000000000036, Periodic(2), 10))\n","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"A number of convenience functions are included to construct a Quote:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"ZCBPrice and ZCBYield\nParYield\nCMTYield\nOISYield\nForwardYields","category":"page"},{"location":"guide/#.-**Models**-Not-just-yield-curves-anymore","page":"Guide","title":"4. Models - Not just yield curves anymore","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Yield Curves: all of Yields.jl yield models are included in the initial FinanceModels.jl release\nEquities and Options: The initial release includes BlackScholesMerton option pricing and one can use constant or spline volatility models\nOthers more to come in the future","category":"page"},{"location":"guide/#Creating-a-new-model","page":"Guide","title":"Creating a new model","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Here we'll do a complete implementation of a yield curve model where the discount rate is approximated by a straight line (often called an AB line from the y=ax+b formula.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":" using FinanceModels, FinanceCore\n using AccessibleOptimization \n using IntervalSets\n \nstruct ABDiscountLine{A} <: FinanceModels.Yield.AbstractYieldModel\n    a::A\n    b::A\nend\n\nABDiscountLine() = ABDiscountLine(0.,0.)\n\nfunction FinanceCore.discount(m::ABDiscountLine,t)\n    #discount rate is approximated by a straight line, floored at 0.0 and capped at 1.0\n    clamp(m.a*t + m.b, 0.0,1.0) \nend\n\n\n# `@optic` indicates what in our model variables needs to be updated (from AccessibleOptimization.jl)\n# `-1.0 .. 1.0` says to bound the search from negative to positive one (from IntervalSets.jl)\nFinanceModels.__default_optic(m::ABDiscountLine) = OptArgs([\n    @optic(_.a) => -1.0 .. 1.0,\n    @optic(_.b) => -1.0 .. 1.0,\n]...)\n\nquotes = ZCBPrice([0.9, 0.8, 0.7,0.6])\n\nm = fit(ABDiscountLine(),quotes)","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Now, m is a model like any of the other yield curve models provided and can be used in that context. For example, calculating the price of the bonds contained within our quotes where we indeed recover the prices for our contrived example:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"julia> map(q -> pv(m,q.instrument),quotes) \n4-element Vector{Float64}:\n 0.9\n 0.8\n 0.7\n 0.6","category":"page"},{"location":"guide/#.-fit-The-standardized-API-for-all-models,-quotes,-and-methods","page":"Guide","title":"5. fit - The standardized API for all models, quotes, and methods","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"       Model                                                               Method\n          |                                                                   |\n    |------------|                                                     |---------------|\nfit(Spline.Cubic(), CMTYield.([0.04,0.05,0.055,0.06,0055],[1,2,3,4,5]), Fit.Bootstrap())\n                    |-------------------------------------------------|\n                                              |\n                                              Quotes","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Model could be Spline.Linear(), Yield.NelsonSiegelSvensson(), Equity.BlackScholesMerton(...), etc.\nQuote could be CMTYields, ParYields, Option.Eurocall, etc.\nMethod could be Fit.Loss(x->x^2), Fit.Loss(x->abs(x)), Fit.Bootstrap(), etc.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"The benefit of this versus the old Yields.jl API is:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Without a generic fit method, no obvious way to expose different curve construction methods (e.g. choice of model and method)\nThe fit is extensible. Users or other packages could define their own Models, Quotes, or Methods and integrate into the JuliaActuary ecosystem.\nThe fit formulation is very generic: the required methods are minimal to integrate in order to extend the functionality.","category":"page"},{"location":"guide/#Customizing-model-fitting","page":"Guide","title":"Customizing model fitting","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Model fitting can be customized:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"The loss function (least squares, absolute difference, etc.) via the third argument to fit:\ne.g.fit(ABDiscountLine(), quotes, FIt.Loss(x -> abs(x))\nthe default is Fit.Loss(x->x^2)\nthe optimization algorithm by defining a method FinanceModels.__default_optim__(m::ABDiscountLine) = OptimizationOptimJL.Newton()\nyou may need to change the __default_optic to be unbounded (simply omit the => and subsequent bounds)\nThe default is OptimizationMetaheuristics.ECA()\nThe general algorithm can be customized by creating a new method for fit: ","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"function FinanceModels.fit(m::ABDiscountLine, quotes, ...)\n\t# custom code for fitting your model here\nend","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"As an example, the splines (Spline.Linear(), Spline.Cubic(),...) are defined to use bootstrap by default: fit(mod0::Spline.BSpline, quotes, method::Fit.Bootstrap)","category":"page"},{"location":"guide/#Using-models-without-fitting","page":"Guide","title":"Using models without fitting","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"While many of the examples show models being fit to observed prices, you can skip that step in practice if you want to define an assumed valuation model that does not intend to calibrate market prices.","category":"page"},{"location":"guide/#.-Projections","page":"Guide","title":"6. Projections","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"A Projection is a generic way to work with various data that you can project forward. For example, getting the series of cashflows associated with a contract.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"What is a Projection?","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"struct Projection{C,M,K} <: AbstractProjection\n    contract::C    # the contract (or set of contracts) we want to project\n    model::M       # the model that defines how the contract will behave\n    kind::K           # what kind of projetion do we want? only cashflows? \nend","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"contract is obvious, so let's talk more about the second two:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"model is the same kind of thing we discussed above. Some contracts (e.g. a floating rate bond). We can still decompose a floating rate bond into a set of cashflows, but we need a model. \nThere are also projections which don't need a model (e.g. fixed bonds) and for that there's the generic NullModel() \nkind defines what we'll return from the projection.\nCashflowProjection() says we just want a Cashflow[...] vector\n... but if we wanted to extend this such that we got a vector containing cashflows, capital factors, default rates, etc we could define a new projection type (e.g. we might call the above AssetDetailProjection()\nCurrently, only CashflowProjection() is defined by FinanceModels.jl","category":"page"},{"location":"guide/#Contracts-that-depend-on-the-model-(or-multiple-models)","page":"Guide","title":"Contracts that depend on the model (or multiple models)","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"For example, the cashflows you generate for a floating rate bond is the current reference rate. Or maybe you have a stochastic volatility model and want to project forward option values. This type of dependency is handled like this:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"define model as a relation that maps a key to a model. E.g. a Dict(\"SOFR\" => NelsonSiegelSvensson(...))\nwhen defining the logic for the reducible collection/foldl, you can reference the Projection.model by the associated key.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Here's how a floating bond is implemented:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"The contract struct. The key would be \"SOFR\" in our example above.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"struct Floating{F<:FinanceCore.Frequency,N<:Real,M<:Timepoint,K} <: AbstractBond\n    coupon_rate::N # coupon_rate / frequency is the actual payment amount\n    frequency::F\n    maturity::M\n    key::K\nend","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"And how we can reference the associated model when projecting that contract. This is very similar to the definition of __foldl__ for our PrincipalOnlyBond, except we are paying a coupon and referencing the scenario rate.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"@inline function Transducers.__foldl__(rf, val, p::Projection{C,M,K}) where {C<:Bond.Floating,M,K}\n    b = p.contract\n    ts = Bond.coupon_times(b)\n    for t in ts\n        freq = b.frequency # e.g. `Periodic(2)`\n        freq_scalar = freq.frequency  # the 2 from `Periodic(2)`\n\n        # get the rate from the current time to next payment \n        # out of the model and convert it to the contract's periodicity\n        model = p.model[b.key]\n        reference_rate = rate(freq(forward(model, t, t + 1 / freq_scalar)))\n        coup = (reference_rate + b.coupon_rate) / freq_scalar\n        amt = if t == last(ts)\n            1.0 + coup\n        else\n            coup\n        end\n        cf = Cashflow(amt, t)\n        val = @next(rf, val, cf)\n    end\n    return complete(rf, val)\nend","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"In this post we've now defined two assets that can work seamlessly with projecting cashflows, fitting models, and determining valuations :)","category":"page"},{"location":"guide/#.-ProjectionKinds","page":"Guide","title":"7. ProjectionKinds","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"While CashflowProjection is the most common (and the only one built into the initial release of FinanceModels), a Projection can be created which handles different kinds of outputs in the same manner as projecting just basic cashflows. For example, you may want to output an amortization schedule, or a financial statement, or an account value roll-forward. The Projection is able to handle these custom outputs by dispatching on the third element in a Projection.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Let's extend the example of a principle-only bond from section 2 above. Our goal is to create a basic amortization schedule which shows the payment made and outstanding balance. ","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"First, we create a new subtype of ProjectionKind:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"struct AmortizationSchedule <: FinanceModels.ProjectionKind\nend","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"And then define the loop for the amortization schedule output:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"# note the dispatch on `AmortizationSchedule` in the next line\nfunction Transducers.__foldl__(rf, val, p::Projection{C,M,K}) where {C<:PrincipalOnlyBond,M,K<:AmortizationSchedule}\n    # initialization stuff\n    b = p.contract # the contract within a projection\n    ts = Bond.coupon_times(b) # works since it's a FinanceModels.Bond.AbstractBond with a frequency and maturity\n    pmt = 1 / length(ts)\n    balance = 1.0\n    for t in ts\n        # the loop wich returns a tuple of the relevant data\n        balance -= pmt\n        result = (time=t,payment=pmt,outstanding=balance)\n        val = @next(rf, val, result) # the value to return is the last argument\n    end\n    return complete(rf, val)\nend","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"We can now define the projection:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"julia> p = Projection(\n           PrincipalOnlyBond(Periodic(2),5.),  # our contract\n           NullModel(),                       # the projection doesn't need a model, so use the null model\n           AmortizationSchedule(),            # specify the amortization schedule output\n           );\n","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"And then collect the values: ","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"julia> collect(p)\n10-element Vector{NamedTuple{(:time, :payment, :outstanding), Tuple{Float64, Float64, Float64}}}:\n (time = 0.5, payment = 0.1, outstanding = 0.9)\n (time = 1.0, payment = 0.1, outstanding = 0.8)\n (time = 1.5, payment = 0.1, outstanding = 0.7000000000000001)\n (time = 2.0, payment = 0.1, outstanding = 0.6000000000000001)\n (time = 2.5, payment = 0.1, outstanding = 0.5000000000000001)\n (time = 3.0, payment = 0.1, outstanding = 0.40000000000000013)\n (time = 3.5, payment = 0.1, outstanding = 0.30000000000000016)\n (time = 4.0, payment = 0.1, outstanding = 0.20000000000000015)\n (time = 4.5, payment = 0.1, outstanding = 0.10000000000000014)\n (time = 5.0, payment = 0.1, outstanding = 1.3877787807814457e-16)","category":"page"},{"location":"api/#FinanceModels-API-Reference","page":"API Reference","title":"FinanceModels API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Please open an issue if you encounter any issues or confusion with the package.","category":"page"},{"location":"api/#Rate-Types","page":"API Reference","title":"Rate Types","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"When JuliaActuary packages return a rate, they will be of a Rate type, such as Rate(0.05,Periodic(2)) for a 5% rate compounded twice per period. It is recommended to keep rates typed and use them throughout the ecosystem without modifying it. ","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"For example, if we construct a curve like this:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"# 2021-03-31 rates from Treasury.gov\nrates =[0.01, 0.01, 0.03, 0.05, 0.07, 0.16, 0.35, 0.92, 1.40, 1.74, 2.31, 2.41] ./ 100\nmats = [1/12, 2/12, 3/12, 6/12, 1, 2, 3, 5, 7, 10, 20, 30]\n  \ncurve = FinanceModels.CMT(rates,mats)","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Then rates from this curve will be typed. For example:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"z = zero(c,10)","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Now, z will be: FinanceModels.Rate{Float64, Continuous}(0.01779624378877313, Continuous())","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"This Rate has both the rate an the compounding convention embedded in the datatype.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"You can now use that rate throughout the JuliaActuary ecosystem, such as with ActuaryUtilities.jl:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"using ActuaryUtilities\npresent_values(z,cashflows)","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"If you need to extract the rate for some reason, you can get the rate by calling FinanceModels.rate(...). Using the above example, FinanceModels.rate(z) will return 0.01779624378877313. ","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [FinanceModels]","category":"page"},{"location":"api/#FinanceModels.CashflowProjection","page":"API Reference","title":"FinanceModels.CashflowProjection","text":"CashflowProjection()\n\nA concrete subtype of ProjectionKind which is the projection which returns only a reducible collection of Cashflows. Use in conjunction with a Projection.\n\n\n\n\n\n","category":"type"},{"location":"api/#FinanceModels.CommonEquity","page":"API Reference","title":"FinanceModels.CommonEquity","text":"CommonEquity()\n\nA singleton type representing a unit stock.\n\nSee also: Option.\n\n\n\n\n\n","category":"type"},{"location":"api/#FinanceModels.Forward","page":"API Reference","title":"FinanceModels.Forward","text":"Forward(time,instrument)\n\nThe instrument is relative to the Forward time. e.g. if you have a Forward(1.0, Cashflow(1.0, 3.0)) then the instrument is a cashflow that pays 1.0 at time 4.0\n\n\n\n\n\n","category":"type"},{"location":"api/#FinanceModels.NullModel","page":"API Reference","title":"FinanceModels.NullModel","text":"NullModel()\n\nA singleton type representing a placeholder model for when you don't really need a model. For example: determining nominal cashflows for fixed income contract.\n\n\n\n\n\n","category":"type"},{"location":"api/#FinanceModels.Projection","page":"API Reference","title":"FinanceModels.Projection","text":"Projection(contract,model,kind)\n\nThe set of contracts and assumptions (model) to project the kind of output desired. Some assets require a projection in order to be valued (e.g. a floating rate bond).\n\nIf attempting to collect or otherwise reduce a contract (<:AbstractContract), by default it will get wrapped into a Projection(contract,NullModel(),CashflowProjection())\n\n\n\n\n\n","category":"type"},{"location":"api/#FinanceModels.ProjectionKind","page":"API Reference","title":"FinanceModels.ProjectionKind","text":"abstract type ProjectionKind\n\nAn abstract type that controls what gets produced from the model.\n\nSubtypes of ProjectionKind define the level of detail in the output of the model. For example, if you just want cashflows or you want a full amortization schedule, you might define an AmortizationSchedule kind which shows principle, interest, etc.\n\nAfter defining a new ProjectionKind, you need to define the how the projection works for that new output by extending either:\n\nfunction Transducers.asfoldable(p::Projection{C,M,K}) where {C<:Cashflow,M,K<:CashflowProjection}\n    ...\nend\n\nor \n\nfunction Transducers.__foldl__(rf, val, p::Projection{C,M,K}) where {C<:Cashflow,M,K<:CashflowProjection}\n    ...\nend\n\nThere are examples of this in the documentation.\n\nExamples\n\n```julia julia> struct CashflowProjection <: ProjectionKind end CashflowProjection\n\njulia> struct AmortizationSchedule <: ProjectionKind end AmortizationSchedule\n\n\n\n\n\n","category":"type"},{"location":"api/#FinanceCore.present_value","page":"API Reference","title":"FinanceCore.present_value","text":"present_value(model,contract,current_time=0.0)\n\nReturn the value of the contract as corresponding with the valuation assumptions embedded in the model.\n\nExamples\n\nm = Equity.BlackScholesMerton(0.01, 0.02, 0.15)\n\na = Option.EuroCall(CommonEquity(), 1.0, 1.0)\n\npv(m, a) # ≈ 0.05410094201902403\n\n\n\n\n\n","category":"function"},{"location":"api/#FinanceModels.__default_optic-Tuple{FinanceModels.Yield.Constant}","page":"API Reference","title":"FinanceModels.__default_optic","text":"__default_optic(model)\n\nReturns the variables to optimize over for the given model. This is an optic/lens specifying which parameters of the modle can vary. See extended help for more. An optic argument is a singular or vector of lenses with an optional range of acceptable parameters.\n\nExamples\n\nWe might have a model as follows where we want fit to optize parameters a and b:\n\nstruct MyModel <:FinanceModels.AbstractModel\n        a \n        b \nend\n\n__default_optic(m::MyModel) = OptArgs([\n    @optic(_.a) => 0.0 .. 100.0,\n    @optic(_.b) => -10.0 .. 10.0,\n]...)\n\nExtended help\n\nAn arbitrarily complex model may be the object we intend to fit - how does fit know what free variables are able to be solved for within the given model? variables is a singlular or vector optic argument. What does this mean?\n\nAn optic (or \"lens\") is a way to define an accessor to a given object. Example:\n\njulia> using Accessors, AccessibleOptimization, IntervalSets\n\njulia> obj = (a = \"AA\", b = \"BB\");\n\njulia> lens = @optic _.a\n(@optic _.a)\n\njulia> lens(obj)\n\"AA\"\n\nAn optic argument is a singular or vector of lenses with an optional range of acceptable parameters. For example, we might have a model as follows where we want  fit to optize parameters a and b:\n\nstruct MyModel <:FinanceModels.AbstractModel\n        a \n        b \nend\n\n__default_optic(m::MyModel) = OptArgs([\n    @optic(_.a) => 0.0 .. 100.0,\n    @optic(_.b) => -10.0 .. 10.0,\n]...)\n\nIn this way, fit know which arbitrary parameters in a given object may be modified. Technically, we are not modifying the immutable MyModel, but instead efficiently creating a new instance. This is enabled by AccessibleOptimization.jl.\n\nNote that not all opitmization algorithms want a bounded interval. In that case, simply leave off the paired range. The prior example would then become:\n\n__default_optic(m::MyModel) = OptArgs([\n    @optic(_.a),\n    @optic(_.b),\n]...)\n\n```\n\n\n\n\n\n","category":"method"},{"location":"api/#FinanceModels.cashflows_timepoints-Tuple{Any}","page":"API Reference","title":"FinanceModels.cashflows_timepoints","text":"cashflows_timepoints(contracts)\ncashflows_timepoints(quotes)\n\nCreate a matrix of cashflows and a vector of timepoints for a collection of quotes or contracts. Timepoints need not be spaced evenly.\n\nThis is used when constructing SmithWilson yield curves.\n\nArguments\n\ncontracts or quotes: A collection of <:AbstractContracts or Quotes.\n\nReturns\n\nA tuple (m, times) where m is a matrix of cashflows and times is a vector of timepoints.\n\nExamples\n\njulia> FinanceModels.cashflows_timepoints(ParYield.([0.04,0.02,0.04],[1,4,4]))\n([0.02 0.01 0.02; 1.02 0.01 0.02; … ; 0.0 0.01 0.02; 0.0 1.01 1.02], [0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0])\n\n\n\n\n\n","category":"method"},{"location":"api/#FinanceModels.eurocall-Tuple{}","page":"API Reference","title":"FinanceModels.eurocall","text":"eurocall(;S=1.,K=1.,τ=1,r,σ,q=0.)\n\nCalculate the Black-Scholes implied option price for a european call, where:\n\nS is the current asset price\nK is the strike or exercise price\nτ is the time remaining to maturity (can be typed with \\tau[tab])\nr is the continuously compounded risk free rate\nσ is the (implied) volatility (can be typed with \\sigma[tab])\nq is the continuously paid dividend rate\n\nRates should be input as rates (not percentages), e.g.: 0.05 instead of 5 for a rate of five percent.\n\n!!! Experimental: this function is well-tested, but the derivatives functionality (API) may change in a future version of ActuaryUtilities.\n\nExtended Help\n\nThis is the same as the formulation presented in the dividend extension of the BS model in Wikipedia.\n\nOther general comments:\n\nSwap/OIS curves are generally better sources for r than government debt (e.g. US Treasury) due to the collateralized nature of swap instruments.\n(Implied) volatility is characterized by a curve that is a function of the strike price (among other things), so take care when using \nYields.jl can assist with converting rates to continuously compounded if you need to perform conversions.\n\n\n\n\n\n","category":"method"},{"location":"api/#FinanceModels.europut-Tuple{}","page":"API Reference","title":"FinanceModels.europut","text":"europut(;S=1.,K=1.,τ=1,r,σ,q=0.)\n\nCalculate the Black-Scholes implied option price for a european call, where:\n\nS is the current asset price\nK is the strike or exercise price\nτ is the time remaining to maturity (can be typed with \\tau[tab])\nr is the continuously compounded risk free rate\nσ is the (implied) volatility (can be typed with \\sigma[tab])\nq is the continuously paid dividend rate\n\nRates should be input as rates (not percentages), e.g.: 0.05 instead of 5 for a rate of five percent.\n\n!!! Experimental: this function is well-tested, but the derivatives functionality (API) may change in a future version of ActuaryUtilities.\n\nExtended Help\n\nThis is the same as the formulation presented in the dividend extension of the BS model in Wikipedia.\n\nOther general comments:\n\nSwap/OIS curves are generally better sources for r than government debt (e.g. US Treasury) due to the collateralized nature of swap instruments.\n(Implied) volatility is characterized by a curve that is a function of the strike price (among other things), so take care when using \nYields.jl can assist with converting rates to continuously compounded if you need to perform conversions.\n\n\n\n\n\n","category":"method"},{"location":"api/#FinanceModels.fit-Union{Tuple{F}, Tuple{Any, Any}, Tuple{Any, Any, F}} where F<:FinanceModels.Fit.Loss","page":"API Reference","title":"FinanceModels.fit","text":"fit(\n    mod0, \n    quotes, \n    method=Fit.Loss(x -> x^2);\n    variables=__default_optic(mod0), \n    optimizer=__default_optim(mod0)\n    )\n\nFit a model to a collection of quotes using a loss function and optimization method.\n\nArguments\n\nmod0: The initial model to fit, which is generally an instantiated but un-optimized model.\nquotes: A collection of quotes to fit the model to.\nmethod::F=Fit.Loss(x -> x^2): The loss function to use for fitting the model. Defaults to the squared loss function. \nmethod can also be Bootstrap(). If this is the case, mod0 should be a spline such as Spline.Linear(), Spline.Cubic()...\nvariables=__default_optic(mod0): The variables to optimize over. This is an optic specifying which parameters of the modle can vary. See extended help for more.\noptimizer=__default_optim(mod0): The optimization algorithm to use. The default optimization for a given model is ECA from Metahueristics.jl; see extended help for more on customizing the solver including setting the seed.\n\nThe optimization routine will then attempt to modify parameters of mod0 to best fit the quoted prices of the contracts underlying the quotes by calling present_value(model,contract). The optimization will minimize the loss function specified within Fit.Loss(...). \n\nDifferent types of quotes are appropriate for different kinds of models. For example, if you try to value a set of equtiy EuroCalls with a Yield.Constant, you will get an error because the present_value(m<:Yield.Constant,o<:EuroCall) is not defined.\n\nReturns\n\nThe fitted model.\n\nExamples\n\njulia> mod0 = Yield.Constant();\n\njulia> quotes = ZCBPrice([0.9, 0.8, 0.7,0.6]);\n\njulia> fit(mod0,quotes)\n\n              ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Yield Curve (FinanceModels.Yield.Constant)⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀           \n              ┌────────────────────────────────────────────────────────────┐           \n     0.120649 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ Zero rates\n              │⠀⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⣧⢰⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⣿⣾⠀⣀⣸⠀⢸⢳⣇⢀⣀⣀⣀⣀⣀⠀⡀⣀⣀⣀⡀⡀⣀⢀⣀⡀⡀⣀⢀⡀⣀⡀⢀⣀⡀⢀⡀⢀⣀⡀⢀⡀⠀⣀⡀⢀⡀⢀⣀⡀⢀⣀⠀⣀⡀⢀⣀⠀⢀│           \n              │⢠⢻⡟⡆⣿⡟⣦⠚⠀⢸⣾⠛⠛⠘⠛⠘⢲⡗⠛⠃⠛⠓⠓⠛⠚⠛⠑⠓⠛⠃⠓⠛⠑⠚⡟⠓⢻⡗⠚⠀⠓⠚⠑⠒⠃⠓⠚⠑⠚⠀⠓⠃⠘⠒⠃⠓⠃⠘⠒⠃│           \n              │⢸⢸⡇⢹⡏⠁⠉⠀⠀⠈⠉⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⠈⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n   Continuous │⢸⢸⡇⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⢸⠀⠁⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⢸⠀⠀⠘⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⡎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n     0.120649 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              └────────────────────────────────────────────────────────────┘           \n              ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀time⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀30⠀  \n\n\nExtended help\n\nCustomizing the Solver\n\nThe default solver is ECA() from Metahueristics.jl. This is a stochastic global optimizer which will run with a random seed by default.\n\nTo make the seed static, you can specify the kwarg to fit with a customized ECA: e.g. fit(...;optimizer=ECA(seed=123))\nA number of options are available for ECA() or you may specify a different solver.\nMore documentation is available from the upstream packages:\nMetaheuristics.jl\nOptimization.jl\nAccessibleOptimization.jl\n\nDefining the variables\n\nAn arbitrarily complex model may be the object we intend to fit - how does fit know what free variables are able to be solved for within the given model? variables is a singlular or vector optic argument. What does this mean?\n\nAn optic (or \"lens\") is a way to define an accessor to a given object. Example:\n\njulia> using Accessors, AccessibleOptimization, IntervalSets\n\njulia> obj = (a = \"AA\", b = \"BB\");\n\njulia> lens = @optic _.a\n(@optic _.a)\n\njulia> lens(obj)\n\"AA\"\n\nAn optic argument is a singular or vector of lenses with an optional range of acceptable parameters. For example, we might have a model as follows where we want  fit to optize parameters a and b:\n\nstruct MyModel <:FinanceModels.AbstractModel\n     a \n     b \nend\n\n__default_optic(m::MyModel) = OptArgs([\n    @optic(_.a) => 0.0 .. 100.0,\n    @optic(_.b) => -10.0 .. 10.0,\n]...)\n\nIn this way, fit know which arbitrary parameters in a given object may be modified. Technically, we are not modifying the immutable MyModel, but instead efficiently creating a new instance. This is enabled by AccessibleOptimization.jl.\n\nNote that not all opitmization algorithms want a bounded interval. In that case, simply leave off the paired range. The prior example would then become:\n\n__default_optic(m::MyModel) = OptArgs([\n    @optic(_.a),\n    @optic(_.b),\n]...)\n\n```\n\nAdditional Examples\n\nSee the tutorials in the package documentation for FinanceModels.jl or the docstrings of FinanceModels.jl's avaiable model types.\n\n\n\n\n\n","category":"method"},{"location":"api/#FinanceModels.volatility-Tuple{FinanceModels.Volatility.Constant, Any, Any}","page":"API Reference","title":"FinanceModels.volatility","text":"volatility(volatiltiy_model,strike_ratio,time_to_maturity)\n\nReturns the volatility associated with the moneyness (strike/price ratio) and time to maturity.\n\n\n\n\n\n","category":"method"},{"location":"migration/#Migration-Guide","page":"Migration Guide","title":"Migration Guide","text":"","category":"section"},{"location":"migration/#v3-to-v4","page":"Migration Guide","title":"v3 to v4","text":"","category":"section"},{"location":"migration/#Yields.jl-is-now-FinanceModels.jl","page":"Migration Guide","title":"Yields.jl is now FinanceModels.jl","text":"","category":"section"},{"location":"migration/","page":"Migration Guide","title":"Migration Guide","text":"This re-write accomplishes three primary things:","category":"page"},{"location":"migration/","page":"Migration Guide","title":"Migration Guide","text":"Provide a composable set of contracts and Quotes \nThose contracts, when combined with a model produce a Cashflow via a flexibly defined Projection\nmodels can be fit with a new unified API: fit(model_type,quotes,fit_method) ","category":"page"},{"location":"migration/#Migrating-Code","page":"Migration Guide","title":"Migrating Code","text":"","category":"section"},{"location":"migration/#Update-Dependencies","page":"Migration Guide","title":"Update Dependencies","text":"","category":"section"},{"location":"migration/","page":"Migration Guide","title":"Migration Guide","text":"You should remove Yields from your project's dependencies and add FinanceModels instead. (link to Pkg documentation on how to do this)","category":"page"},{"location":"migration/#API-Changes","page":"Migration Guide","title":"API Changes","text":"","category":"section"},{"location":"migration/","page":"Migration Guide","title":"Migration Guide","text":"Previously, the API pattern was, e.g.:","category":"page"},{"location":"migration/","page":"Migration Guide","title":"Migration Guide","text":"model = Yields.Par(SmitWilson(...), rates,timepoints)","category":"page"},{"location":"migration/","page":"Migration Guide","title":"Migration Guide","text":"Now, follow the pattern of:","category":"page"},{"location":"migration/","page":"Migration Guide","title":"Migration Guide","text":"Define the quotes you want to fit the model to\nfit the model to those quotes","category":"page"},{"location":"migration/","page":"Migration Guide","title":"Migration Guide","text":"Example:","category":"page"},{"location":"migration/","page":"Migration Guide","title":"Migration Guide","text":"quotes = ParYield.(rates,timepoints)\nmodel = fit(SmithWilson(),quotes)","category":"page"},{"location":"migration/#Discussion","page":"Migration Guide","title":"Discussion","text":"","category":"section"},{"location":"migration/","page":"Migration Guide","title":"Migration Guide","text":"Previously the kind of contract, the implied quotes, the type of model, and how the fitting process worked were all combined into a single call (Yields.Par). This minimized the amount of code needed to construct a yield curve, but left it fairly cumbersome to extend the package. For example, for every new yield curve model, methods for Par, CMT, OIS, Zero, ... had to be defined. Additionally, all of the inputs needed to be yields - specifying a price was not available as an argument to fit. ","category":"page"},{"location":"migration/","page":"Migration Guide","title":"Migration Guide","text":"With the new design of the package, creating a completely new model is much easier, as only the model itself and the valuation primitives need to be defined. For example, defining a new yield curve type that works to value contracts instrument quotes only requires defining the discount method. To allow the model to be fit requires only defining a default set of parameters to optimize with __default_optic:","category":"page"},{"location":"migration/","page":"Migration Guide","title":"Migration Guide","text":" using FinanceModels, FinanceCore\n using AccessibleOptimization \n using IntervalSets\n \nstruct ABDiscountLine{A} <: FinanceModels.Yield.AbstractYieldModel\n    a::A\n    b::A\nend\n\n# define the default constructor for convenience\nABDiscountLine() = ABDiscountLine(0.,0.)\n\nfunction FinanceCore.discount(m::ABDiscountLine,t)\n    #discount rate is approximated by a straight lined, floored at 0.0 and capped at 1.0\n    clamp(m.a*t + m.b, 0.0,1.0) \nend\n\n\n# `@optic` indicates what in our model variables needs to be updated (from AccessibleOptimization.jl)\n# `-1.0 .. 1.0` says to bound the search from negative to positive one (from IntervalSets.jl)\nFinanceModels.__default_optic(m::ABDiscountLine) = OptArgs([\n    @optic(_.a) => -1.0 .. 1.0,\n    @optic(_.b) => -1.0 .. 1.0,\n]...)\n\nquotes = ZCBPrice([0.9, 0.8, 0.7,0.6])\n\nm = fit(ABDiscountLine(),quotes)","category":"page"},{"location":"models/#Models,-Valuation,-Projections,-and-Fitting","page":"Models, Valuation, and Fitting","title":"Models, Valuation, Projections, and Fitting","text":"","category":"section"},{"location":"models/#Page-Contents","page":"Models, Valuation, and Fitting","title":"Page Contents","text":"","category":"section"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"Pages = [\"models.md\"]\nDepth = 4","category":"page"},{"location":"models/#Introduction","page":"Models, Valuation, and Fitting","title":"Introduction","text":"","category":"section"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"Conceptually, we have an iterative process:","category":"page"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"We use models to value contracts\nWe use observed (or assumed) prices to calibrate models","category":"page"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"Thus the discussion of model calibration and valuation of contracts is inextricably linked together.","category":"page"},{"location":"models/#Yield-(Interest-Rate)-models","page":"Models, Valuation, and Fitting","title":"Yield (Interest Rate) models","text":"","category":"section"},{"location":"models/#Rates","page":"Models, Valuation, and Fitting","title":"Rates","text":"","category":"section"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"We should first discuss Rates, which are reexported from FinanceCore.jl","category":"page"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"Rates are types that wrap scalar values to provide information about how to determine discount and accumulation factors. These allow for explicit handling of rate compounding conventions which, if not explicit, is often a source of errors in practice.","category":"page"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"There are two Frequency types:","category":"page"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"Yields.Periodic(m) for rates that compound m times per period (e.g. m times per year if working with annual rates).\nYields.Continuous() for continuously compounding rates.","category":"page"},{"location":"models/#Examples","page":"Models, Valuation, and Fitting","title":"Examples","text":"","category":"section"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"Continuous(0.05)       # 5% continuously compounded\nPeriodic(0.05,2)       # 5% compounded twice per period","category":"page"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"These are both subtypes of the parent Rate type and are instantiated as:","category":"page"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"Rate(0.05,Continuous())       # 5% continuously compounded\nRate(0.05,Periodic(2))        # 5% compounded twice per period","category":"page"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"Broadcast over a vector to create Rates with the given compounding:","category":"page"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"Periodic.([0.02,0.03,0.04],2) \nContinuous.([0.02,0.03,0.04]) ","category":"page"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"Rates can also be constructed by specifying the CompoundingFrequency and then passing a scalar rate:","category":"page"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"Periodic(1)(0.05)\nContinuous()(0.05)","category":"page"},{"location":"models/#Conversion","page":"Models, Valuation, and Fitting","title":"Conversion","text":"","category":"section"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"Convert rates between different types with convert. E.g.:","category":"page"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"r = Rate(Yields.Periodic(12),0.01)             # rate that compounds 12 times per rate period (ie monthly)\n\nconvert(Yields.Periodic(1),r)                  # convert monthly rate to annual effective\nconvert(Yields.Continuous(),r)          # convert monthly rate to continuous","category":"page"},{"location":"models/#Arithmetic","page":"Models, Valuation, and Fitting","title":"Arithmetic","text":"","category":"section"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"Adding, subtracting, multiplying, dividing, and comparing rates is supported.","category":"page"},{"location":"models/#Available-Models-Yields","page":"Models, Valuation, and Fitting","title":"Available Models - Yields","text":"","category":"section"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"Yield.Constant\nBootstrapped Spline\nYield.SmithWilson\nYield.NelsonSiegel\nYield.NelsonSiegelSvensson","category":"page"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"Yield models can also be composed. Here is an example of fitting rates and spread separately and then adding the two models together:","category":"page"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"julia> q_rate = ZCBYield([0.01,0.02,0.03]);\n\njulia> q_spread = ZCBYield([0.01,0.01,0.01]);\n\njulia> m_rate = fit(Spline.Linear(),q_rate,Fit.Bootstrap());⠀           \n\njulia> m_spread = fit(Spline.Linear(),q_spread,Fit.Bootstrap());\n\njulia> forward(m_spread + m_rate,0,1)\nRate{Float64, Continuous}(0.01980262729617973, Continuous())\n\njulia> forward(m_spread + m_rate,0,1) |> Periodic(1)\nRate{Float64, Periodic}(0.020000000000000018, Periodic(1))\n\njulia> discount(m_spread + m_rate,0,3)\n0.8889963586709149\n\njulia> discount(0.04,3)\n0.8889963586709148","category":"page"},{"location":"models/#Creating-New-Yield-Models","page":"Models, Valuation, and Fitting","title":"Creating New Yield Models","text":"","category":"section"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"See the Guide for an example of creating a model from scratch. Some additional aspects to note:","category":"page"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"The only method that must be defined to calculate the present_value of something is discount. Other methods will be inferred.\nOther methods that are imputed by default, but can be extended include: accumulation, forward, par, zero, and rate.","category":"page"},{"location":"models/#Equity-and-Volatility-Models","page":"Models, Valuation, and Fitting","title":"Equity and Volatility Models","text":"","category":"section"},{"location":"models/#Available-Models-Option-Valuation","page":"Models, Valuation, and Fitting","title":"Available Models - Option Valuation","text":"","category":"section"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"Option.BlackScholesMerton","category":"page"},{"location":"models/#Available-Models-Volatility","page":"Models, Valuation, and Fitting","title":"Available Models - Volatility","text":"","category":"section"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"Volatility.Constant","category":"page"},{"location":"models/#Creating-new-Volatility-Models","page":"Models, Valuation, and Fitting","title":"Creating new Volatility Models","text":"","category":"section"},{"location":"models/","page":"Models, Valuation, and Fitting","title":"Models, Valuation, and Fitting","text":"A volatility model must extend volatility(vol::Volatility.MyNewModel, strike_ratio, time_to_maturity).","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = FinanceModels","category":"page"},{"location":"#FinanceModels.jl","page":"Home","title":"FinanceModels.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage)","category":"page"},{"location":"","page":"Home","title":"Home","text":"FinanceModels.jl provides a set of composable contracts, models, and functions that allow for modeling of both simple and complex financial instruments. The resulting models, such as discount rates or term structures, can then be used across the JuliaActuary ecosystem to perform actuarial and financial analysis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Additionally, the models can be used to project contracts through time: most basically as a series of cashflows but more complex output can be defined for contracts.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: anim_fps2)","category":"page"},{"location":"#QuickStart","page":"Home","title":"QuickStart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using FinanceModels\n\n# a set of market-observed prices we wish to calibrate the model to\n# annual effective unless otherwise specified\nq_rate = ZCBYield([0.01,0.02,0.03]);\nq_spread = ZCBYield([0.01,0.01,0.01]);\n\n# bootstrap a linear spline yield model\nmodel_rate = fit(Spline.Linear(),q_rate,Fit.Bootstrap());⠀           \nmodel_spread = fit(Spline.Linear(),q_spread,Fit.Bootstrap());\n\n# the zero rate is the combination of the two underlying rates\nzero(m_spread + m_rate,1) # 0.02 annual effective rate \n\n# the discount is the same as if we added the underlying zero rates\ndiscount(m_spread + m_rate,0,3) ≈ discount(0.01 + 0.03,3)   # true\n\n# compute the present value of a contract (a cashflow of 10 at time 3)\npresent_value(m_rate,Cashflow(10,3)) # 9.15...","category":"page"},{"location":"#Overview-of-FinanceModels","page":"Home","title":"Overview of FinanceModels","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: A conceptual sketch of FinanceModels.jl)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Often we start with observed or assumed values for existing contracts. We want to then use those assumed values to extend the valuation logic to new contracts. For example, we may have a set of bond yields which we then want to discount a series of insurance obligations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In the language of FinanceModels, we would have a set of Quotes which are used to fit a Model. That model is then used to discount a new series of cashflows.","category":"page"},{"location":"","page":"Home","title":"Home","text":"That's just an example, and we can use the various components in different ways depending on the objective of the analysis.","category":"page"},{"location":"#Contracts-and-Quotes","page":"Home","title":"Contracts and Quotes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Contracts are a way to represent financial obligations. These can be valued using a model, projected into a future steam of values, or combined with assumed prices as a Quote.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Included are a number of primitives and convenience methods for contracts:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Existing structs:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Cashflow\nBond.Fixed\nBond.Floating\nForward (an obligation with a forward start time)\nComposite (combine two other contracts, e.g. into a swap)\nEuroCall\nCommonEquity","category":"page"},{"location":"","page":"Home","title":"Home","text":"Commonly, we deal with conventions that imply a contract and an observed price. For example, we may talk about a treasury yield of 0.03. This is a description that implies a Quoteed price for an underling fixed bond. In FinanceModels, we could use CMTYield(rate,tenor) which would create a Quote(price,Bond.Fixed(...)). In this way, we can conveniently create a number of Quotes which can be used to fit models. Such convenience methods include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ZCBYield\nZCBPrice\nCMTYield\nParYield\nParSwapYield\nForwardYield","category":"page"},{"location":"","page":"Home","title":"Home","text":"FinanceModels offers a way to define new contracts as well.","category":"page"},{"location":"#Cashflows","page":"Home","title":"Cashflows","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Cashflows obligation are themselves a contract, but other contracts can be considered as essentially anything that can be combined with assumptions (a model) to derive a collection of cashflows.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For example, a obligation that pays 1.75 at time 2 could be represented as: Cashflow(1.75,2). ","category":"page"},{"location":"#Models","page":"Home","title":"Models","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Models are objects that can be fit to observed prices and then subsequently used to make valuations of other cashflows/contracts.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Yield models include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Yield.Constant\nBootstrapped Splines\nYield.SmithWilson\nYield.NelsonSiegel\nYield.NelsonSiegelSvensson","category":"page"},{"location":"#Yield-related-functions","page":"Home","title":"Yield-related functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The models can be used to compute various rates of interest:","category":"page"},{"location":"","page":"Home","title":"Home","text":"discount(curve,from,to) or discount(curve,to) gives the discount factor\naccumulation(curve,from,to) or accumulation(curve,to) gives the accumulation factor\nzero(curve,time) or zero(curve,time,Frequency) gives the zero-coupon spot rate for the given time.\nforward(curve,from,to) gives the zero rate between the two given times\npar(curve,time;frequency=2) gives the coupon-paying par equivalent rate for the given time.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Other models include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"BlackScholesMerton derivative valuation","category":"page"},{"location":"#Projections","page":"Home","title":"Projections","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Most basically, we can project a contract into a series of Cashflows: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> b = Bond.Fixed(0.04,Periodic(2),3)\nFinanceModels.Bond.Fixed{Periodic, Float64, Int64}(0.04, Periodic(2), 3)\n\njulia> collect(b)\n6-element Vector{Cashflow{Float64, Float64}}:\n Cashflow{Float64, Float64}(0.02, 0.5)\n Cashflow{Float64, Float64}(0.02, 1.0)\n Cashflow{Float64, Float64}(0.02, 1.5)\n Cashflow{Float64, Float64}(0.02, 2.0)\n Cashflow{Float64, Float64}(0.02, 2.5)\n Cashflow{Float64, Float64}(1.02, 3.0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"However, Projections allow one to combine three elements which can be extended to define any desired output (such as amortization schedules, financial statement projections, or account value rollforwards). The three elements are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"the underlying contract of interest\nthe model which includes assumptions of how the contract will behave\na ProjectionKind which indicates the kind of output desired (cashflow stream, amortization schedule, etc...)","category":"page"},{"location":"#Fitting-Models","page":"Home","title":"Fitting Models","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"       Model                                                               Method\n          |                                                                   |\n  \t|------------|                                                     |---------------|\nfit(Spline.Cubic(), CMTYield.([0.04,0.05,0.055,0.06,0055],[1,2,3,4,5]), Fit.Bootstrap())\n                    |-------------------------------------------------|\n                                              |\n                                              Quotes","category":"page"},{"location":"","page":"Home","title":"Home","text":"Model could be Spline.Linear(), Yield.NelsonSiegelSvensson(), Equity.BlackScholesMerton(...), etc.\nQuote could be CMTYields, ParYields, Option.Eurocall, etc.\nMethod could be Fit.Loss(x->x^2), Fit.Loss(x->abs(x)), Fit.Bootstrap(), etc.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This unified way to fit models offers a much simpler way to extend functionality to new models or contract types.","category":"page"},{"location":"#Using-Models","page":"Home","title":"Using Models","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"After being fit, models can be used to value contracts:","category":"page"},{"location":"","page":"Home","title":"Home","text":"present_value(model,cashflows)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Additionally, ActuaryUtilities.jl offers a number of other methods that can be used, such as duration, convexity, price which can be used for analysis with the fitted models.","category":"page"},{"location":"#Rates","page":"Home","title":"Rates","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Rates are types that wrap scalar values to provide information about how to determine discount and accumulation factors.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are two Frequency types:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Periodic(m) for rates that compound m times per period (e.g. m times per year if working with annual rates).\nContinuous() for continuously compounding rates.","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Continuous(0.05)       # 5% continuously compounded\nPeriodic(0.05,2)       # 5% compounded twice per period","category":"page"},{"location":"","page":"Home","title":"Home","text":"These are both subtypes of the parent Rate type and are instantiated as:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Rate(0.05,Continuous())       # 5% continuously compounded\nRate(0.05,Periodic(2))        # 5% compounded twice per period","category":"page"},{"location":"","page":"Home","title":"Home","text":"Rates can also be constructed by specifying the Frequency and then passing a scalar rate:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Periodic(1)(0.05)\nContinuous()(0.05)","category":"page"},{"location":"#Conversion","page":"Home","title":"Conversion","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Convert rates between different types with convert. E.g.:","category":"page"},{"location":"","page":"Home","title":"Home","text":"r = Rate(FinanceModels.Periodic(12),0.01)             # rate that compounds 12 times per rate period (ie monthly)\n\nconvert(FinanceModels.Periodic(1),r)                  # convert monthly rate to annual effective\nconvert(FinanceModels.Continuous(),r)          # convert monthly rate to continuous","category":"page"},{"location":"#Arithmetic","page":"Home","title":"Arithmetic","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Adding, substracting, multiplying, dividing, and comparing rates is supported.","category":"page"},{"location":"#Guide-and-Documentation","page":"Home","title":"Guide and Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A guide which explains more about the components of the package and from-scratch examples of extending the package is available in the documenation","category":"page"},{"location":"#Exported-vs-Un-exported-Functions","page":"Home","title":"Exported vs Un-exported Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Generally, CamelCase methods which construct a datatype are exported as they are unlikely to conflict with other parts of code that may be written. For example, rate is un-exported (it must be called with FinanceModels.rate(...)) because rate is likely a very commonly defined variable within actuarial and financial contexts and there is a high risk of conflicting with defined variables.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Consider using import FinanceModels which would require qualifying all methods, but alleviates any namespace conflicts and has the benefit of being explicit about the calls (internally we prefer this in the package design to keep dependencies and their usage clear). ","category":"page"},{"location":"#Internals","page":"Home","title":"Internals","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For time-variant FinanceModels (ie yield curves), the inputs are converted to spot rates and interpolated using quadratic B-splines by default (see documentation for alternatives, such as linear interpolations).","category":"page"},{"location":"#Combination-Implementation","page":"Home","title":"Combination Implementation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Combinations track two different curve objects and are not combined into a single underlying data structure. This means that you may achieve better performance if you combine the rates before constructing a FinanceModels representation. The exception to this is Constant curves, which do get combined into a single structure that is as performant as pre-combined rate structure.","category":"page"},{"location":"#Related-Packages","page":"Home","title":"Related Packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"InterestRates.jl specializes in fast rate calculations aimed at valuing fixed income contracts, with business-day-level accuracy.\nComparative comments: FinanceModels.jl does not try to provide as precise controls over the timing, structure, and interpolation of the curve. Instead, FinanceModels.jl provides a minimal, but flexible and intuitive interface for common modeling needs.","category":"page"},{"location":"contracts/#Contracts","page":"Contracts","title":"Contracts","text":"","category":"section"},{"location":"contracts/#Page-Contents","page":"Contracts","title":"Page Contents","text":"","category":"section"},{"location":"contracts/","page":"Contracts","title":"Contracts","text":"Pages = [\"contracts.md\"]\nDepth = 4","category":"page"},{"location":"contracts/#**Contracts**-A-composable-way-to-represent-financial-instruments","page":"Contracts","title":"Contracts - A composable way to represent financial instruments","text":"","category":"section"},{"location":"contracts/","page":"Contracts","title":"Contracts","text":"Contracts are a composable way to represent financial instruments. They are, in essence, anything that is a collection of cashflows. Contracts can be combined to represent more complex instruments. For example, a bond can be represented as a collection of cashflows that correspond to the coupon payments and the principal repayment.","category":"page"},{"location":"contracts/","page":"Contracts","title":"Contracts","text":"Examples:","category":"page"},{"location":"contracts/","page":"Contracts","title":"Contracts","text":"a Cashflow\nBonds:\nBond.Fixed, Bond.Floating\nOptions:\nOption.EuroCall and Option.EuroPut \nCompositional contracts:\nForwardto represent an instrument that is relative to a forward point in time.\nComposite to represent the combination of two other instruments.  ","category":"page"},{"location":"contracts/","page":"Contracts","title":"Contracts","text":"In the future, this notion may be extended to liabilities (e.g. insurance policies in LifeContingencies.jl)","category":"page"},{"location":"contracts/#Cashflow-a-fundamental-financial-type","page":"Contracts","title":"Cashflow - a fundamental financial type","text":"","category":"section"},{"location":"contracts/","page":"Contracts","title":"Contracts","text":"Say you wanted to model a contract that paid quarterly payments, and those payments occurred starting 15 days from the valuation date (first payment time = 15/365 = 0.057)","category":"page"},{"location":"contracts/","page":"Contracts","title":"Contracts","text":"Previously, you had two options:","category":"page"},{"location":"contracts/","page":"Contracts","title":"Contracts","text":"Choose a discrete timestep to model (e.g. monthly, quarterly, annual) and then lump the cashflows into those timesteps. E.g. with monthly timesteps  of a unit payment of our contract, it might look like: [1,0,0,1,0,0...]\nKeep track of two vectors: one for the payment and one for the times. In this case, that might look like: cfs = [1,1,...];times = [0.057, 0.307...]","category":"page"},{"location":"contracts/","page":"Contracts","title":"Contracts","text":"The former has inaccuracies due to the simplified timing and logical complication related to mapping the contracts natural periodicity into an arbitrary modeling choice. The latter becomes unwieldy and fails to take advantage of Julia's type system. ","category":"page"},{"location":"contracts/","page":"Contracts","title":"Contracts","text":"The new solution: Cashflows. Our example above would become: [Cashflow(1,0.057), Cashflow(1,0.307),...]","category":"page"},{"location":"contracts/#Creating-a-new-Contract","page":"Contracts","title":"Creating a new Contract","text":"","category":"section"},{"location":"contracts/","page":"Contracts","title":"Contracts","text":"A contract is anything that creates a vector of Cashflows when collected. For example, let's create a bond which only pays down principle and offers no coupons.","category":"page"},{"location":"contracts/","page":"Contracts","title":"Contracts","text":"using FinanceModels,FinanceCore\n\n# Transducers is used to provide a more powerful, composible way to construct collections than the basic iteration interface\nusing Transducers: __foldl__, @next, complete\n\n\"\"\"\nA bond which pays down its par (one unit) in equal payments. \n\"\"\"\nstruct PrincipleOnlyBond{F<:FinanceCore.Frequency} <: FinanceModels.Bond.AbstractBond\n    frequency::F\n    maturity::Float64\nend\n\n# We extend the interface to say what should happen as the bond is projected\n# There's two parts to customize:\n# 1. any initialization or state to keep track of\n# 2. The loop where we decide what gets returned at each timestep\nfunction Transducers.__foldl__(rf, val, p::Projection{C,M,K}) where {C<:PrincipleOnlyBond,M,K}\n    # initialization stuff\n    b = p.contract # the contract within a projection\n    ts = Bond.coupon_times(b) # works since it's a FinanceModels.Bond.AbstractBond with a frequency and maturity\n    pmt = 1 / length(ts)\n\n    for t in ts\n        # the loop wich returns a value\n        cf = Cashflow(pmt, t)\n        val = @next(rf, val, cf) # the value to return is the last argument\n    end\n    return complete(rf, val)\nend","category":"page"},{"location":"contracts/","page":"Contracts","title":"Contracts","text":"That's it! then we can use this fitting models, projections, quotes, etc. Here we simply collect the bond into an array of cashflows:","category":"page"},{"location":"contracts/","page":"Contracts","title":"Contracts","text":"julia> PrincipleOnlyBond(Periodic(2),5.) |> collect\n10-element Vector{Cashflow{Float64, Float64}}:\n Cashflow{Float64, Float64}(0.1, 0.5)\n Cashflow{Float64, Float64}(0.1, 1.0)\n Cashflow{Float64, Float64}(0.1, 1.5)\n Cashflow{Float64, Float64}(0.1, 2.0)\n Cashflow{Float64, Float64}(0.1, 2.5)\n Cashflow{Float64, Float64}(0.1, 3.0)\n Cashflow{Float64, Float64}(0.1, 3.5)\n Cashflow{Float64, Float64}(0.1, 4.0)\n Cashflow{Float64, Float64}(0.1, 4.5)\n Cashflow{Float64, Float64}(0.1, 5.0)","category":"page"},{"location":"contracts/","page":"Contracts","title":"Contracts","text":"Note that all contracts in FinanceModels.jl are currently unit contracts in that they assume a unit par value. ","category":"page"},{"location":"contracts/#More-complex-Contracts","page":"Contracts","title":"More complex Contracts","text":"","category":"section"},{"location":"contracts/","page":"Contracts","title":"Contracts","text":"When the cashflow depends on a model. An example of this is a floating bond where the coupon paid depends on a view of forward rates. See this section in the overview on projections for how this is handled.","category":"page"},{"location":"contracts/#Availalbe-Contracts-and-Modules","page":"Contracts","title":"Availalbe Contracts & Modules","text":"","category":"section"},{"location":"contracts/#Bond-Module","page":"Contracts","title":"Bond Module","text":"","category":"section"},{"location":"contracts/","page":"Contracts","title":"Contracts","text":"Modules = [FinanceModels.Bond]","category":"page"},{"location":"contracts/#FinanceModels.Bond","page":"Contracts","title":"FinanceModels.Bond","text":"The Bond module provide a number of fixed-income contracts and related methods.\n\n\n\n\n\n","category":"module"},{"location":"contracts/#FinanceModels.Bond.Fixed","page":"Contracts","title":"FinanceModels.Bond.Fixed","text":"Bond.Fixed(coupon_rate,frequency<:FinanceCore.Frequency,maturity)\n\nAn object representing a fixed coupon bond. coupon_rate / frequency is the actual payment amount.\n\nNote that there are a number of convienience constructors which return a Quote for a Bond.Fixed: \n\nParYield\nParSwapYield\nCMTYield\nOISYield\n\nSee also Quote.\n\nExamples\n\njulia> Bond.Fixed(0.05,Periodic(2),3)\nFinanceModels.Bond.Fixed{Periodic, Float64, Int64}(0.05, Periodic(2), 3)\n\njulia> Bond.Fixed(0.05,Periodic(2),3) |> collect\n6-element Vector{Cashflow{Float64, Float64}}:\n Cashflow{Float64, Float64}(0.025, 0.5)\n Cashflow{Float64, Float64}(0.025, 1.0)\n Cashflow{Float64, Float64}(0.025, 1.5)\n Cashflow{Float64, Float64}(0.025, 2.0)\n Cashflow{Float64, Float64}(0.025, 2.5)\n Cashflow{Float64, Float64}(1.025, 3.0)\n\n\njulia> ParYield(0.05,10)\nQuote{Float64, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}}(1.0, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}(0.05, Periodic(2), 10))\n\n\n\n\n\n","category":"type"},{"location":"contracts/#FinanceModels.Bond.Floating","page":"Contracts","title":"FinanceModels.Bond.Floating","text":"Bond.Floating(coupon_rate,frequency<:FinanceCore.Frequency,maturity,model_key)\n\nAn object representing a floating coupon bond. (coupon_rate + reference rate) / frequency is the actual payment amount, where the reference rate requires a Projection with a key/value pair where the key is the model_key argument and the value is the model which produces the reference rate.\n\nSee also Quote.\n\nExamples\n\njulia> p = Projection(\n        Bond.Floating(0.02, Periodic(1), 3.0, \"SOFR\"),\n        Dict(\"SOFR\" => Yield.Constant(0.05)),  # note the key/value store used for the model in the projection\n        CashflowProjection(),\n    );\n\njulia> collect(p)\n3-element Vector{Cashflow{Float64, Float64}}:\n    Cashflow{Float64, Float64}(0.07000000000000005, 1.0)\n    Cashflow{Float64, Float64}(0.07000000000000005, 2.0)\n    Cashflow{Float64, Float64}(1.07, 3.0)\n\n\n\n\n\n","category":"type"},{"location":"contracts/#FinanceModels.Bond.CMTYield-Tuple{Any, Any}","page":"Contracts","title":"FinanceModels.Bond.CMTYield","text":"CMTYield(yield,maturity)\nCMTYield(yield::Vector)\n\nReturns a Quote for the correpsonding bond implied by the given bond equivalent yield, and assumes that instruments <= one year maturity` pay no coupons and that the rest pay semi-annual.\n\nUse broadcasting to create a set of quotes given a collection of FinanceModels and maturities, e.g. CMTYield.(FinanceModels,maturities).\n\nSee also Quote, Bond.Fixed\n\nExamples\n\njulia> CMTYield(0.05,10)\nQuote{Float64, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}}(1.0, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}(0.05, Periodic(2), 10))\n\n\n\n\n\n","category":"method"},{"location":"contracts/#FinanceModels.Bond.ForwardYields","page":"Contracts","title":"FinanceModels.Bond.ForwardYields","text":"ForwardYields(yields,times)\n\nReturns a vector of Quote corresponding to the yield at the given forward times. \n\nExamples\n\njulia> FinanceModels.Bond.ForwardYields([0.01,0.02],[1.,3.])\n2-element Vector{Quote{Float64, Cashflow{Float64, Float64}}}:\n Quote{Float64, Cashflow{Float64, Float64}}(0.9900990099009901, Cashflow{Float64, Float64}(1.0, 1.0))\n Quote{Float64, Cashflow{Float64, Float64}}(0.9423223345470445, Cashflow{Float64, Float64}(1.0, 3.0))\n\n\n\n\n\n","category":"function"},{"location":"contracts/#FinanceModels.Bond.OISYield-Tuple{Any, Any}","page":"Contracts","title":"FinanceModels.Bond.OISYield","text":"OISYield(yield, maturity)\n\nReturns the implied Quote for the fixed bond implied by the given yield and maturity. Assumes that maturities less than or equal to 12 months are settled once (per Hull textbook, 4.7), otherwise quarterly and that the FinanceModels given are bond equivalent.\n\nUse broadcasting to create a set of quotes given a collection of FinanceModels and maturities, e.g. OISYield.(FinanceModels,maturities).\n\nSee also Quote, Bond.Fixed\n\nExamples\n\njulia> OISYield(0.05,10)\nQuote{Float64, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}}(1.0, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}(0.05, Periodic(4), 10))\n\n\n\n\n\n","category":"method"},{"location":"contracts/#FinanceModels.Bond.ParSwapYield-Tuple{Any, Any}","page":"Contracts","title":"FinanceModels.Bond.ParSwapYield","text":"ParSwapYield(yield, maturity; frequency=Periodic(4))\n\nSame as ParYield, except the frequency is four times per period by default.\n\n\n\n\n\n","category":"method"},{"location":"contracts/#FinanceModels.Bond.ParYield-Tuple{Any, Any}","page":"Contracts","title":"FinanceModels.Bond.ParYield","text":"ParYield(yield, maturity; frequency=Periodic(2)) ParYield(yield::Vector)\n\nTakes bond equivalent FinanceModels, and assumes that instruments <= one year maturity pay no coupons and that the rest pay semi-annual. Alternative, you may pass a Rate as the yield and the coupon frequency will be inferred from the Rate's frequency. \n\nUse broadcasting to create a set of quotes given a collection of FinanceModels and maturities, e.g. ParYield.(FinanceModels,maturities).\n\nExamples\n\njulia> ParYield(0.05,10)\nQuote{Float64, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}}(1.0, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}(0.05, Periodic(2), 10))\n\n\n\n\n\n","category":"method"},{"location":"contracts/#FinanceModels.Bond.ZCBPrice-Tuple{Any, Any}","page":"Contracts","title":"FinanceModels.Bond.ZCBPrice","text":"ZCBPrice(discount,maturity)\nZCBPrice(yield::Vector)\n\nTakes spot/zero discount factors and returns a Quote for the cashflow occuring at the given maturity.\n\nUse broadcasting to create a set of quotes given a collection of prices and maturities, e.g. ZCBPrice.(FinanceModels,maturities).\n\nSee also ZCBYield\n\nExamples\n\n\njulia> ZCBPrice(0.5,10)\nQuote{Float64, Cashflow{Float64, Int64}}(0.5, Cashflow{Float64, Int64}(1.0, 10))\n\njulia> ZCBPrice([0.9,0.8,0.75])\n3-element Vector{Quote{Float64, Cashflow{Float64, Int64}}}:\n Quote{Float64, Cashflow{Float64, Int64}}(0.9, Cashflow{Float64, Int64}(1.0, 1))\n Quote{Float64, Cashflow{Float64, Int64}}(0.8, Cashflow{Float64, Int64}(1.0, 2))\n Quote{Float64, Cashflow{Float64, Int64}}(0.75, Cashflow{Float64, Int64}(1.0, 3))\n \n\n\n\n\n\n","category":"method"},{"location":"contracts/#FinanceModels.Bond.ZCBYield-Tuple{Any, Any}","page":"Contracts","title":"FinanceModels.Bond.ZCBYield","text":"ZCBYield(yield,maturity)\nZCBYield(yield::Vector)\n\nReturns a Quote for the cashflow occuring at the given maturity and the quoted value is derived from the given yield.\n\nTakes zero (sometimes called \"spot\") rates. Assumes annual effective compounding (Periodic(1)) unless given aRate` with a different compounding frequency.\n\nUse broadcasting to create a set of quotes given a collection of FinanceModels and maturities, e.g. ZCBYield.(FinanceModels,maturities).\n\nSee also ZCBPrice\n\nExamples\n\njulia> ZCBYield(0.05,30)\nQuote{Float64, Cashflow{Float64, Int64}}(0.23137744865585788, Cashflow{Float64, Int64}(1.0, 30))\n\njulia> ZCBYield(Periodic(0.05,1),30)\nQuote{Float64, Cashflow{Float64, Int64}}(0.23137744865585788, Cashflow{Float64, Int64}(1.0, 30))\n\njulia> ZCBYield(Continuous(0.05),30)\nQuote{Float64, Cashflow{Float64, Int64}}(0.22313016014842982, Cashflow{Float64, Int64}(1.0, 30))\n\njulia> ZCBYield([0.04,0.05,0.045])\n3-element Vector{Quote{Float64, Cashflow{Float64, Int64}}}:\n Quote{Float64, Cashflow{Float64, Int64}}(0.9615384615384615, Cashflow{Float64, Int64}(1.0, 1))\n Quote{Float64, Cashflow{Float64, Int64}}(0.9070294784580498, Cashflow{Float64, Int64}(1.0, 2))\n Quote{Float64, Cashflow{Float64, Int64}}(0.8762966040549094, Cashflow{Float64, Int64}(1.0, 3))\n\n\n\n\n\n","category":"method"},{"location":"contracts/#FinanceModels.Bond.coupon_times-Tuple{Any, Any}","page":"Contracts","title":"FinanceModels.Bond.coupon_times","text":"coupon_times(maturity, frequency)\n\nGenerate coupon times for a bond with the given maturity and frequency.\n\nArguments\n\nmaturity::Real: The maturity of the bond.\nfrequency::Real: The coupon frequency of the bond.\n\nReturns\n\nAn array of coupon times for the bond.\n\nExamples\n\njulia-repl julia> Bond.coupon_times(10, 2) 0.5:0.5:10.0 julia> Bond.coupon_times(Bond.Fixed(0.05,Periodic(4),20)) 0.25:0.25:20.0`\n\n\n\n\n\n","category":"method"},{"location":"contracts/#Other-Contracts","page":"Contracts","title":"Other Contracts","text":"","category":"section"},{"location":"contracts/","page":"Contracts","title":"Contracts","text":"Composite\nCommonEquity\nForward","category":"page"},{"location":"contracts/#Derivatives","page":"Contracts","title":"Derivatives","text":"","category":"section"},{"location":"contracts/","page":"Contracts","title":"Contracts","text":"Modules = [FinanceModels.Option]","category":"page"},{"location":"contracts/#FinanceModels.Option","page":"Contracts","title":"FinanceModels.Option","text":"\n\n\n\n","category":"module"},{"location":"Updates/#FinanceModels.jl","page":"FinanceModels.jl","title":"FinanceModels.jl","text":"","category":"section"},{"location":"Updates/#Design","page":"FinanceModels.jl","title":"Design","text":"","category":"section"},{"location":"Updates/","page":"FinanceModels.jl","title":"FinanceModels.jl","text":"Contracts represent insturments that ultimately obligate a payment of cashflows, which may or may not be scenario dependant. \nQuotes are observed or reference prices that may be used to fit models.\nModels are the combination of assumptions and logic that can then be used to realize the assumed cashflows that arise from a contract.","category":"page"},{"location":"Updates/#Motivation","page":"FinanceModels.jl","title":"Motivation","text":"","category":"section"},{"location":"Updates/","page":"FinanceModels.jl","title":"FinanceModels.jl","text":"FinanceModels.jl is the evolution of Yields.jl. Yields.jl was originally designed for very nice usage of term structures of yield curves, but three aspects held it back:","category":"page"},{"location":"Updates/","page":"FinanceModels.jl","title":"FinanceModels.jl","text":"The design was very oriented towards interest rates, and it was awkward to stick, e.g. volatility models into a package called Yields.jl\nThe API for contructing curves was inconsistent because there are different ways to construct a given curve and the inputs to constructing a simple bootstrapped curve with a spline through given yields vs a best-fit of a variety of instrumnets was simply a different paradigm.\nThere was a lack of ability to even express some types of contracts that are useful for model-fitting or modeling in general.","category":"page"},{"location":"Updates/#TODOs","page":"FinanceModels.jl","title":"TODOs","text":"","category":"section"},{"location":"Updates/","page":"FinanceModels.jl","title":"FinanceModels.jl","text":"bond.frequency.frequency is awkward\nCore contracts:\nComposite contact (e.g. Fixed + Float -> Swap)\nForward contact\nDerivatives?\ndistinguish between clean and dirty prices\nProjections\nEverythign is currently coerced to a F64/F64 Cashflow, but would like to be flexible with amount and timepoints\nHow to integrate Dates?\nCore methods:\nport Yields.jl methods\nErgonomics:\n\nPackage design:\npromote pv to FinanceCore given it's utility here\npromote Cashflow up to FC ","category":"page"}]
}

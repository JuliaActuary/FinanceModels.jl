var documenterSearchIndex = {"docs":
[{"location":"Updates/#FinanceModels.jl","page":"FinanceModels.jl","title":"FinanceModels.jl","text":"","category":"section"},{"location":"Updates/#Design","page":"FinanceModels.jl","title":"Design","text":"Contracts represent insturments that ultimately obligate a payment of cashflows, which may or may not be scenario dependant.\nQuotes are observed or reference prices that may be used to fit models.\nModels are the combination of assumptions and logic that can then be used to realize the assumed cashflows that arise from a contract.","category":"section"},{"location":"Updates/#Motivation","page":"FinanceModels.jl","title":"Motivation","text":"FinanceModels.jl is the evolution of Yields.jl. Yields.jl was originally designed for very nice usage of term structures of yield curves, but three aspects held it back:\n\nThe design was very oriented towards interest rates, and it was awkward to stick, e.g. volatility models into a package called Yields.jl\nThe API for contructing curves was inconsistent because there are different ways to construct a given curve and the inputs to constructing a simple bootstrapped curve with a spline through given yields vs a best-fit of a variety of instrumnets was simply a different paradigm.\nThere was a lack of ability to even express some types of contracts that are useful for model-fitting or modeling in general.","category":"section"},{"location":"Updates/#TODOs","page":"FinanceModels.jl","title":"TODOs","text":"bond.frequency.frequency is awkward\nCore contracts:\nComposite contact (e.g. Fixed + Float -> Swap)\nForward contact\nDerivatives?\ndistinguish between clean and dirty prices\nProjections\nEverythign is currently coerced to a F64/F64 Cashflow, but would like to be flexible with amount and timepoints\nHow to integrate Dates?\nCore methods:\nport Yields.jl methods\nErgonomics\n\nPackage design:\npromote pv to FinanceCore given it's utility here\npromote Cashflow up to FC","category":"section"},{"location":"API/Option/#FinanceModels.Option-API-Reference","page":"Option","title":"FinanceModels.Option API Reference","text":"Modules = [FinanceModels.Option]","category":"section"},{"location":"API/Option/#Exported-API","page":"Option","title":"Exported API","text":"","category":"section"},{"location":"API/Option/#Unexported-API","page":"Option","title":"Unexported API","text":"Please open an issue if you encounter any issues or confusion with the package.","category":"section"},{"location":"API/Option/#FinanceModels.Option","page":"Option","title":"FinanceModels.Option","text":"\n\n\n\n","category":"module"},{"location":"API/Option/#FinanceModels.Option.Cap","page":"Option","title":"FinanceModels.Option.Cap","text":"Cap(strike, frequency, maturity)\n\nAn interest rate cap — a portfolio of caplets that pay max(L(Tᵢ₋₁,Tᵢ) - strike, 0) · τ at each payment date Tᵢ, where L is the simply-compounded forward rate and τ = 1/frequency.\n\nThe first caplet resets at time τ (the first period's rate is known).\n\n\n\n\n\n","category":"type"},{"location":"API/Option/#FinanceModels.Option.EuroCall","page":"Option","title":"FinanceModels.Option.EuroCall","text":"EuroCall(contract,strike,maturity)\n\nA European call option on the given contract with the given strike and maturity.\n\nArguments\n\ncontract::AbstractContract -  The underlying contract.\nstrike::Real -  The strike price.\nmaturity::Union{Real,Date} -  The maturity of the option.\n\nSupertype Hierarchy ≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡\n\nEuroCall{S,K,M} <: FinanceCore.AbstractContract <: Any\n\n\n\n\n\n","category":"type"},{"location":"API/Option/#FinanceModels.Option.EuroPut","page":"Option","title":"FinanceModels.Option.EuroPut","text":"EuroPut(contract,strike,maturity)\n\nA European put option on the given contract with the given strike and maturity.\n\nArguments\n\ncontract::AbstractContract -  The underlying contract.\nstrike::Real -  The strike price.\nmaturity::Union{Real,Date} -  The maturity of the option.\n\nSupertype Hierarchy ≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡\n\nEuroPut{S,K,M} <: FinanceCore.AbstractContract <: Any\n\n\n\n\n\n","category":"type"},{"location":"API/Option/#FinanceModels.Option.Floor","page":"Option","title":"FinanceModels.Option.Floor","text":"Floor(strike, frequency, maturity)\n\nAn interest rate floor — a portfolio of floorlets that pay max(strike - L(Tᵢ₋₁,Tᵢ), 0) · τ at each payment date Tᵢ.\n\n\n\n\n\n","category":"type"},{"location":"API/Option/#FinanceModels.Option.Swaption","page":"Option","title":"FinanceModels.Option.Swaption","text":"Swaption(expiry, swap_maturity, strike, frequency; payer=true)\n\nA European swaption — the right to enter an interest rate swap at expiry. The underlying swap has payment dates from expiry + 1/frequency to swap_maturity, paying a fixed rate strike.\n\npayer=true (default): right to pay fixed, receive floating\npayer=false: right to receive fixed, pay floating\n\n\n\n\n\n","category":"type"},{"location":"API/Option/#FinanceModels.Option.ZCBCall","page":"Option","title":"FinanceModels.Option.ZCBCall","text":"ZCBCall(expiry, bond_maturity, strike)\n\nA European call option on a zero-coupon bond. The holder has the right to buy at time expiry a ZCB maturing at bond_maturity for strike.\n\n\n\n\n\n","category":"type"},{"location":"API/Option/#FinanceModels.Option.ZCBPut","page":"Option","title":"FinanceModels.Option.ZCBPut","text":"ZCBPut(expiry, bond_maturity, strike)\n\nA European put option on a zero-coupon bond. The holder has the right to sell at time expiry a ZCB maturing at bond_maturity for strike.\n\n\n\n\n\n","category":"type"},{"location":"API/Fit/#FinanceModels.Fit-API-Reference","page":"Fit","title":"FinanceModels.Fit API Reference","text":"Modules = [FinanceModels.Fit]","category":"section"},{"location":"API/Fit/#Exported-API","page":"Fit","title":"Exported API","text":"","category":"section"},{"location":"API/Fit/#Unexported-API","page":"Fit","title":"Unexported API","text":"Please open an issue if you encounter any issues or confusion with the package.","category":"section"},{"location":"API/Fit/#FinanceModels.Fit.Bootstrap","page":"Fit","title":"FinanceModels.Fit.Bootstrap","text":"Bootstrap()\n\nA singleton type which is passed to fit in order to bootstrap Splines. The curves are fit such that the spline passes through the zero rates of the curve. \n\nA subtype of FitMethod.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"API/Fit/#FinanceModels.Fit.Loss","page":"Fit","title":"FinanceModels.Fit.Loss","text":"Fit.Loss(function)\n\nfunction should be a loss measure, such as x->x^2 or x->abs(x). This is used by the optimization algorithm in fit to determine optimal parameters as defined by this loss function.\n\nA subtype of FitMethod.\n\nExamples\n\njulia> mod0 = Yield.Constant();\n\njulia> quotes = ZCBPrice([0.9, 0.8, 0.7,0.6]);\n\njulia> fit(mod0,quotes,Fit.Loss(x-x^2))\n\n              ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Yield Curve (FinanceModels.Yield.Constant)⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀           \n              ┌────────────────────────────────────────────────────────────┐           \n     0.120649 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ Zero rates\n              │⠀⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⣧⢰⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⣿⣾⠀⣀⣸⠀⢸⢳⣇⢀⣀⣀⣀⣀⣀⠀⡀⣀⣀⣀⡀⡀⣀⢀⣀⡀⡀⣀⢀⡀⣀⡀⢀⣀⡀⢀⡀⢀⣀⡀⢀⡀⠀⣀⡀⢀⡀⢀⣀⡀⢀⣀⠀⣀⡀⢀⣀⠀⢀│           \n              │⢠⢻⡟⡆⣿⡟⣦⠚⠀⢸⣾⠛⠛⠘⠛⠘⢲⡗⠛⠃⠛⠓⠓⠛⠚⠛⠑⠓⠛⠃⠓⠛⠑⠚⡟⠓⢻⡗⠚⠀⠓⠚⠑⠒⠃⠓⠚⠑⠚⠀⠓⠃⠘⠒⠃⠓⠃⠘⠒⠃│           \n              │⢸⢸⡇⢹⡏⠁⠉⠀⠀⠈⠉⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⠈⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n   Continuous │⢸⢸⡇⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⢸⠀⠁⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⢸⠀⠀⠘⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⡎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n     0.120649 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              └────────────────────────────────────────────────────────────┘           \n              ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀time⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀30⠀  \n\n\n\n\n\n\n","category":"type"},{"location":"contracts/#Contracts","page":"Contracts","title":"Contracts","text":"","category":"section"},{"location":"contracts/#**Contracts**-A-composable-way-to-represent-financial-instruments","page":"Contracts","title":"Contracts - A composable way to represent financial instruments","text":"Contracts are a composable way to represent financial instruments. They are, in essence, anything that is a collection of cashflows. Contracts can be combined to represent more complex instruments. For example, a bond can be represented as a collection of cashflows that correspond to the coupon payments and the principal repayment.\n\nExamples:\n\na Cashflow\nBonds:\nBond.Fixed, Bond.Floating\nOptions:\nOption.EuroCall and Option.EuroPut\nCompositional contracts:\nForwardto represent an instrument that is relative to a forward point in time.\nComposite to represent the combination of two other instruments.  \n\nIn the future, this notion may be extended to liabilities (e.g. insurance policies in LifeContingencies.jl)","category":"section"},{"location":"contracts/#Cashflow-a-fundamental-financial-type","page":"Contracts","title":"Cashflow - a fundamental financial type","text":"Say you wanted to model a contract that paid quarterly payments, and those payments occurred starting 15 days from the valuation date (first payment time = 15/365 = 0.057)\n\nPreviously, you had two options:\n\nChoose a discrete timestep to model (e.g. monthly, quarterly, annual) and then lump the cashflows into those timesteps. E.g. with monthly timesteps  of a unit payment of our contract, it might look like: [1,0,0,1,0,0...]\nKeep track of two vectors: one for the payment and one for the times. In this case, that might look like: cfs = [1,1,...];times = [0.057, 0.307...]\n\nThe former has inaccuracies due to the simplified timing and logical complication related to mapping the contracts natural periodicity into an arbitrary modeling choice. The latter becomes unwieldy and fails to take advantage of Julia's type system.\n\nThe new solution: Cashflows. Our example above would become: [Cashflow(1,0.057), Cashflow(1,0.307),...]","category":"section"},{"location":"contracts/#Creating-a-new-Contract","page":"Contracts","title":"Creating a new Contract","text":"A contract is anything that creates a vector of Cashflows when collected. For example, let's create a bond which only pays down principle and offers no coupons.\n\nusing FinanceModels,FinanceCore\n\n# Transducers is used to provide a more powerful, composible way to construct collections than the basic iteration interface\nusing Transducers: __foldl__, @next, complete\n\n\"\"\"\nA bond which pays down its par (one unit) in equal payments. \n\"\"\"\nstruct PrincipleOnlyBond{F<:FinanceCore.Frequency} <: FinanceModels.Bond.AbstractBond\n    frequency::F\n    maturity::Float64\nend\n\n# We extend the interface to say what should happen as the bond is projected\n# There's two parts to customize:\n# 1. any initialization or state to keep track of\n# 2. The loop where we decide what gets returned at each timestep\nfunction Transducers.__foldl__(rf, val, p::Projection{C,M,K}) where {C<:PrincipleOnlyBond,M,K}\n    # initialization stuff\n    b = p.contract # the contract within a projection\n    ts = Bond.coupon_times(b) # works since it's a FinanceModels.Bond.AbstractBond with a frequency and maturity\n    pmt = 1 / length(ts)\n\n    for t in ts\n        # the loop wich returns a value\n        cf = Cashflow(pmt, t)\n        val = @next(rf, val, cf) # the value to return is the last argument\n    end\n    return complete(rf, val)\nend\n\nThat's it! then we can use this fitting models, projections, quotes, etc. Here we simply collect the bond into an array of cashflows:\n\njulia> PrincipleOnlyBond(Periodic(2),5.) |> collect\n10-element Vector{Cashflow{Float64, Float64}}:\n Cashflow{Float64, Float64}(0.1, 0.5)\n Cashflow{Float64, Float64}(0.1, 1.0)\n Cashflow{Float64, Float64}(0.1, 1.5)\n Cashflow{Float64, Float64}(0.1, 2.0)\n Cashflow{Float64, Float64}(0.1, 2.5)\n Cashflow{Float64, Float64}(0.1, 3.0)\n Cashflow{Float64, Float64}(0.1, 3.5)\n Cashflow{Float64, Float64}(0.1, 4.0)\n Cashflow{Float64, Float64}(0.1, 4.5)\n Cashflow{Float64, Float64}(0.1, 5.0)\n\nNote that all contracts in FinanceModels.jl are currently unit contracts in that they assume a unit par value.","category":"section"},{"location":"contracts/#More-complex-Contracts","page":"Contracts","title":"More complex Contracts","text":"","category":"section"},{"location":"contracts/#Sets-of-contracts","page":"Contracts","title":"Sets of contracts","text":"Sets of contracts can be put in an AbstractArray contained (e.g. a Vector) and then handled together. For example, we combine two bonds as a portfolio to project together:\n\njulia> c1 = Bond.Fixed(0.05, Periodic(1), 2.0);\njulia> c2 = Bond.Fixed(0.04, Periodic(1), 2.0);\n\njulia> Projection([c1, c2]) |> collect\n4-element Vector{Cashflow{Float64, Float64}}:\n Cashflow{Float64, Float64}(0.05, 1.0)\n Cashflow{Float64, Float64}(1.05, 2.0)\n Cashflow{Float64, Float64}(0.04, 1.0)\n Cashflow{Float64, Float64}(1.04, 2.0)","category":"section"},{"location":"contracts/#Transformations","page":"Contracts","title":"Transformations","text":"Contracts (<:AbstractContract) and Projections can be modified to be scaled or transformed using the transformations in Transducers.jl after importing that package.\n\nMost commonly, this is likely simply chaining Map(...) calls. Two use-cases of this may be to (1) scale the contract by a factor or (2) change the sign of the contract to indicate an obligation/liability instead of an asset. Examples of this:\n\njulia> using Transducers, FinanceModels\n\njulia> Bond.Fixed(0.05,Periodic(1),3) |> collect\n3-element Vector{Cashflow{Float64, Float64}}:\n Cashflow{Float64, Float64}(0.05, 1.0)\n Cashflow{Float64, Float64}(0.05, 2.0)\n Cashflow{Float64, Float64}(1.05, 3.0)\n\njulia> Bond.Fixed(0.05,Periodic(1),3) |> Map(-) |> collect\n3-element Vector{Cashflow{Float64, Float64}}:\n Cashflow{Float64, Float64}(-0.05, 1.0)\n Cashflow{Float64, Float64}(-0.05, 2.0)\n Cashflow{Float64, Float64}(-1.05, 3.0)\n\njulia> Bond.Fixed(0.05,Periodic(1),3) |> Map(-) |> Map(x->x*2) |> collect\n3-element Vector{Cashflow{Float64, Float64}}:\n Cashflow{Float64, Float64}(-0.1, 1.0)\n Cashflow{Float64, Float64}(-0.1, 2.0)\n Cashflow{Float64, Float64}(-2.1, 3.0)\n\nAnother example of this is how InterestRateSwap[@ref] is implemented. It's simply a Composite contract of a positive fixed rate bond and a negative floating rate bond:\n\nfunction InterestRateSwap(curve, tenor; model_key=\"OIS\")\n    fixed_rate = par(curve, tenor; frequency=4)\n    fixed_leg = Bond.Fixed(rate(fixed_rate), Periodic(4), tenor)\n    float_leg = Bond.Floating(0.0, Periodic(4), tenor, model_key) |> Map(-)\n    return Composite(fixed_leg, float_leg)\nend","category":"section"},{"location":"contracts/#Cashflows-are-model-dependent","page":"Contracts","title":"Cashflows are model dependent","text":"An example of this is a floating bond where the coupon paid depends on a view of forward rates. See this section in the overview on projections for how this is handled.","category":"section"},{"location":"contracts/#Available-Contracts-and-Modules","page":"Contracts","title":"Available Contracts & Modules","text":"See the Modules in the left navigation for details on available contracts/models/functions.","category":"section"},{"location":"API/ShortRate/#FinanceModels.ShortRate-API-Reference","page":"ShortRate","title":"FinanceModels.ShortRate API Reference","text":"Modules = [FinanceModels.ShortRate]","category":"section"},{"location":"API/ShortRate/#Exported-API","page":"ShortRate","title":"Exported API","text":"","category":"section"},{"location":"API/ShortRate/#Simulation-and-Monte-Carlo","page":"ShortRate","title":"Simulation and Monte Carlo","text":"","category":"section"},{"location":"API/ShortRate/#Unexported-API","page":"ShortRate","title":"Unexported API","text":"Please open an issue if you encounter any issues or confusion with the package.","category":"section"},{"location":"API/ShortRate/#FinanceModels.simulate","page":"ShortRate","title":"FinanceModels.simulate","text":"simulate(model::AbstractStochasticModel;\n         n_scenarios=1000, timestep=1/12, horizon=30.0,\n         rng=Random.default_rng())\n\nGenerate n_scenarios interest-rate paths via Euler-Maruyama discretisation. Each path is returned as a RatePath (an AbstractYieldModel) so it plugs directly into present_value, discount, etc.\n\n\n\n\n\n","category":"function"},{"location":"API/ShortRate/#FinanceModels.pv_mc","page":"ShortRate","title":"FinanceModels.pv_mc","text":"pv_mc(model, contract;\n      n_scenarios=1000, timestep=1/12, horizon=nothing,\n      rng=Random.default_rng())\n\nEstimate the expected present value of contract under the stochastic model by averaging present_value across simulated scenarios.\n\nnote: Note\npv_mc is designed for fixed-cashflow instruments where each RatePath scenario provides the discount factors. For floating-rate instruments whose cashflows depend on the rate path, project cashflows per scenario using Projection instead.\n\nThe horizon should cover the contract's maturity. The default (maturity + 1) ensures this.\n\n\n\n\n\n","category":"function"},{"location":"API/ShortRate/#FinanceModels.short_rate","page":"ShortRate","title":"FinanceModels.short_rate","text":"short_rate(path::RatePath, t)\n\nThe instantaneous short rate r(t) for a simulated scenario.\n\nRatePath stores the cumulative integral ∫₀ᵗ r(s) ds as a LinearInterpolation. The short rate is the derivative of this cumulative integral.\n\nBecause the cumulative integral is built from Euler-Maruyama trapezoidal steps, the returned rate is piecewise-constant within each timestep — an approximation to the continuous short-rate process, not the exact value.\n\n\n\n\n\n","category":"function"},{"location":"API/ShortRate/#FinanceModels.ShortRate.CoxIngersollRoss","page":"ShortRate","title":"FinanceModels.ShortRate.CoxIngersollRoss","text":"CoxIngersollRoss(a, b, σ, initial)\n\nCox-Ingersoll-Ross (1985) mean-reverting short-rate model:\n\ndr = a(b - r) dt + σ √r dW\n\nArguments\n\na: speed of mean reversion\nb: long-term mean rate (continuous compounding). Can be passed as a Real or Continuous(b).\nσ: volatility\ninitial: initial short rate r₀ (a Rate object or Real)\n\nnote: Feller condition\nThe condition 2ab > σ² is required for the variance process to stay strictly positive. When violated, the short rate can reach zero; simulation uses absorption at zero (full truncation scheme) in that case.\n\n\n\n\n\n","category":"type"},{"location":"API/ShortRate/#FinanceModels.ShortRate.HullWhite","page":"ShortRate","title":"FinanceModels.ShortRate.HullWhite","text":"HullWhite(a, σ, curve)\n\nHull-White (1990) one-factor model:\n\ndr = (θ(t) - a r) dt + σ dW\n\nwhere θ(t) is calibrated to fit the initial term structure curve.\n\nArguments\n\na: speed of mean reversion\nσ: volatility\ncurve: an existing yield model providing the initial term structure\n\n\n\n\n\n","category":"type"},{"location":"API/ShortRate/#FinanceModels.ShortRate.Vasicek","page":"ShortRate","title":"FinanceModels.ShortRate.Vasicek","text":"Vasicek(a, b, σ, initial)\n\nVasicek (1977) mean-reverting short-rate model:\n\ndr = a(b - r) dt + σ dW\n\nArguments\n\na: speed of mean reversion\nb: long-term mean rate (continuous compounding). Can be passed as a Real or Continuous(b).\nσ: volatility\ninitial: initial short rate r₀ (a Rate object or Real)\n\nnote: Note\nThe Vasicek model allows negative rates. For very negative rates or long horizons, discount factors may exceed 1.\n\n\n\n\n\n","category":"type"},{"location":"models/#Models,-Valuation,-Projections,-and-Fitting","page":"Models, Valuation, and Fitting","title":"Models, Valuation, Projections, and Fitting","text":"","category":"section"},{"location":"models/#Introduction","page":"Models, Valuation, and Fitting","title":"Introduction","text":"Conceptually, we have an iterative process:\n\nWe use models to value contracts\nWe use observed (or assumed) prices to calibrate models\n\nThus the discussion of model calibration and valuation of contracts is inextricably linked together.","category":"section"},{"location":"models/#Yield-(Interest-Rate)-models","page":"Models, Valuation, and Fitting","title":"Yield (Interest Rate) models","text":"","category":"section"},{"location":"models/#Rates","page":"Models, Valuation, and Fitting","title":"Rates","text":"We should first discuss Rates, which are reexported from FinanceCore.jl\n\nRates are types that wrap scalar values to provide information about how to determine discount and accumulation factors. These allow for explicit handling of rate compounding conventions which, if not explicit, is often a source of errors in practice.\n\nThere are two Frequency types:\n\nYields.Periodic(m) for rates that compound m times per period (e.g. m times per year if working with annual rates).\nYields.Continuous() for continuously compounding rates.","category":"section"},{"location":"models/#Examples","page":"Models, Valuation, and Fitting","title":"Examples","text":"Continuous(0.05)       # 5% continuously compounded\nPeriodic(0.05,2)       # 5% compounded twice per period\n\nThese are both subtypes of the parent Rate type and are instantiated as:\n\nRate(0.05,Continuous())       # 5% continuously compounded\nRate(0.05,Periodic(2))        # 5% compounded twice per period\n\nBroadcast over a vector to create Rates with the given compounding:\n\nPeriodic.([0.02,0.03,0.04],2) \nContinuous.([0.02,0.03,0.04]) \n\nRates can also be constructed by specifying the CompoundingFrequency and then passing a scalar rate:\n\nPeriodic(1)(0.05)\nContinuous()(0.05)","category":"section"},{"location":"models/#Conversion","page":"Models, Valuation, and Fitting","title":"Conversion","text":"Convert rates between different types with convert. E.g.:\n\nr = Rate(0.01,Periodic(12))             # rate that compounds 12 times per rate period (ie monthly)\n\nconvert(Yields.Periodic(1),r)                  # convert monthly rate to annual effective\nconvert(Yields.Continuous(),r)          # convert monthly rate to continuous\n\nTo get the scalar value out of the Rate, use FinanceModels.rate(r):\n\njulia> r = Rate(0.01,Periodic(12));   \njulia> rate(r)\n0.01\n","category":"section"},{"location":"models/#Available-Models-Yields","page":"Models, Valuation, and Fitting","title":"Available Models - Yields","text":"FinanceModels.Yield.Constant\nBootstrapped Splines\nFinanceModels.Yield.SmithWilson\nFinanceModels.Yield.NelsonSiegel\nFinanceModels.Yield.NelsonSiegelSvensson","category":"section"},{"location":"models/#Available-Models-Stochastic-Short-Rates","page":"Models, Valuation, and Fitting","title":"Available Models - Stochastic Short Rates","text":"Stochastic short-rate models with closed-form zero-coupon bond prices. These are full yield models that also support Monte Carlo simulation. See the Stochastic Models guide for details and examples.\n\nFinanceModels.ShortRate.Vasicek\nFinanceModels.ShortRate.CoxIngersollRoss\nFinanceModels.ShortRate.HullWhite","category":"section"},{"location":"models/#Arithmetic","page":"Models, Valuation, and Fitting","title":"Arithmetic","text":"Adding, subtracting, multiplying, dividing, and comparing rates is supported.\n\nYield models can also be composed. Here is an example of fitting rates and spread separately and then adding the two models together:\n\njulia> q_rate = ZCBYield([0.01,0.02,0.03]);\n\njulia> q_spread = ZCBYield([0.01,0.01,0.01]);\n\njulia> m_rate = fit(Spline.Linear(),q_rate,Fit.Bootstrap());⠀           \n\njulia> m_spread = fit(Spline.Linear(),q_spread,Fit.Bootstrap());\n\njulia> forward(m_spread + m_rate,0,1)\nRate{Float64, Continuous}(0.01980262729617973, Continuous())\n\njulia> forward(m_spread + m_rate,0,1) |> Periodic(1)\nRate{Float64, Periodic}(0.020000000000000018, Periodic(1))\n\njulia> discount(m_spread + m_rate,0,3)\n0.8889963586709149\n\njulia> discount(0.04,3)\n0.8889963586709148\n\nwarning: Caution with Spreads\nIt is fairly common to see spreads and rates provided separately where both are quoted in par convention. For example, US Treasury par rates with the associated par risk spreads. Because par rates are dependent on the amount and path of rates preceeding the given tenor, it is not valid to construct a \"spread curve\" with par rates and then use it in composition with a \"rate curve\".That is, while the zero rates and spreads in the preceeding example allow for additive or subtractive composition, it is not the case for par rates and spreads. Note the different discount factors produced:q_rate = ParYield([0.01,0.02,0.03]);\nq_spread = ParYield([0.01,0.01,0.01]);\nq_yield = ParYield([0.02,0.03,0.04]);\n\nm_rate = fit(Spline.Linear(),q_rate,Fit.Bootstrap());         \nm_spread = fit(Spline.Linear(),q_spread,Fit.Bootstrap());\nm_yield = fit(Spline.Linear(),q_yield,Fit.Bootstrap());\n\n# The curves are different!\ndiscount(m_spread + m_rate,3)\n# 0.8889963586709149\n\ndiscount(m_yield,3)\n# 0.8864366955434709","category":"section"},{"location":"models/#Creating-New-Yield-Models","page":"Models, Valuation, and Fitting","title":"Creating New Yield Models","text":"See the FinanceModels.jl Guide for an example of creating a model from scratch. Some additional aspects to note:\n\nThe only method that must be defined to calculate the FinanceCore.present_value of something is FinanceCore.discount. Other methods will be inferred.\nOther methods that are imputed by default, but can be extended include: FinanceCore.accumulation, FinanceModels.forward, FinanceModels.par, FinanceModels.zero, and FinanceModels.rate.","category":"section"},{"location":"models/#Equity-and-Volatility-Models","page":"Models, Valuation, and Fitting","title":"Equity and Volatility Models","text":"","category":"section"},{"location":"models/#Available-Models-Option-Valuation","page":"Models, Valuation, and Fitting","title":"Available Models - Option Valuation","text":"FinanceModels.Equity.BlackScholesMerton","category":"section"},{"location":"models/#Available-Models-Volatility","page":"Models, Valuation, and Fitting","title":"Available Models - Volatility","text":"FinanceModels.Volatility.Constant","category":"section"},{"location":"models/#Creating-new-Volatility-Models","page":"Models, Valuation, and Fitting","title":"Creating new Volatility Models","text":"A volatility model must extend volatility(vol::Volatility.MyNewModel, strike_ratio, time_to_maturity).","category":"section"},{"location":"API/Yield/#FinanceModels.Yield-API-Reference","page":"Yield","title":"FinanceModels.Yield API Reference","text":"Modules = [FinanceModels.Yield]","category":"section"},{"location":"API/Yield/#Exported-API","page":"Yield","title":"Exported API","text":"","category":"section"},{"location":"API/Yield/#Unexported-API","page":"Yield","title":"Unexported API","text":"Please open an issue if you encounter any issues or confusion with the package.","category":"section"},{"location":"API/Yield/#Base.zero-Union{Tuple{YC}, Tuple{YC, Any}} where YC<:FinanceModels.Yield.AbstractYieldModel","page":"Yield","title":"Base.zero","text":"zero(curve,time)\n\nReturn the zero rate for the curve at the given time.\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#FinanceCore.discount-Union{Tuple{T}, Tuple{T, Any, Any}} where T<:FinanceModels.Yield.AbstractYieldModel","page":"Yield","title":"FinanceCore.discount","text":"discount(yc, to)\ndiscount(yc, from,to)\n\nThe discount factor for the yield curve yc for times from through to.\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#FinanceCore.forward-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T<:FinanceModels.Yield.AbstractYieldModel","page":"Yield","title":"FinanceCore.forward","text":"forward(yc, from, to)˚\n\nThe forward Rate implied by the yield curve yc between times from and to.\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#FinanceModels.Yield.par-Tuple{Any, Any}","page":"Yield","title":"FinanceModels.Yield.par","text":"par(curve,time;frequency=2)\n\nCalculate the par yield for maturity time for the given curve and frequency. Returns a Rate object with periodicity corresponding to the frequency. The exception to this is if time is less than what the payments allowed by frequency (e.g. a time 0.5 but with frequency 1) will effectively assume frequency equal to 1 over time.\n\nExamples\n\njulia> c = Yields.Constant(0.04);\n\njulia> Yields.par(c,4)\nYields.Rate{Float64, Yields.Periodic}(0.03960780543711406, Yields.Periodic(2))\n\njulia> Yields.par(c,4;frequency=1)\nYields.Rate{Float64, Yields.Periodic}(0.040000000000000036, Yields.Periodic(1))\n\njulia> Yields.par(c,0.6;frequency=4)\nYields.Rate{Float64, Yields.Periodic}(0.039413626195875295, Yields.Periodic(4))\n\njulia> Yields.par(c,0.2;frequency=4)\nYields.Rate{Float64, Yields.Periodic}(0.039374942589460726, Yields.Periodic(5))\n\njulia> Yields.par(c,2.5)\nYields.Rate{Float64, Yields.Periodic}(0.03960780543711406, Yields.Periodic(2))\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#FinanceModels.Yield.CompositeYield","page":"Yield","title":"FinanceModels.Yield.CompositeYield","text":"CompositeYield(curve1,curve2,operation)\n\nCreates a datastructure that will perform the given operation after independently calculating the effects of the two curves.  Can only be created via the public API by using the +, -, *, and / operatations on AbstractYield objects.\n\nAs this is double the normal operations when performing calculations, if you are using the curve in performance critical locations, you should consider transforming the inputs and  constructing a single curve object ahead of time.\n\nCurves can be added or subtracted together, but note that this is not always the same thing as adding or subtracting spreads with rates. If spreads and base rates are expressed as zero rates, then the curve addition/subtraction has the same effect as re-fitting the yield model with the rate+spread inputs added together first. Non-zero rates (e.g. par rates) do not have this same property. Zero-coupon rates have a direct, linear relationship with the underlying discount factors. Par-coupon rates have a complex, non-linear relationship with the underlying discount factors and so the curve addition/subtraction does not work the same way.\n\nExamples\n\nrates = [0.01, 0.01, 0.03, 0.05, 0.07, 0.16, 0.35, 0.92, 1.40, 1.74, 2.31, 2.41] ./ 100\nspreads = [0.01, 0.01, 0.03, 0.05, 0.07, 0.16, 0.35, 0.92, 1.40, 1.74, 2.31, 2.41] ./ 100\nmats = [1 / 12, 2 / 12, 3 / 12, 6 / 12, 1, 2, 3, 5, 7, 10, 20, 30]\n\n\n### Zero coupon rates/spreads\n\nq_rf_z = ZCBYield.(rates,mats)\nq_s_z = ZCBYield.(spreads,mats)\nq_y_z = ZCBYield.(rates + spreads,mats)\n\nc_rf_z = fit(Spline.Linear(),q_rf_z,Fit.Bootstrap())\nc_s_z = fit(Spline.Linear(),q_s_z,Fit.Bootstrap())\nc_y_z = fit(Spline.Linear(),q_y_z,Fit.Bootstrap())\n\n# adding curves when the spreads were zero spreads works\n@test discount(c_rf_z+c_s_z,20) ≈ discount(c_y_z,20)\n\n\n### Par coupon rates/spreads\n\nq_rf = CMTYield.(rates,mats)\nq_s = CMTYield.(spreads,mats)\nq_y = CMTYield.(rates + spreads,mats)\n\nc_rf = fit(Spline.Linear(),q_rf,Fit.Bootstrap())\nc_s = fit(Spline.Linear(),q_s,Fit.Bootstrap())\nc_y = fit(Spline.Linear(),q_y,Fit.Bootstrap())\n\n# adding curves when the spreads were par spreads does not work\n@test !(discount(c_rf+c_s,20) ≈ discount(c_y,20))\n\n\n\n\n\n","category":"type"},{"location":"API/Yield/#FinanceModels.Yield.Constant","page":"Yield","title":"FinanceModels.Yield.Constant","text":"Constant(rate)\n\nA yield curve representing a flat term structure. rate can be a Rate object or a Real object.\n\nIf fiting with the default FinanceModels.jl settings, the solver will attempt to fit a discount rate with the range of: -1.0 .. 1.0\n\n\n\n\n\n","category":"type"},{"location":"API/Yield/#FinanceModels.Yield.ForwardStarting","page":"Yield","title":"FinanceModels.Yield.ForwardStarting","text":"ForwardStarting(curve,forwardstart)\n\nRebase a curve so that discount/accumulation/etc. are re-based so that time zero from the new curves perspective is the given forwardstart time.\n\nExamples\n\njulia> zero = [5.0, 5.8, 6.4, 6.8] ./ 100\njulia> maturity = [0.5, 1.0, 1.5, 2.0]\njulia> curve = Yields.Zero(zero, maturity)\njulia> fwd = Yields.ForwardStarting(curve, 1.0)\n\njulia> FinanceCore.discount(curve,1,2)\n0.9275624570410582\n\njulia> FinanceCore.discount(fwd,1) # `curve` has effectively been reindexed to `1.0`\n0.9275624570410582\n\nExtended Help\n\nWhile ForwardStarting could be nested so that, e.g. the third period's curve is the one-period forward of the second period's curve, it will be more efficient to reuse the initial curve from a runtime and compiler perspective.\n\nForwardStarting is not used to construct a curve based on forward rates. \n\n\n\n\n\n","category":"type"},{"location":"API/Yield/#FinanceModels.Yield.MonotoneConvex","page":"Yield","title":"FinanceModels.Yield.MonotoneConvex","text":"MonotoneConvex(rates, times)\n\nA Monotone Convex yield curve model implementing the Hagan-West interpolation method.\n\nThis interpolation method guarantees:\n\nContinuous forward rates\nPositive forward rates (when input rates imply positive forwards)\nMonotone convex forward curves that match discrete forward rates at knot points\n\nThe implementation follows the Hagan-West method as described in WILMOTT magazine.\n\nExamples\n\nprices = [0.98, 0.955, 0.92, 0.88, 0.830]\ntimes = [1, 2, 3, 4, 5]\nrates = @. -log(prices) / times\n\nc = Yield.MonotoneConvex(rates, times)\nzero(c, 2.5)  # Get the zero rate at t=2.5\ndiscount(c, 2.5)  # Get the discount factor at t=2.5\n\nReferences\n\nHagan & West, \"Interpolation Methods for Curve Construction\", WILMOTT magazine\nDehlbom, \"Interpolation of the yield curve\" (http://uu.diva-portal.org/smash/get/diva2:1477828/FULLTEXT01.pdf)\n\n\n\n\n\n","category":"type"},{"location":"API/Yield/#FinanceModels.Yield.NelsonSiegel","page":"Yield","title":"FinanceModels.Yield.NelsonSiegel","text":"NelsonSiegel(β₀, β₁, β₂, τ₁)\nNelsonSiegel(τ₁=1.0) # used in fitting\n\nA Nelson-Siegel yield curve model  Parameters of Nelson and Siegel (1987) parametric model, along with default parameter ranges used in the fitting:\n\nβ₀ represents a long-term interest rate: -10.0 .. 10.0\nβ₁ represents a time-decay component: -10.0 .. 10.0\nβ₂ represents a hump: -10.0 .. 10.0\nτ₁ controls the location of the hump: 0.0 .. 100.0\n\nExamples\n\njulia> β₀, β₁, β₂, τ₁ = 0.6, -1.2, -1.9, 3.0\njulia> nsm = Yields.NelsonSiegel.(β₀, β₁, β₂, τ₁)\n\n# Extended Help\n\nNelsonSiegel has generally been replaced by NelsonSiegelSvensson, which is a more flexible model.\n\n## References\n- https://onriskandreturn.com/2019/12/01/nelson-siegel-yield-curve-model/\n- https://www.bis.org/publ/bppdf/bispap25.pdf\n\n\n\n\n\n\n","category":"type"},{"location":"API/Yield/#FinanceModels.Yield.NelsonSiegelSvensson","page":"Yield","title":"FinanceModels.Yield.NelsonSiegelSvensson","text":"NelsonSiegelSvensson(τ₁, τ₂, β₀, β₁, β₂, β₃)\nNelsonSiegelSvensson(τ₁=1.0, τ₂=1.0)\n\nReturn the NelsonSiegelSvensson yield curve. The rates should be continuous zero spot rates. If rates are not Rates, then they will be interpreted as Continuous Rates.\n\nParameters of Svensson (1994) parametric model, along with the default parameter bounds used in the fit routine:\n\nτ₁ controls the location of the hump: 0.0 .. 100.0\nτ₁ controls the location of the second hump: 0.0 .. 100.0\nβ₀ represents a long-term interest rate: -10.0 .. 10.0\nβ₁ represents a time-decay component: -10.0 .. 10.0\nβ₂ represents a hump: -10.0 .. 10.0\nβ₃ represents a second hump: -10.0 .. 10.0\n\nExamples\n\njulia> β₀, β₁, β₂, β₃, τ₁, τ₂ = 0.6, -1.2, -2.1, 3.0, 1.5\njulia> nssm = NelsonSiegelSvensson.NelsonSiegelSvensson.(β₀, β₁, β₂, β₃, τ₁, τ₂)\n\n# Extended Help\n\nNelson-Siegel-Svensson Pros:\n\n- Simplicity: With only six parameters, the model is quite parsimonious and easy to estimate. It's also easier to interpret and communicate than more complex models.\n- Economic Interpretability: Each of the model's components can be given an economic interpretation, with parameters representing long term rate, short term rate, the rates of decay towards the long term rate, and humps in the yield curve.\n\nNelson-Siegel-Svensson Cons:\n\n- Unusual Curves: NSS makes some assumptions about the shape of the yield curve (e.g. generally has a hump in short to medium term maturities). It might not be the best choice for fitting unusual curves.\n- Arbitrage Opportunities: The NSS model does not guarantee absence of arbitrage opportunities. More sophisticated models, like the ones based on no-arbitrage conditions, might provide better pricing accuracy in some contexts.\n- Sensitivity: Similar inputs may produce different parameters due to the highly convex, non-linear region to solve for the parameters. Entities like the ECB will partially mitigate this by using the prior business day's parameters as the starting point for the current day's yield curve.\n\n## References\n- https://onriskandreturn.com/2019/12/01/nelson-siegel-yield-curve-model/\n- https://www.bis.org/publ/bppdf/bispap25.pdf\n\n\n\n\n\n\n","category":"type"},{"location":"API/Yield/#FinanceModels.Yield.SmithWilson","page":"Yield","title":"FinanceModels.Yield.SmithWilson","text":"Yield.SmithWilson(u, qb; ufr=ufr, α=α)\nYield.SmithWilson(;ufr=ufr, α=α)\n\nCreate a yield curve object that implements the Smith-Wilson interpolation/extrapolation scheme.\n\nTo calibrate a curve, you generally want to construct the object without the u and qb arguments and call fit in conjunction with Quotes (fit requires no third parameter for SmithWilson curves). See Examples for what this looks like.  Positional arguments to construct a curve:\n\nA curve can be with u is the timepoints coming from the calibration, and qb is the internal parameterization of the curve that ensures that the calibration is correct. Users may prefer the other constructors but this mathematical constructor is also available.\n\nRequired keyword arguments:\n\nufr is the Ultimate Forward Rate, the forward interest rate to which the yield curve tends, in continuous compounding convention. \nα is the parameter that governs the speed of convergence towards the Ultimate Forward Rate. It can be typed with \\alpha[TAB]\n\nExamples\n\ntimes = [1.0, 2.5, 5.6]\nprices = [0.9, 0.7, 0.5]\nqs = ZCBPrice.(prices, times)\n\nufr = 0.03\nα = 0.1\n\nmodel = fit(Yield.SmithWilson(ufr=ufr, α=α), qs)\n\nExtended Help\n\nReferences\n\nSmith-Wilson Yields Curves\nA Technical Note on the Smith-Wilson Method\n\n\n\n\n\n","category":"type"},{"location":"API/Yield/#FinanceModels.Yield.ZeroRateCurve","page":"Yield","title":"FinanceModels.Yield.ZeroRateCurve","text":"ZeroRateCurve(rates, tenors, [spline])\nZeroRateCurve(curve::AbstractYieldModel, tenors; spline=Spline.MonotoneConvex())\n\nA yield curve defined by continuously-compounded zero rates at specified tenors, with interpolation between tenors via the existing Spline infrastructure.\n\nThe spline argument is a Spline.SplineCurve object (e.g. Spline.MonotoneConvex(), Spline.PCHIP(), Spline.Linear(), Spline.Cubic()). Defaults to Spline.MonotoneConvex().\n\nThe curve stores the raw rates vector, making it compatible with ForwardDiff: construct ZeroRateCurve(dual_rates, tenors, spline) inside an AD closure and the interpolation will propagate dual numbers.\n\nConstructing from another yield model\n\nThe second form samples zero rates from any AbstractYieldModel (e.g. Yield.Constant, Yield.NelsonSiegel, a fitted spline curve, etc.) at the specified tenors, producing a ZeroRateCurve suitable for key rate analysis with ActuaryUtilities.jl. All tenors must be positive (t > 0).\n\nExamples\n\nusing FinanceModels\n\nrates = [0.02, 0.03, 0.035, 0.04]\ntenors = [1.0, 2.0, 5.0, 10.0]\n\nzrc = ZeroRateCurve(rates, tenors)                              # default: MonotoneConvex\nzrc_pchip = ZeroRateCurve(rates, tenors, Spline.PCHIP())        # PCHIP\nzrc_lin = ZeroRateCurve(rates, tenors, Spline.Linear())          # linear\nzrc_cubic = ZeroRateCurve(rates, tenors, Spline.Cubic())         # cubic\n\ndiscount(zrc, 1.0)   # exp(-0.02 * 1.0)\ndiscount(zrc, 3.5)   # interpolated rate at t=3.5\nzero(zrc, 5.0)       # Continuous(0.035)\n\n# From a NelsonSiegel model:\nns = Yield.NelsonSiegel(1.0, 0.04, -0.02, 0.01)\nzrc_ns = ZeroRateCurve(ns, [1.0, 2.0, 5.0, 10.0, 20.0])\n\nPerformance note\n\ndiscount reconstructs the interpolation model on each call for AD compatibility (dual numbers must flow through the interpolation). For non-AD usage where discount is called many times on the same curve, construct Yield.build_model(zrc.spline, zrc.tenors, zrc.rates) once and use that instead. The AD pathway in ActuaryUtilities builds the model once per gradient step, avoiding this per-call overhead.\n\nForward curve smoothness\n\nThe default Spline.MonotoneConvex() guarantees positive continuous forward rates and produces C1-smooth forward curves (Hagan & West, 2006). For C2 smoothness, use Spline.Cubic(). Spline.Linear() produces kinks in the forward curve at tenor points.\n\n\n\n\n\n","category":"type"},{"location":"API/Yield/#Base.:*-Tuple{FinanceModels.Yield.AbstractYieldModel, FinanceModels.Yield.AbstractYieldModel}","page":"Yield","title":"Base.:*","text":"Yields.AbstractYieldModel * Yields.AbstractYieldModel\n\nThe multiplication of two yields will create a CompositeYield. For rate, discount, and accumulation purposes the spot rates of the two curves will be added together. This can be useful, for example, if you wanted to after-tax a yield.\n\nExamples\n\njulia> m = Yields.Constant(0.01) * 0.79;\n\njulia> accumulation(m,1)\n1.0079\n\njulia> accumulation(.01*.79,1)\n1.0079\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#Base.:+-Tuple{FinanceModels.Yield.AbstractYieldModel, FinanceModels.Yield.AbstractYieldModel}","page":"Yield","title":"Base.:+","text":"Yields.AbstractYieldModel + Yields.AbstractYieldModel\n\nThe addition of two yields will create a CompositeYield. For rate, discount, and accumulation purposes the spot rates of the two curves will be added together.\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#Base.:--Tuple{FinanceModels.Yield.AbstractYieldModel, FinanceModels.Yield.AbstractYieldModel}","page":"Yield","title":"Base.:-","text":"Yields.AbstractYieldModel - Yields.AbstractYieldModel\n\nThe subtraction of two yields will create a CompositeYield. For rate, discount, and accumulation purposes the spot rates of the second curves will be subtracted from the first.\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#Base.:/-Tuple{FinanceModels.Yield.AbstractYieldModel, FinanceModels.Yield.AbstractYieldModel}","page":"Yield","title":"Base.:/","text":"Yields.AbstractYieldModel / Yields.AbstractYieldModel\n\nThe division of two yields will create a CompositeYield. For rate, discount, and accumulation purposes the spot rates of the two curves will have the first divided by the second. This can be useful, for example, if you wanted to gross-up a yield to be pre-tax.\n\nExamples\n\njulia> m = Yields.Constant(0.01) / 0.79;\n\njulia> accumulation(d,1)\n1.0126582278481013\n\njulia> accumulation(.01/.79,1)\n1.0126582278481013\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#FinanceCore.accumulation-Tuple{FinanceModels.Yield.AbstractYieldModel, Any}","page":"Yield","title":"FinanceCore.accumulation","text":"accumulation(yc, from, to)\n\nThe accumulation factor for the yield curve yc for times from through to.\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#FinanceModels.Yield.H-Union{Tuple{T}, Tuple{Any, T, T}} where T","page":"Yield","title":"FinanceModels.Yield.H","text":"H(α, t1, t2)\n\nThe Smith-Wilson H function implemented in a faster way.\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#FinanceModels.Yield.H_ordered-Tuple{Any, Any, Any}","page":"Yield","title":"FinanceModels.Yield.H_ordered","text":"H_ordered(α, t_min, t_max)\n\nThe Smith-Wilson H function with ordered arguments (for better performance than using min and max).\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#FinanceModels.Yield.__i_time-Tuple{Any, Any}","page":"Yield","title":"FinanceModels.Yield.__i_time","text":"returns the index associated with the time t, an initial rate vector, and a time vector\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#FinanceModels.Yield.__monotone_convex_fs-Tuple{Any, Any}","page":"Yield","title":"FinanceModels.Yield.__monotone_convex_fs","text":"returns a pair of vectors (f and fᵈ) used in Monotone Convex Yield Curve fitting\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#FinanceModels.Yield.build_model-Tuple{FinanceModels.Spline.SplineCurve, Any, Any}","page":"Yield","title":"FinanceModels.Yield.build_model","text":"build_model(spline, tenors, rates)\n\nBuild a yield model from a SplineCurve type descriptor, tenor times, and rates. Returns an AbstractYieldModel that supports discount() and callable (t) syntax.\n\nUsed by ZeroRateCurve and the AD pathway in ActuaryUtilities to construct the interpolation model efficiently (once per gradient step rather than per discount call).\n\n\n\n\n\n","category":"method"},{"location":"API/Yield/#FinanceModels.Yield.g_rate-NTuple{4, Any}","page":"Yield","title":"FinanceModels.Yield.g_rate","text":"g_rate(x, f⁻, f, fᵈ)\n\nCompute the integrated deviation G(x) = ∫₀ˣ g(u) du, which captures how the instantaneous forward curve deviates from the discrete forward across an interval. This quantity feeds into the zero-rate relation r(t) = fᵈ + (Δt / t) ⋅ G(x) used by the Hagan-West construction.\n\n\n\n\n\n","category":"method"},{"location":"interpolation/#Interpolation-Methods-for-ZeroRateCurve","page":"Interpolation Methods","title":"Interpolation Methods for ZeroRateCurve","text":"ZeroRateCurve accepts an optional third argument specifying the interpolation method. The choice of interpolation affects forward curve smoothness, key rate duration locality, and performance when used with automatic differentiation (e.g. via sensitivities() in ActuaryUtilities.jl).","category":"section"},{"location":"interpolation/#Available-Methods","page":"Interpolation Methods","title":"Available Methods","text":"Method Smoothness Locality Description\nSpline.MonotoneConvex() C1 (smooth) Best among smooth Default. Finance-aware. Positive forwards, best KRD locality, fastest AD.\nSpline.PCHIP() C1 (smooth) Local Monotonicity-preserving, local. Good general-purpose alternative.\nSpline.Akima() C1 (smooth) Local Local, resistant to outlier oscillation.\nSpline.Linear() C0 (kinked) Perfectly local Simplest. Kinks in forward curve at tenor points.\nSpline.Cubic() C2 (smoothest) Global Smoothest, but bumping one rate affects the entire curve.\nSpline.BSpline(n) Varies Mostly local nth-order B-spline.\n\nusing FinanceModels\n\nrates = [0.02, 0.03, 0.035, 0.04, 0.045]\ntenors = [1.0, 2.0, 5.0, 10.0, 20.0]\n\nzrc = ZeroRateCurve(rates, tenors)                              # default: MonotoneConvex\nzrc_pchip = ZeroRateCurve(rates, tenors, Spline.PCHIP())        # PCHIP\nzrc_lin = ZeroRateCurve(rates, tenors, Spline.Linear())          # linear\nzrc_cub = ZeroRateCurve(rates, tenors, Spline.Cubic())           # cubic B-spline\nzrc_aki = ZeroRateCurve(rates, tenors, Spline.Akima())           # Akima","category":"section"},{"location":"interpolation/#Key-Tradeoffs","page":"Interpolation Methods","title":"Key Tradeoffs","text":"","category":"section"},{"location":"interpolation/#Forward-Curve-Smoothness","page":"Interpolation Methods","title":"Forward Curve Smoothness","text":"The instantaneous forward rate f(t) = r(t) + t · r'(t) should be smooth for stochastic models that differentiate the forward curve (e.g. Hull-White θ(t) calibration). Linear interpolation creates discontinuous jumps in f(t) at tenor points, while PCHIP, MonotoneConvex, Akima, and CubicSpline produce smooth forward curves.\n\nThe following code evaluates forward rates near the 2yr and 5yr tenor points to illustrate the difference:\n\nusing FinanceModels\nusing FinanceCore: discount\nDI = FinanceModels.DataInterpolations\n\nrates = [0.02, 0.025, 0.03, 0.035, 0.04]\ntenors = [1.0, 2.0, 5.0, 10.0, 20.0]\n\neval_points = [1.9, 1.99, 2.0, 2.01, 2.1, 4.9, 4.99, 5.0, 5.01, 5.1]\n\n# Helper: numerical forward rate from a zero-rate interpolator\nfunction fwd_from_interp(interp, t)\n    r = interp(t); h = 1e-6\n    dr = (interp(t+h) - interp(t-h)) / (2h)\n    r + t * dr\nend\n\n# Helper: numerical forward rate from a discount function\nfunction fwd_from_discount(model, t)\n    h = 1e-6\n    -log(discount(model, t+h) / discount(model, t-h)) / (2h)\nend\n\nfor (name, make_fwd) in [\n    (\"Linear\", (r, t) -> begin\n        interp = DI.BSplineInterpolation(r, t, 1, :Uniform, :Average;\n            extrapolation=DI.ExtrapolationType.Extension)\n        pt -> fwd_from_interp(interp, pt)\n    end),\n    (\"PCHIP\", (r, t) -> begin\n        interp = DI.PCHIPInterpolation(r, t;\n            extrapolation=DI.ExtrapolationType.Extension)\n        pt -> fwd_from_interp(interp, pt)\n    end),\n    (\"MonotoneConvex\", (r, t) -> begin\n        mc = FinanceModels.Yield.MonotoneConvex(collect(r), collect(float.(t)))\n        pt -> fwd_from_discount(mc, pt)\n    end),\n    (\"Akima\", (r, t) -> begin\n        interp = DI.AkimaInterpolation(r, t;\n            extrapolation=DI.ExtrapolationType.Extension)\n        pt -> fwd_from_interp(interp, pt)\n    end),\n    (\"CubicSpline\", (r, t) -> begin\n        interp = DI.CubicSpline(r, t;\n            extrapolation=DI.ExtrapolationType.Extension)\n        pt -> fwd_from_interp(interp, pt)\n    end),\n]\n    fwd = make_fwd(rates, tenors)\n    println(\"\\n--- $name: forward rate f(t) ---\")\n    for t in eval_points\n        println(\"  t=$(lpad(round(t, digits=2), 5)):  f=$(round(fwd(t)*100, digits=4))%\")\n    end\nend\n\nResults:\n\nMethod f(1.99) f(2.0) f(2.01) Jump? f(4.99) f(5.0) f(5.01) Jump?\nLinear 3.49% 3.17% 2.84% Yes 3.83% 3.67% 3.50% Yes\nPCHIP 3.05% 3.05% 3.05% No 3.63% 3.64% 3.64% No\nMonotoneConvex 3.08% 3.08% 3.09% No 3.58% 3.58% 3.59% No\nAkima 2.96% 2.94% 2.95% No 3.54% 3.54% 3.55% No\nCubicSpline 3.32% 3.33% 3.33% No 3.32% 3.32% 3.33% No\n\nMonotoneConvex additionally guarantees positive continuous forward rates when input rates imply positive forwards — a property unique to this method among those listed (Hagan & West, 2006).","category":"section"},{"location":"interpolation/#Key-Rate-Duration-Locality","page":"Interpolation Methods","title":"Key Rate Duration Locality","text":"When computing key rate durations (KRDs), bumping one zero rate should ideally affect only nearby discount factors. The table below shows ∂rate(t)/∂r₃ — the sensitivity of the interpolated rate at various times to a bump in the 5yr rate (rate index 3, with tenors at 1, 2, 5, 10, 20):\n\nusing FinanceModels\nusing FinanceModels: DataInterpolations as DI\nusing FinanceCore: discount\nusing ForwardDiff\n\nrates = [0.02, 0.03, 0.035, 0.04, 0.045]\ntenors = [1.0, 2.0, 5.0, 10.0, 20.0]\n\neval_points = [0.5, 1.0, 1.5, 2.0, 3.0, 5.0, 7.0, 10.0, 15.0, 20.0]\n\nfor (name, rate_at) in [\n    (\"Linear\", (r, t, pt) ->\n        DI.BSplineInterpolation(r, t, 1, :Uniform, :Average;\n            extrapolation=DI.ExtrapolationType.Extension)(pt)),\n    (\"PCHIP\", (r, t, pt) ->\n        DI.PCHIPInterpolation(r, t;\n            extrapolation=DI.ExtrapolationType.Extension)(pt)),\n    (\"MonotoneConvex\", (r, t, pt) -> begin\n        mc = FinanceModels.Yield.MonotoneConvex(collect(r), collect(float.(t)))\n        -log(discount(mc, pt)) / pt\n    end),\n    (\"Akima\", (r, t, pt) ->\n        DI.AkimaInterpolation(r, t;\n            extrapolation=DI.ExtrapolationType.Extension)(pt)),\n    (\"CubicSpline\", (r, t, pt) ->\n        DI.CubicSpline(r, t;\n            extrapolation=DI.ExtrapolationType.Extension)(pt)),\n]\n    println(\"\\n--- $name: ∂rate(t)/∂r₃  (bump at 5yr) ---\")\n    for pt in eval_points\n        g = ForwardDiff.gradient(r -> rate_at(r, tenors, pt), rates)\n        println(\"  t=$(lpad(pt,4)):  $(round(g[3], digits=4))\")\n    end\nend\n\nResults (sensitivity of interpolated rate to 5yr rate bump):\n\nt Linear PCHIP MonotoneConvex Akima CubicSpline\n0.5 0.0 -0.10 0.0 -0.11 0.02\n1.0 0.0 0.0 0.0 0.0 0.0\n1.5 0.0 -0.08 -0.02 -0.12 -0.02\n2.0 0.0 0.0 0.0 0.0 0.0\n3.0 0.33 0.50 0.45 0.65 0.26\n5.0 1.0 1.0 1.0 1.0 1.0\n7.0 0.6 0.64 0.53 0.63 0.95\n10.0 0.0 0.0 0.0 0.0 0.0\n15.0 0.0 -0.23 -0.08 -0.42 -0.56\n20.0 0.0 0.0 0.0 0.0 0.0\n\nLinear is perfectly local — zero sensitivity outside adjacent intervals. MonotoneConvex has the best locality among smooth methods (only -0.08 at t=15 vs -0.23 for PCHIP, -0.42 for Akima, and -0.56 for CubicSpline). All smooth methods have zero sensitivity at the exact tenor points (t=1, 2, 10, 20) because the interpolation passes through those data points exactly.","category":"section"},{"location":"interpolation/#Performance","page":"Interpolation Methods","title":"Performance","text":"All methods are fast enough for interactive use. The table below shows end-to-end sensitivities() timing from ActuaryUtilities.jl, which includes gradient + Hessian + result packaging in a single call:\n\nusing ActuaryUtilities, FinanceModels, Printf\n\nrates5 = [0.02, 0.025, 0.03, 0.035, 0.04]\ntenors5 = [1.0, 2.0, 5.0, 10.0, 20.0]\ncfs5 = [5.0, 5.0, 5.0, 5.0, 105.0]\n\nfor (name, spline) in [\n    (\"PCHIP\", Spline.PCHIP()),\n    (\"MonotoneConvex\", Spline.MonotoneConvex()),\n    (\"Linear\", Spline.Linear()),\n    (\"Akima\", Spline.Akima()),\n    (\"Cubic\", Spline.Cubic()),\n]\n    zrc = ZeroRateCurve(rates5, tenors5, spline)\n    sensitivities(zrc, cfs5, tenors5)  # warmup\n\n    N = 5_000\n    t0 = time_ns()\n    for _ in 1:N; sensitivities(zrc, cfs5, tenors5); end\n    elapsed = (time_ns() - t0) / 1e3 / N\n    @printf(\"  %-20s  %7.1f μs\\n\", name, elapsed)\nend\n\nsensitivities() (5 tenors):\n\nMethod Time\nMonotoneConvex 5.9 μs\nLinear 5.3 μs\nPCHIP 10.1 μs\nCubic 10.1 μs\nAkima 15.2 μs\n\nsensitivities() (12 tenors):\n\nMethod Time\nMonotoneConvex 40.3 μs\nPCHIP 69.4 μs\nAkima 102.1 μs\nCubic 112.8 μs\nLinear 131.2 μs\n\nMonotoneConvex is fastest at both sizes. At 12 tenors the advantage is substantial — roughly 2x faster than PCHIP and 3x faster than Linear.","category":"section"},{"location":"interpolation/#Recommendations","page":"Interpolation Methods","title":"Recommendations","text":"Spline.MonotoneConvex() (default): Best for finance applications. Guarantees positive continuous forward rates, best KRD locality among smooth methods (-0.08 vs -0.23 for PCHIP), and fastest AD performance. Based on Hagan & West (2006).\nSpline.PCHIP(): Good general-purpose alternative. Smooth forward curves, local sensitivity, monotonicity-preserving.\nSpline.Linear(): Use when you need perfectly localized KRDs (zero sensitivity outside adjacent intervals) and don't need smooth forwards.\nSpline.Akima(): Alternative to PCHIP with different behavior near inflection points. Slightly more non-local leakage than PCHIP.\nSpline.Cubic(): Use when curve smoothness matters most and you accept non-local KRD effects (e.g. negative duration at distant tenors from a local rate bump).","category":"section"},{"location":"API/Bond/#FinanceModels.Bond-API-Reference","page":"Bond","title":"FinanceModels.Bond API Reference","text":"Modules = [FinanceModels.Bond]","category":"section"},{"location":"API/Bond/#Exported-API","page":"Bond","title":"Exported API","text":"","category":"section"},{"location":"API/Bond/#Unexported-API","page":"Bond","title":"Unexported API","text":"Please open an issue if you encounter any issues or confusion with the package.","category":"section"},{"location":"API/Bond/#FinanceModels.Bond","page":"Bond","title":"FinanceModels.Bond","text":"The Bond module provide a number of fixed-income contracts and related methods.\n\n\n\n\n\n","category":"module"},{"location":"API/Bond/#FinanceModels.Bond.CMTYield-Tuple{Any, Any}","page":"Bond","title":"FinanceModels.Bond.CMTYield","text":"CMTYield(yield,maturity)\nCMTYield(yield::Vector)\n\nReturns a Quote for the correpsonding bond implied by the given bond equivalent yield, and assumes that instruments <= one year maturity` pay no coupons and that the rest pay semi-annual.\n\nUse broadcasting to create a set of quotes given a collection of FinanceModels and maturities, e.g. CMTYield.(FinanceModels,maturities).\n\nSee also FinanceCore.Quote, Bond.Fixed\n\nExamples\n\njulia> CMTYield(0.05,10)\nQuote{Float64, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}}(1.0, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}(0.05, Periodic(2), 10))\n\n\n\n\n\n","category":"method"},{"location":"API/Bond/#FinanceModels.Bond.ParSwapYield-Tuple{Any, Any}","page":"Bond","title":"FinanceModels.Bond.ParSwapYield","text":"ParSwapYield(yield, maturity; frequency=Periodic(4))\n\nSame as ParYield, except the frequency is four times per period by default.\n\n\n\n\n\n","category":"method"},{"location":"API/Bond/#FinanceModels.Bond.ParYield-Tuple{Any, Any}","page":"Bond","title":"FinanceModels.Bond.ParYield","text":"ParYield(yield, maturity; frequency=Periodic(2))\nParYield(yield::Rate{N,Periodic}, maturity; frequency=Periodic(2))\n\nCreate a Quote representing a par bond with the given yield and maturity. The default coupon frequency is semi-annual (Periodic(2)). If a Rate with Periodic compounding is passed, the frequency is inferred from the rate.\n\nWhen maturity ≤ 1/frequency (i.e. the bond matures before the first regular coupon date), a stub-period par bond is created. The coupon is compound-accrued so that (1 + stub_coupon) * discount(yield, maturity) = 1.0, preserving par pricing. Otherwise, a standard par coupon bond Quote with price = 1.0 is returned.\n\nUse broadcasting to create a set of quotes: ParYield.(yields, maturities).\n\nExamples\n\njulia> ParYield(0.05, 10)\nQuote{Float64, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}}(1.0, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}(0.05, Periodic(2), 10))\n\njulia> ParYield(Periodic(0.04, 2), 1//4)  # sub-period maturity → stub-period par bond\nQuote{Float64, FinanceModels.Bond.Fixed{…}}(1.0, FinanceModels.Bond.Fixed{…}(…, Periodic(2), 1//4))\n\n\n\n\n\n","category":"method"},{"location":"API/Bond/#FinanceModels.Bond.ZCBPrice-Tuple{Any, Any}","page":"Bond","title":"FinanceModels.Bond.ZCBPrice","text":"ZCBPrice(discount,maturity)\nZCBPrice(yield::Vector)\n\nTakes spot/zero discount factors and returns a Quote for the cashflow occuring at the given maturity.\n\nUse broadcasting to create a set of quotes given a collection of prices and maturities, e.g. ZCBPrice.(FinanceModels,maturities).\n\nSee also ZCBYield\n\nExamples\n\n\njulia> ZCBPrice(0.5,10)\nQuote{Float64, Cashflow{Float64, Int64}}(0.5, Cashflow{Float64, Int64}(1.0, 10))\n\njulia> ZCBPrice([0.9,0.8,0.75])\n3-element Vector{Quote{Float64, Cashflow{Float64, Int64}}}:\n Quote{Float64, Cashflow{Float64, Int64}}(0.9, Cashflow{Float64, Int64}(1.0, 1))\n Quote{Float64, Cashflow{Float64, Int64}}(0.8, Cashflow{Float64, Int64}(1.0, 2))\n Quote{Float64, Cashflow{Float64, Int64}}(0.75, Cashflow{Float64, Int64}(1.0, 3))\n \n\n\n\n\n\n","category":"method"},{"location":"API/Bond/#FinanceModels.Bond.ZCBYield-Tuple{Any, Any}","page":"Bond","title":"FinanceModels.Bond.ZCBYield","text":"ZCBYield(yield,maturity)\nZCBYield(yield::Vector)\n\nReturns a Quote for the cashflow occuring at the given maturity and the quoted value is derived from the given yield.\n\nTakes zero (sometimes called \"spot\") rates. Assumes annual effective compounding (Periodic(1)) unless given aRate` with a different compounding frequency.\n\nUse broadcasting to create a set of quotes given a collection of FinanceModels and maturities, e.g. ZCBYield.(FinanceModels,maturities).\n\nSee also ZCBPrice\n\nExamples\n\njulia> ZCBYield(0.05,30)\nQuote{Float64, Cashflow{Float64, Int64}}(0.23137744865585788, Cashflow{Float64, Int64}(1.0, 30))\n\njulia> ZCBYield(Periodic(0.05,1),30)\nQuote{Float64, Cashflow{Float64, Int64}}(0.23137744865585788, Cashflow{Float64, Int64}(1.0, 30))\n\njulia> ZCBYield(Continuous(0.05),30)\nQuote{Float64, Cashflow{Float64, Int64}}(0.22313016014842982, Cashflow{Float64, Int64}(1.0, 30))\n\njulia> ZCBYield([0.04,0.05,0.045])\n3-element Vector{Quote{Float64, Cashflow{Float64, Int64}}}:\n Quote{Float64, Cashflow{Float64, Int64}}(0.9615384615384615, Cashflow{Float64, Int64}(1.0, 1))\n Quote{Float64, Cashflow{Float64, Int64}}(0.9070294784580498, Cashflow{Float64, Int64}(1.0, 2))\n Quote{Float64, Cashflow{Float64, Int64}}(0.8762966040549094, Cashflow{Float64, Int64}(1.0, 3))\n\n\n\n\n\n","category":"method"},{"location":"API/Bond/#FinanceModels.Bond.Fixed","page":"Bond","title":"FinanceModels.Bond.Fixed","text":"Bond.Fixed(coupon_rate,frequency<:FinanceCore.Frequency,maturity)\n\nAn object representing a fixed coupon bond. coupon_rate / frequency is the actual payment amount.\n\nNote that there are a number of convienience constructors which return a Quote for a Bond.Fixed: \n\nParYield\nParSwapYield\nCMTYield\nOISYield\n\nSee also FinanceCore.Quote.\n\nExamples\n\njulia> Bond.Fixed(0.05,Periodic(2),3)\nFinanceModels.Bond.Fixed{Periodic, Float64, Int64}(0.05, Periodic(2), 3)\n\njulia> Bond.Fixed(0.05,Periodic(2),3) |> collect\n6-element Vector{Cashflow{Float64, Float64}}:\n Cashflow{Float64, Float64}(0.025, 0.5)\n Cashflow{Float64, Float64}(0.025, 1.0)\n Cashflow{Float64, Float64}(0.025, 1.5)\n Cashflow{Float64, Float64}(0.025, 2.0)\n Cashflow{Float64, Float64}(0.025, 2.5)\n Cashflow{Float64, Float64}(1.025, 3.0)\n\n\njulia> ParYield(0.05,10)\nQuote{Float64, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}}(1.0, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}(0.05, Periodic(2), 10))\n\n\n\n\n\n","category":"type"},{"location":"API/Bond/#FinanceModels.Bond.Floating","page":"Bond","title":"FinanceModels.Bond.Floating","text":"Bond.Floating(coupon_rate,frequency<:FinanceCore.Frequency,maturity,model_key)\n\nAn object representing a floating coupon bond. (coupon_rate + reference rate) / frequency is the actual payment amount, where the reference rate requires a Projection with a key/value pair where the key is the model_key argument and the value is the model which produces the reference rate.\n\nSee also FinanceCore.Quote.\n\nExamples\n\njulia> p = Projection(\n        Bond.Floating(0.02, Periodic(1), 3.0, \"SOFR\"),\n        Dict(\"SOFR\" => Yield.Constant(0.05)),  # note the key/value store used for the model in the projection\n        CashflowProjection(),\n    );\n\njulia> collect(p)\n3-element Vector{Cashflow{Float64, Float64}}:\n    Cashflow{Float64, Float64}(0.07000000000000005, 1.0)\n    Cashflow{Float64, Float64}(0.07000000000000005, 2.0)\n    Cashflow{Float64, Float64}(1.07, 3.0)\n\n\n\n\n\n","category":"type"},{"location":"API/Bond/#FinanceModels.Bond.ForwardYields","page":"Bond","title":"FinanceModels.Bond.ForwardYields","text":"ForwardYields(yields,times)\n\nReturns a vector of Quote corresponding to the yield at the given forward times. \n\nExamples\n\njulia> FinanceModels.Bond.ForwardYields([0.01,0.02],[1.,3.])\n2-element Vector{Quote{Float64, Cashflow{Float64, Float64}}}:\n Quote{Float64, Cashflow{Float64, Float64}}(0.9900990099009901, Cashflow{Float64, Float64}(1.0, 1.0))\n Quote{Float64, Cashflow{Float64, Float64}}(0.9423223345470445, Cashflow{Float64, Float64}(1.0, 3.0))\n\n\n\n\n\n","category":"function"},{"location":"API/Bond/#FinanceModels.Bond.OISYield-Tuple{Any, Any}","page":"Bond","title":"FinanceModels.Bond.OISYield","text":"OISYield(yield, maturity)\n\nReturns the implied Quote for the fixed bond implied by the given yield and maturity. Assumes that maturities less than or equal to 12 months are settled once (per Hull textbook, 4.7), otherwise quarterly and that the FinanceModels given are bond equivalent.\n\nUse broadcasting to create a set of quotes given a collection of FinanceModels and maturities, e.g. OISYield.(FinanceModels,maturities).\n\nSee also FinanceCore.Quote, Bond.Fixed\n\nExamples\n\njulia> OISYield(0.05,10)\nQuote{Float64, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}}(1.0, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}(0.05, Periodic(4), 10))\n\n\n\n\n\n","category":"method"},{"location":"API/Bond/#FinanceModels.Bond.coupon_times-Tuple{Any, Any}","page":"Bond","title":"FinanceModels.Bond.coupon_times","text":"coupon_times(maturity, frequency)\n\nGenerate coupon times for a bond with the given maturity and frequency.\n\nArguments\n\nmaturity::Real: The maturity of the bond.\nfrequency::Real: The coupon frequency of the bond.\n\nReturns\n\nAn array of coupon times for the bond.\n\nExamples\n\njulia-repl julia> Bond.coupon_times(10, 2) 0.5:0.5:10.0 julia> Bond.coupon_times(Bond.Fixed(0.05,Periodic(4),20)) 0.25:0.25:20.0`\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceModels/#FinanceModels-API-Reference","page":"FinanceModels","title":"FinanceModels API Reference","text":"Modules = [FinanceModels]","category":"section"},{"location":"API/FinanceModels/#Exported-API","page":"FinanceModels","title":"Exported API","text":"","category":"section"},{"location":"API/FinanceModels/#Unexported-API","page":"FinanceModels","title":"Unexported API","text":"Please open an issue if you encounter any issues or confusion with the package.","category":"section"},{"location":"API/FinanceModels/#FinanceModels.AbstractStochasticModel","page":"FinanceModels","title":"FinanceModels.AbstractStochasticModel","text":"AbstractStochasticModel <: Yield.AbstractYieldModel\n\nAbstract supertype for stochastic short-rate models.\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceModels/#FinanceModels.CashflowProjection","page":"FinanceModels","title":"FinanceModels.CashflowProjection","text":"CashflowProjection()\n\nA concrete subtype of ProjectionKind which is the projection which returns only a reducible collection of Cashflows. Use in conjunction with a Projection.\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceModels/#FinanceModels.CommonEquity","page":"FinanceModels","title":"FinanceModels.CommonEquity","text":"CommonEquity()\n\nA singleton type representing a unit stock.\n\nSee also: Option.\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceModels/#FinanceModels.Forward","page":"FinanceModels","title":"FinanceModels.Forward","text":"Forward(time,instrument)\n\nThe instrument is relative to the Forward time. e.g. if you have a Forward(1.0, Cashflow(1.0, 3.0)) then the instrument is a cashflow that pays 1.0 at time 4.0\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceModels/#FinanceModels.NullModel","page":"FinanceModels","title":"FinanceModels.NullModel","text":"NullModel()\n\nA singleton type representing a placeholder model for when you don't really need a model. For example: determining nominal cashflows for fixed income contract.\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceModels/#FinanceModels.Projection","page":"FinanceModels","title":"FinanceModels.Projection","text":"Projection(contract,model,kind)\n\nThe set of contracts and assumptions (model) to project the kind of output desired. Some assets require a projection in order to be valued (e.g. a floating rate bond).\n\nIf attempting to collect or otherwise reduce a contract (<:AbstractContract), by default it will get wrapped into a Projection(contract,NullModel(),CashflowProjection())\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceModels/#FinanceModels.RatePath","page":"FinanceModels","title":"FinanceModels.RatePath","text":"RatePath(interp)\n\nA simulated interest-rate path wrapped as an AbstractYieldModel. interp maps time t to the cumulative integral ∫₀ᵗ r(s) ds so that discount(path, t) = exp(-interp(t)).\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceModels/#FinanceCore.discount-Tuple{FinanceModels.ShortRate.CoxIngersollRoss, Any, Any, Any}","page":"FinanceModels","title":"FinanceCore.discount","text":"discount(m::ShortRate.CoxIngersollRoss, t, T, r_t)\n\nConditional zero-coupon bond price P(tT mid r(t) = r_t) under the CIR model. Since the model is time-homogeneous, P(tTr) = P(0 T-t  r).\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceModels/#FinanceCore.discount-Tuple{FinanceModels.ShortRate.HullWhite, Any, Any, Any}","page":"FinanceModels","title":"FinanceCore.discount","text":"discount(m::ShortRate.HullWhite, t, T, r_t)\n\nConditional zero-coupon bond price P(tT mid r(t) = r_t) under the Hull-White model. Unlike Vasicek/CIR, this depends on t and T separately (not just T-t) because the model is calibrated to an initial term structure.\n\nFormula (Brigo & Mercurio 2006, Proposition 3.2.2):\n\nln P(tT) = lnfracP(0T)P(0t) + B(tT) f(0t) - fracsigma^24a B(tT)^2 (1 - e^-2at) - B(tT) r_t\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceModels/#FinanceCore.discount-Tuple{FinanceModels.ShortRate.Vasicek, Any, Any, Any}","page":"FinanceModels","title":"FinanceCore.discount","text":"discount(m::ShortRate.Vasicek, t, T, r_t)\n\nConditional zero-coupon bond price P(tT mid r(t) = r_t) under the Vasicek model. Since the model is time-homogeneous, P(tTr) = P(0 T-t  r).\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceModels/#FinanceCore.internal_rate_of_return-Tuple{Quote}","page":"FinanceModels","title":"FinanceCore.internal_rate_of_return","text":"FinanceCore.internal_rate_of_return(q::Quote)\n\nReturn the internal rate of return (yield to maturity) implied by the quote's price and cashflows.\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceModels/#FinanceCore.present_value","page":"FinanceModels","title":"FinanceCore.present_value","text":"present_value(model,contract,current_time=0.0)\npresent_value(model,projection,current_time=0.0)\n\nReturn the value of the contract as corresponding with the valuation assumptions embedded in the model for the given contract or projection with CashflowProjection kind.\n\nExamples\n\nm = Equity.BlackScholesMerton(0.01, 0.02, 0.15)\n\na = Option.EuroCall(CommonEquity(), 1.0, 1.0)\n\npv(m, a) # ≈ 0.05410094201902403\n\n\n\n\n\n","category":"function"},{"location":"API/FinanceModels/#FinanceModels.InterestRateSwap-Tuple{Any, Any}","page":"FinanceModels","title":"FinanceModels.InterestRateSwap","text":"InterestRateSwap(curve, tenor; model_key=\"OIS\")\n\nA convenience method for creating an interest rate swap given a curve and a tenor via a Composite contract consisting of receiving a fixed bond and paying (i.e. the negative of) a floating bond.\n\nThe notional is a unit (1.0) amount and assumed to settle four times per period.\n\nA Projection, with an indexable model_key is still needed to project a swap. See examples below for what this looks like.\n\nExamples\n\n\njulia> curve = Yield.Constant(0.05);\n\njulia> swap = InterestRateSwap(curve,10);\n\njulia> Projection(swap,Dict(\"OIS\" => curve),CashflowProjection()) |> collect\n80-element Vector{Cashflow{Float64, Float64}}:\nCashflow{Float64, Float64}(0.012272234429039353, 0.25)\nCashflow{Float64, Float64}(0.012272234429039353, 0.5)\n⋮\nCashflow{Float64, Float64}(-0.012272234429039353, 9.75)\nCashflow{Float64, Float64}(-1.0122722344290391, 10.0)\n\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceModels/#FinanceModels.fit-Union{Tuple{F}, Tuple{Any, Any}, Tuple{Any, Any, F}} where F<:FinanceModels.Fit.Loss","page":"FinanceModels","title":"FinanceModels.fit","text":"fit(\n    model, \n    quotes, \n    method=Fit.Loss(x -> x^2);\n    variables=__default_optic(model), \n    optimizer=__default_optim(model)\n    )\n\nFit a model to a collection of quotes using a loss function and optimization method.\n\nArguments\n\nmodel: The initial model to fit, which is generally an instantiated but un-optimized model.\nquotes: A collection of quotes to fit the model to.\nmethod::F=Fit.Loss(x -> x^2): The loss function to use for fitting the model. Defaults to the squared loss function. \nmethod can also be Bootstrap(). If this is the case, model should be a spline such as Spline.Linear(), Spline.Cubic()...\nvariables=__default_optic(model): The variables to optimize over. This is a tuple of optic => interval pairs specifying which parameters of the model can vary. See extended help for more.\noptimizer=__default_optim(model): The optimization algorithm to use. The default optimization for a given model is LBFGS() from Optim.jl (via OptimizationOptimJL), a quasi-Newton method with automatic differentiation via ForwardDiff. See extended help for more on customizing the solver.\n\nThe optimization routine will then attempt to modify parameters of model to best fit the quoted prices of the contracts underlying the quotes by calling present_value(model,contract). The optimization will minimize the loss function specified within Fit.Loss(...). \n\nDifferent types of quotes are appropriate for different kinds of models. For example, if you try to value a set of equtiy EuroCalls with a Yield.Constant, you will get an error because the present_value(m<:Yield.Constant,o<:EuroCall) is not defined.\n\nReturns\n\nThe fitted model.\n\nExamples\n\njulia> model = Yield.Constant();\n\njulia> quotes = ZCBPrice([0.9, 0.8, 0.7,0.6]);\n\njulia> fit(model,quotes)\n\n              ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Yield Curve (FinanceModels.Yield.Constant)⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀           \n              ┌────────────────────────────────────────────────────────────┐           \n     0.120649 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ Zero rates\n              │⠀⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⣧⢰⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⣿⣾⠀⣀⣸⠀⢸⢳⣇⢀⣀⣀⣀⣀⣀⠀⡀⣀⣀⣀⡀⡀⣀⢀⣀⡀⡀⣀⢀⡀⣀⡀⢀⣀⡀⢀⡀⢀⣀⡀⢀⡀⠀⣀⡀⢀⡀⢀⣀⡀⢀⣀⠀⣀⡀⢀⣀⠀⢀│           \n              │⢠⢻⡟⡆⣿⡟⣦⠚⠀⢸⣾⠛⠛⠘⠛⠘⢲⡗⠛⠃⠛⠓⠓⠛⠚⠛⠑⠓⠛⠃⠓⠛⠑⠚⡟⠓⢻⡗⠚⠀⠓⠚⠑⠒⠃⠓⠚⠑⠚⠀⠓⠃⠘⠒⠃⠓⠃⠘⠒⠃│           \n              │⢸⢸⡇⢹⡏⠁⠉⠀⠀⠈⠉⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⠈⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n   Continuous │⢸⢸⡇⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⢸⠀⠁⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⢸⠀⠀⠘⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⡎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n     0.120649 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              └────────────────────────────────────────────────────────────┘           \n              ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀time⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀30⠀  \n\n\nExtended help\n\nCustomizing the Solver\n\nThe default solver is LBFGS() from Optim.jl (via OptimizationOptimJL). This is a quasi-Newton method that uses automatic differentiation (ForwardDiff) to compute gradients efficiently.\n\nAny solver from OptimizationOptimJL can be used, e.g. fit(...; optimizer=OptimizationOptimJL.Newton()) or fit(...; optimizer=OptimizationOptimJL.NelderMead()).\nMore documentation is available from the upstream packages:\nOptim.jl\nOptimization.jl\nAccessibleModels.jl\n\nDefining the variables\n\nAn arbitrarily complex model may be the object we intend to fit - how does fit know what free variables are able to be solved for within the given model? variables is a tuple of optic => interval pairs. What does this mean?\n\nAn optic (or \"lens\") is a way to define an accessor to a given object. Example:\n\njulia> using Accessors, AccessibleModels, IntervalSets\n\njulia> obj = (a = \"AA\", b = \"BB\");\n\njulia> lens = @optic _.a\n(@optic _.a)\n\njulia> lens(obj)\n\"AA\"\n\nAn optic argument is a tuple of optic => interval pairs. For example, we might have a model as follows where we want  fit to optimize parameters a and b:\n\nstruct MyModel <:FinanceModels.AbstractModel\n     a \n     b \nend\n\n__default_optic(m::MyModel) = (\n    @optic(_.a) => 0.0 .. 100.0,\n    @optic(_.b) => -10.0 .. 10.0,\n)\n\nIn this way, fit know which arbitrary parameters in a given object may be modified. Technically, we are not modifying the immutable MyModel, but instead efficiently creating a new instance. This is enabled by AccessibleModels.jl.\n\nNote that not all optimization algorithms want a bounded interval. In that case, simply leave off the paired range. The prior example would then become:\n\n__default_optic(m::MyModel) = (\n    (@optic(_.a),),\n    (@optic(_.b),),\n)\n\n```\n\nAdditional Examples\n\nSee the tutorials in the package documentation for FinanceModels.jl or the docstrings of FinanceModels.jl's available model types.\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceModels/#FinanceModels.pv_mc-Tuple{AbstractStochasticModel, Any}","page":"FinanceModels","title":"FinanceModels.pv_mc","text":"pv_mc(model, contract;\n      n_scenarios=1000, timestep=1/12, horizon=nothing,\n      rng=Random.default_rng())\n\nEstimate the expected present value of contract under the stochastic model by averaging present_value across simulated scenarios.\n\nnote: Note\npv_mc is designed for fixed-cashflow instruments where each RatePath scenario provides the discount factors. For floating-rate instruments whose cashflows depend on the rate path, project cashflows per scenario using Projection instead.\n\nThe horizon should cover the contract's maturity. The default (maturity + 1) ensures this.\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceModels/#FinanceModels.short_rate-Tuple{RatePath, Any}","page":"FinanceModels","title":"FinanceModels.short_rate","text":"short_rate(path::RatePath, t)\n\nThe instantaneous short rate r(t) for a simulated scenario.\n\nRatePath stores the cumulative integral ∫₀ᵗ r(s) ds as a LinearInterpolation. The short rate is the derivative of this cumulative integral.\n\nBecause the cumulative integral is built from Euler-Maruyama trapezoidal steps, the returned rate is piecewise-constant within each timestep — an approximation to the continuous short-rate process, not the exact value.\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceModels/#FinanceModels.simulate-Tuple{AbstractStochasticModel}","page":"FinanceModels","title":"FinanceModels.simulate","text":"simulate(model::AbstractStochasticModel;\n         n_scenarios=1000, timestep=1/12, horizon=30.0,\n         rng=Random.default_rng())\n\nGenerate n_scenarios interest-rate paths via Euler-Maruyama discretisation. Each path is returned as a RatePath (an AbstractYieldModel) so it plugs directly into present_value, discount, etc.\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceModels/#FinanceModels.ProjectionKind","page":"FinanceModels","title":"FinanceModels.ProjectionKind","text":"abstract type ProjectionKind\n\nAn abstract type that controls what gets produced from the model.\n\nSubtypes of ProjectionKind define the level of detail in the output of the model. For example, if you just want cashflows or you want a full amortization schedule, you might define an AmortizationSchedule kind which shows principle, interest, etc.\n\nAfter defining a new ProjectionKind, you need to define the how the projection works for that new output by extending either:\n\nfunction Transducers.asfoldable(p::Projection{C,M,K}) where {C<:Cashflow,M,K<:CashflowProjection}\n    ...\nend\n\nor \n\nfunction Transducers.__foldl__(rf, val, p::Projection{C,M,K}) where {C<:Cashflow,M,K<:CashflowProjection}\n    ...\nend\n\nThere are examples of this in the documentation.\n\nExamples\n\n```julia julia> struct CashflowProjection <: ProjectionKind end CashflowProjection\n\njulia> struct AmortizationSchedule <: ProjectionKind end AmortizationSchedule\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceModels/#FinanceModels.__default_optic-Tuple{FinanceModels.Yield.Constant}","page":"FinanceModels","title":"FinanceModels.__default_optic","text":"__default_optic(model)\n\nReturns the variables to optimize over for the given model. This is an optic/lens specifying which parameters of the model can vary. See extended help for more. An optic argument is a tuple of optic => interval pairs specifying which model parameters to optimize and their bounds.\n\nExamples\n\nWe might have a model as follows where we want fit to optize parameters a and b:\n\nstruct MyModel <:FinanceModels.AbstractModel\n        a \n        b \nend\n\n__default_optic(m::MyModel) = (\n    @optic(_.a) => 0.0 .. 100.0,\n    @optic(_.b) => -10.0 .. 10.0,\n)\n\nExtended help\n\nAn arbitrarily complex model may be the object we intend to fit - how does fit know what free variables are able to be solved for within the given model? variables is a tuple of optic => interval pairs. What does this mean?\n\nAn optic (or \"lens\") is a way to define an accessor to a given object. Example:\n\njulia> using Accessors, AccessibleModels, IntervalSets\n\njulia> obj = (a = \"AA\", b = \"BB\");\n\njulia> lens = @optic _.a\n(@optic _.a)\n\njulia> lens(obj)\n\"AA\"\n\nAn optic argument is a tuple of optic => interval pairs. For example, we might have a model as follows where we want  fit to optize parameters a and b:\n\nstruct MyModel <:FinanceModels.AbstractModel\n        a \n        b \nend\n\n__default_optic(m::MyModel) = (\n    @optic(_.a) => 0.0 .. 100.0,\n    @optic(_.b) => -10.0 .. 10.0,\n)\n\nIn this way, fit know which arbitrary parameters in a given object may be modified. Technically, we are not modifying the immutable MyModel, but instead efficiently creating a new instance. This is enabled by AccessibleModels.jl.\n\nNote that not all optimization algorithms want a bounded interval. In that case, simply leave off the paired range. The prior example would then become:\n\n__default_optic(m::MyModel) = (\n    (@optic(_.a),),\n    (@optic(_.b),),\n)\n\n```\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceModels/#FinanceModels.__rewrap-Tuple{Transducers.Reduction, Any}","page":"FinanceModels","title":"FinanceModels.__rewrap","text":"__rewrap(from::Transducers.Reduction, to)\n__rewrap(from, to)\n\nUsed to unwrap a Reduction which is a composition of contracts and a transducer and apply the transducers to the associated projection instead of the transducer.\n\nFor example, on its own a contract is not project-able, but wrapped in a (default) Projection it can be. But it may also be a lot more convienent  to construct contracts which have scaling or negated modifications and let that flow into a projection.\n\nExamples\n\njulia> Bond.Fixed(0.05,Periodic(1),3) |> collect\n3-element Vector{Cashflow{Float64, Float64}}:\n Cashflow{Float64, Float64}(0.05, 1.0)\n Cashflow{Float64, Float64}(0.05, 2.0)\n Cashflow{Float64, Float64}(1.05, 3.0)\n\njulia> Bond.Fixed(0.05,Periodic(1),3) |> Map(-) |> collect\n3-element Vector{Cashflow{Float64, Float64}}:\n Cashflow{Float64, Float64}(-0.05, 1.0)\n Cashflow{Float64, Float64}(-0.05, 2.0)\n Cashflow{Float64, Float64}(-1.05, 3.0)\n\njulia> Bond.Fixed(0.05,Periodic(1),3) |> Map(-) |> Map(x->x*2) |> collect\n3-element Vector{Cashflow{Float64, Float64}}:\n Cashflow{Float64, Float64}(-0.1, 1.0)\n Cashflow{Float64, Float64}(-0.1, 2.0)\n Cashflow{Float64, Float64}(-2.1, 3.0)\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceModels/#FinanceModels._zcb_option_price-Tuple{Union{FinanceModels.ShortRate.HullWhite, FinanceModels.ShortRate.Vasicek}, Any, Any, Any}","page":"FinanceModels","title":"FinanceModels._zcb_option_price","text":"_zcb_option_price(m::Union{ShortRate.Vasicek, ShortRate.HullWhite}, T, S, K)\n\nClosed-form price of a European call and put on a zero-coupon bond under a Gaussian (Vasicek or Hull-White) one-factor model.\n\nReturns (call_price, put_price).\n\nT: option expiry\nS: bond maturity (S > T)\nK: strike price\n\nReference: Brigo & Mercurio (2006), Proposition 3.2.1\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceModels/#FinanceModels.cashflows_timepoints-Tuple{Any}","page":"FinanceModels","title":"FinanceModels.cashflows_timepoints","text":"cashflows_timepoints(contracts)\ncashflows_timepoints(quotes)\n\nCreate a matrix of cashflows and a vector of timepoints for a collection of quotes or contracts. Timepoints need not be spaced evenly.\n\nThis is used when constructing SmithWilson yield curves.\n\nArguments\n\ncontracts or quotes: A collection of <:AbstractContracts or Quotes.\n\nReturns\n\nA tuple (m, times) where m is a matrix of cashflows and times is a vector of timepoints.\n\nExamples\n\njulia> FinanceModels.cashflows_timepoints(ParYield.([0.04,0.02,0.04],[1,4,4]))\n([0.02 0.01 0.02; 1.02 0.01 0.02; … ; 0.0 0.01 0.02; 0.0 1.01 1.02], [0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0])\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceModels/#FinanceModels.eurocall-Tuple{}","page":"FinanceModels","title":"FinanceModels.eurocall","text":"eurocall(;S=1.,K=1.,τ=1,r,σ,q=0.)\n\nCalculate the Black-Scholes implied option price for a european call, where:\n\nS is the current asset price\nK is the strike or exercise price\nτ is the time remaining to maturity (can be typed with \\tau[tab])\nr is the continuously compounded risk free rate\nσ is the (implied) volatility (can be typed with \\sigma[tab])\nq is the continuously paid dividend rate\n\nRates should be input as rates (not percentages), e.g.: 0.05 instead of 5 for a rate of five percent.\n\n!!! Experimental: this function is well-tested, but the derivatives functionality (API) may change in a future version of ActuaryUtilities.\n\nExtended Help\n\nThis is the same as the formulation presented in the dividend extension of the BS model in Wikipedia.\n\nOther general comments:\n\nSwap/OIS curves are generally better sources for r than government debt (e.g. US Treasury) due to the collateralized nature of swap instruments.\n(Implied) volatility is characterized by a curve that is a function of the strike price (among other things), so take care when using \nYields.jl can assist with converting rates to continuously compounded if you need to perform conversions.\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceModels/#FinanceModels.europut-Tuple{}","page":"FinanceModels","title":"FinanceModels.europut","text":"europut(;S=1.,K=1.,τ=1,r,σ,q=0.)\n\nCalculate the Black-Scholes implied option price for a european call, where:\n\nS is the current asset price\nK is the strike or exercise price\nτ is the time remaining to maturity (can be typed with \\tau[tab])\nr is the continuously compounded risk free rate\nσ is the (implied) volatility (can be typed with \\sigma[tab])\nq is the continuously paid dividend rate\n\nRates should be input as rates (not percentages), e.g.: 0.05 instead of 5 for a rate of five percent.\n\n!!! Experimental: this function is well-tested, but the derivatives functionality (API) may change in a future version of ActuaryUtilities.\n\nExtended Help\n\nThis is the same as the formulation presented in the dividend extension of the BS model in Wikipedia.\n\nOther general comments:\n\nSwap/OIS curves are generally better sources for r than government debt (e.g. US Treasury) due to the collateralized nature of swap instruments.\n(Implied) volatility is characterized by a curve that is a function of the strike price (among other things), so take care when using \nYields.jl can assist with converting rates to continuously compounded if you need to perform conversions.\n\n\n\n\n\n","category":"method"},{"location":"migration/#Migration-Guide","page":"Migration Guide","title":"Migration Guide","text":"","category":"section"},{"location":"migration/#v3-to-v4","page":"Migration Guide","title":"v3 to v4","text":"","category":"section"},{"location":"migration/#Yields.jl-is-now-FinanceModels.jl","page":"Migration Guide","title":"Yields.jl is now FinanceModels.jl","text":"This re-write accomplishes three primary things:\n\nProvide a composable set of contracts and Quotes\nThose contracts, when combined with a model produce a Cashflow via a flexibly defined Projection\nmodels can be fit with a new unified API: fit(model_type,quotes,fit_method)","category":"section"},{"location":"migration/#Migrating-Code","page":"Migration Guide","title":"Migrating Code","text":"","category":"section"},{"location":"migration/#Update-Dependencies","page":"Migration Guide","title":"Update Dependencies","text":"You should remove Yields from your project's dependencies and add FinanceModels instead. (link to Pkg documentation on how to do this)","category":"section"},{"location":"migration/#API-Changes","page":"Migration Guide","title":"API Changes","text":"Previously, the API pattern was, e.g.:\n\nmodel = Yields.Par(SmitWilson(...), rates,timepoints)\n\nNow, follow the pattern of:\n\nDefine the quotes you want to fit the model to\nfit the model to those quotes\n\nExample:\n\nquotes = ParYield.(rates,timepoints)\nmodel = fit(SmithWilson(),quotes)","category":"section"},{"location":"migration/#Details-of-changes","page":"Migration Guide","title":"Details of changes","text":"Previously the kind of contract, the implied quotes, the type of model, and how the fitting process worked were all combined into a single call (Yields.Par). This minimized the amount of code needed to construct a yield curve, but left it fairly cumbersome to extend the package. For example, for every new yield curve model, methods for Par, CMT, OIS, Zero, ... had to be defined. Additionally, all of the inputs needed to be yields - specifying a price was not available as an argument to fit.\n\nWith the new design of the package, creating a completely new model is much easier, as only the model itself and the valuation primitives need to be defined. For example, defining a new yield curve type that works to value contracts instrument quotes only requires defining the discount method. To allow the model to be fit requires only defining a default set of parameters to optimize with __default_optic:\n\n using FinanceModels, FinanceCore\n using AccessibleModels \n using IntervalSets\n \nstruct ABDiscountLine{A} <: FinanceModels.Yield.AbstractYieldModel\n    a::A\n    b::A\nend\n\n# define the default constructor for convenience\nABDiscountLine() = ABDiscountLine(0.,0.)\n\nfunction FinanceCore.discount(m::ABDiscountLine,t)\n    #discount rate is approximated by a straight lined, floored at 0.0 and capped at 1.0\n    clamp(m.a*t + m.b, 0.0,1.0) \nend\n\n\n# `@optic` indicates what in our model variables needs to be updated (from AccessibleModels.jl)\n# `-1.0 .. 1.0` says to bound the search from negative to positive one (from IntervalSets.jl)\nFinanceModels.__default_optic(m::ABDiscountLine) = (\n    @optic(_.a) => -1.0 .. 1.0,\n    @optic(_.b) => -1.0 .. 1.0,\n)\n\nquotes = ZCBPrice([0.9, 0.8, 0.7,0.6])\n\nm = fit(ABDiscountLine(),quotes)","category":"section"},{"location":"faq/#Frequently-Asked-Questions","page":"FAQs","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"faq/#How-can-I-handle-Dates-instead-of-real-timepoints?","page":"FAQs","title":"How can I handle Dates instead of real timepoints?","text":"Currently, you must convert the Date into a real-valued timepoint for use within the models and contracts. Future releases may contemplate more explicit, built-in handling of dates. In the meantime, you may find these packages helpful if you need precise date-level accuracy:\n\nMiletus.jl\nInterestRates.jl\nBusinessDays.jl\nDayCounts.jl\nQuantLib.jl","category":"section"},{"location":"faq/#Why-does-the-package-rely-on-using-Transducers?","page":"FAQs","title":"Why does the package rely on using Transducers?","text":"Transducers are a way of defining logic to be applied to a reducible collection. They can compose together efficiently and the compiler can optimize them well. In rewriting the package from v3 to v4, Transducers vastly simplified the iteration and state handling needed when projecting the contracts. The performance remains excellent and made a lot of the internals much simpler.\n\nTransducers are a rich and powerful way to express programs and can seem somewhat unfamiliar at first encounter. For users of FinanceModels, very of transducers are needed/exposed:\n\nTo regular end-users who just use what is given to them here, the transducers internals are effectively completely hidden\nTo moderately advanced users who want to extend the functionality, as the examples show the only real exposure here is a weird function name ( __foldl__) with for loop with a return signature that has some extra information.\n\nA number of examples of extending the package are given on the FinanceModels.jl Guide page and the of course the source code itself offers examples of existing Projections and Contracts.","category":"section"},{"location":"faq/#Composite-Yield/Discount-Curves","page":"FAQs","title":"Composite Yield/Discount Curves","text":"Curves can be added or subtracted together, but note that this is not always the same thing as adding or subtracting spreads with rates. If spreads and base rates are expressed as zero rates, then the curve addition/subtraction has the same effect as re-fitting the yield model with the rate+spread inputs added together first. Non-zero rates (e.g. par rates) do not have this same property. Zero-coupon rates have a direct, linear relationship with the underlying discount factors. Par-coupon rates have a complex, non-linear relationship with the underlying discount factors and so the curve addition/subtraction does not work the same way.\n\nExample:\n\nusing FinanceModels\nusing Test\n\n\nrates = [0.01, 0.01, 0.03, 0.05, 0.07, 0.16, 0.35, 0.92, 1.40, 1.74, 2.31, 2.41] ./ 100\nspreads = [0.01, 0.01, 0.03, 0.05, 0.07, 0.16, 0.35, 0.92, 1.40, 1.74, 2.31, 2.41] ./ 100\nmats = [1 / 12, 2 / 12, 3 / 12, 6 / 12, 1, 2, 3, 5, 7, 10, 20, 30]\n\n\n### Zero coupon rates/spreads\n\nq_rf_z = ZCBYield.(rates,mats)\nq_s_z = ZCBYield.(spreads,mats)\nq_y_z = ZCBYield.(rates + spreads,mats)\n\nc_rf_z = fit(Spline.Linear(),q_rf_z,Fit.Bootstrap())\nc_s_z = fit(Spline.Linear(),q_s_z,Fit.Bootstrap())\nc_y_z = fit(Spline.Linear(),q_y_z,Fit.Bootstrap())\n\n# adding curves when the spreads were zero spreads DOES works\ndiscount(c_rf_z+c_s_z,20) ≈ discount(c_y_z,20) #true\n\n\n### Par coupon rates/spreads\n\nq_rf = CMTYield.(rates,mats)\nq_s = CMTYield.(spreads,mats)\nq_y = CMTYield.(rates + spreads,mats)\n\nc_rf = fit(Spline.Linear(),q_rf,Fit.Bootstrap())\nc_s = fit(Spline.Linear(),q_s,Fit.Bootstrap())\nc_y = fit(Spline.Linear(),q_y,Fit.Bootstrap())\n\n# adding curves when the spreads were par spreads does NOT work\ndiscount(c_rf+c_s,20) ≈ discount(c_y,20) # false\n\n\n","category":"section"},{"location":"faq/#I-have-another-question","page":"FAQs","title":"I have another question","text":"Ask on the discussion forum here: https://github.com/JuliaActuary/FinanceModels.jl/discussions","category":"section"},{"location":"API/Spline/#FinanceModels.Spline-API-Reference","page":"Spline","title":"FinanceModels.Spline API Reference","text":"Modules = [FinanceModels.Spline]","category":"section"},{"location":"API/Spline/#Exported-API","page":"Spline","title":"Exported API","text":"","category":"section"},{"location":"API/Spline/#Unexported-API","page":"Spline","title":"Unexported API","text":"Please open an issue if you encounter any issues or confusion with the package.","category":"section"},{"location":"API/Spline/#FinanceModels.Spline","page":"Spline","title":"FinanceModels.Spline","text":"Spline is a module which offers various degree splines used for fitting or bootstraping curves via the fit function.\n\nAvailable methods:\n\nSpline.BSpline(d) where d is the polynomial degree. A degree-d B-spline produces (d-1)th-order-continuous piecewise polynomials. That is, degree 2/3 is very similar to a quadratic/cubic spline respectively. BSplines are global in that a change in one point affects the entire spline (though the spline still passes through the other given points still).\nSpline.PolynomialSpline(n) where n is the nth order.\n\nThis object is not a fitted spline itself, rather it is a placeholder object which will be a spline representing the data only after using within fit.\n\nConvenience methods which create a Spline.BSpline object of the appropriate order:\n\nSpline.Linear() equals BSpline(1)\nSpline.Quadratic() equals BSpline(2)\nSpline.Cubic() equals BSpline(3)\n\nNotes on Fitting:\n\nfit(spline,quotes) will fit entire curve at once, with knots equal to the maturity points of the Quotes\nfit(spline, quotes, Fit.Bootstrap()) will curve one knot at a time, with knots equal to the maturity points of the Quotes\n\nGenerally, the former will be preferred for performance reasons.\n\nExamples\n\nusing FinanceModels\nusing BenchmarkTools\nrates = [0.07, 0.16, 0.35, 0.92, 1.4, 1.74, 2.31, 2.41] ./ 100\nmats = [1, 2, 3, 5, 7, 10, 20, 30]\n\nqs = CMTYield.(rates, mats)\nc = fit(Spline.Linear(), qs) # will fit entire curve at once, with knots equal to the maturity points of the `Quote`s\nc = fit(Spline.Linear(), qs, Fit.Bootstrap()) # will curve one knot at a time, with knots equal to the maturity points of the `Quote`s\n\n\n\n\n\n\n","category":"module"},{"location":"API/Spline/#FinanceModels.Spline.Akima","page":"Spline","title":"FinanceModels.Spline.Akima","text":"Spline.Akima()\n\nAkima (1970) interpolation. Local and resistant to outlier-induced oscillation: each segment depends on a few neighboring points. Produces C1-continuous curves.\n\nCompared to PCHIP, Akima can produce slightly different shapes near inflection points. Both are local; PCHIP additionally preserves monotonicity.\n\n\n\n\n\n","category":"type"},{"location":"API/Spline/#FinanceModels.Spline.MonotoneConvex","page":"Spline","title":"FinanceModels.Spline.MonotoneConvex","text":"Spline.MonotoneConvex()\n\nHagan-West (2006) monotone convex interpolation. Finance-aware: guarantees positive continuous forward rates (when input rates imply positive forwards) and matches discrete forward rates at knot points. Produces the best KRD locality among smooth methods.\n\nUnlike other SplineCurve types that wrap DataInterpolations, this dispatches to Yield.MonotoneConvex which implements the Hagan-West sector-based polynomial construction.\n\nReferences\n\nHagan & West, \"Interpolation Methods for Curve Construction\", Applied Mathematical Finance (2006)\n\n\n\n\n\n","category":"type"},{"location":"API/Spline/#FinanceModels.Spline.PCHIP","page":"Spline","title":"FinanceModels.Spline.PCHIP","text":"Spline.PCHIP()\n\nPiecewise Cubic Hermite Interpolating Polynomial (PCHIP). Local and monotonicity-preserving: each segment depends only on its immediate neighbors, so bumping one rate has bounded effect. Produces C1-continuous curves (continuous first derivative), giving smooth forward rates without the non-local coupling of cubic splines.\n\nPCHIP is the default interpolation for ZeroRateCurve.\n\n\n\n\n\n","category":"type"},{"location":"API/Spline/#FinanceModels.Spline.Cubic-Tuple{}","page":"Spline","title":"FinanceModels.Spline.Cubic","text":"Spline.Cubic()\n\nCreate a cubic B-spline. This object is not a fitted spline itself, rather it is a placeholder object which will be a spline representing the data only after using within fit.\n\nReturns\n\nA BSpline object representing a cubic B-spline.\n\nExamples\n\njulia> Spline.Cubic()\nBSpline(3)\n\n\n\n\n\n","category":"method"},{"location":"API/Spline/#FinanceModels.Spline.Linear-Tuple{}","page":"Spline","title":"FinanceModels.Spline.Linear","text":"Spline.Linear()\n\nCreate a linear B-spline. This object is not a fitted spline itself, rather it is a placeholder object which will be a spline representing the data only after using within fit.\n\nReturns\n\nA BSpline object representing a linear B-spline.\n\nExamples\n\njulia> Spline.Linear()\nBSpline(1)\n\n\n\n\n\n","category":"method"},{"location":"API/Spline/#FinanceModels.Spline.Quadratic-Tuple{}","page":"Spline","title":"FinanceModels.Spline.Quadratic","text":"Spline.Quadratic()\n\nCreate a quadratic B-spline. This object is not a fitted spline itself, rather it is a placeholder object which will be a spline representing the data only after using within fit.\n\nReturns\n\nA BSpline object representing a quadratic B-spline.\n\nExamples\n\njulia> Spline.Quadratic()\nBSpline(2)\n\n\n\n\n\n","category":"method"},{"location":"API/Volatility/#FinanceModels.Volatility-API-Reference","page":"Volatility","title":"FinanceModels.Volatility API Reference","text":"Modules = [FinanceModels.Volatility]","category":"section"},{"location":"API/Volatility/#Exported-API","page":"Volatility","title":"Exported API","text":"","category":"section"},{"location":"API/Volatility/#Unexported-API","page":"Volatility","title":"Unexported API","text":"Please open an issue if you encounter any issues or confusion with the package.","category":"section"},{"location":"API/Volatility/#FinanceModels.Volatility.Constant","page":"Volatility","title":"FinanceModels.Volatility.Constant","text":"Volatility.Constant(σ)\n\nA constant volatility per period. If σ is not explicitly passed, then it is set to zero.\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceCore/#FinanceCore-API-Reference","page":"FinanceCore","title":"FinanceCore API Reference","text":"Modules = [FinanceCore]","category":"section"},{"location":"API/FinanceCore/#Exported-API","page":"FinanceCore","title":"Exported API","text":"","category":"section"},{"location":"API/FinanceCore/#Unexported-API","page":"FinanceCore","title":"Unexported API","text":"Please open an issue if you encounter any issues or confusion with the package.","category":"section"},{"location":"API/FinanceCore/#FinanceCore.Cashflow","page":"FinanceCore","title":"FinanceCore.Cashflow","text":"Cashflow(amount,time)\n\nA Cahflow{A,B} is a contract that pays an amount at time. \n\nCashflows can be:\n\nnegated with the unary - operator. \nadded/subtracted together but note that the time must be isapprox equal.\nmultiplied/divided by a scalar.\n\nSupertype Hierarchy ≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡\n\nCashflow{A<:Real, B<:Timepoint} <: FinanceCore.AbstractContract <: Any\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceCore/#FinanceCore.Composite","page":"FinanceCore","title":"FinanceCore.Composite","text":"Composite(A,B)\n\nSummary ≡≡≡≡≡≡≡≡≡\n\nstruct Composite{A, B}\n\nA Composite{A,B} is a contract that is composed of two other contracts of type A and type B.  The maturity of the composite is the maximum of the maturities of the two components. \n\nIt is used to assemble arbitrarily complex contracts from simpler ones.\n\nFields ≡≡≡≡≡≡≡≡\n\na :: A\nb :: B\n\nSupertype Hierarchy ≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡\n\nComposite{A, B} <: FinanceCore.AbstractContract <: Any\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceCore/#FinanceCore.Continuous","page":"FinanceCore","title":"FinanceCore.Continuous","text":"Continuous()\n\nA type representing continuous interest compounding frequency.\n\nUse rate to retrieve the nominal rate value from a Rate with Continuous compounding.\n\nExamples\n\njulia> Rate(0.01,Continuous())\nContinuous(0.01)\n\nSee also: Periodic\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceCore/#FinanceCore.Continuous-Tuple{Any}","page":"FinanceCore","title":"FinanceCore.Continuous","text":"Continuous(rate)\n\nA convenience constructor for Rate(rate, Continuous()). Use rate to retrieve the nominal rate value.\n\njulia> Continuous(0.01)\nContinuous(0.01)\n\nSee also: Periodic\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.Periodic","page":"FinanceCore","title":"FinanceCore.Periodic","text":"Periodic(frequency)\n\nA type representing periodic interest compounding with the given frequency.\n\nfrequency will be converted to an Integer, and will round up to 8 decimal places (otherwise will throw an InexactError).\n\nUse rate to retrieve the nominal rate value from a Rate with Periodic compounding.\n\nExamples\n\nCreating a semi-annual bond equivalent yield:\n\njulia> Rate(0.01,Periodic(2))\nPeriodic(0.01, 2)\n\nSee also: Continuous\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceCore/#FinanceCore.Periodic-Tuple{Any, Any}","page":"FinanceCore","title":"FinanceCore.Periodic","text":"Periodic(rate, frequency)\n\nA convenience constructor for Rate(rate, Periodic(frequency)). Use rate to retrieve the nominal rate value.\n\nExamples\n\nCreating a semi-annual bond equivalent yield:\n\njulia> Periodic(0.01,2)\nPeriodic(0.01, 2)\n\nSee also: Continuous\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.Quote","page":"FinanceCore","title":"FinanceCore.Quote","text":"Quote(price,instrument)\n\nThe price(<:Real) is the observed value , and the instrument is the instrument/contract that the price is for.\n\nThis can be used, e.g., to calibrate a valuation model to prices for the given instruments - see FinanceModels.jl for more details.\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceCore/#FinanceCore.Rate-Tuple{Any}","page":"FinanceCore","title":"FinanceCore.Rate","text":"Rate(rate[,frequency=1])\nRate(rate,frequency::Frequency)\n\nRate is a type that encapsulates an interest rate along with its compounding frequency.\n\nInternally, all rates (including Periodic rates) are stored as their continuously compounded equivalent for performance. This means the internal field values will differ from the nominal rate. Use rate to retrieve the nominal rate value corresponding to the compounding frequency, and compounding to retrieve the compounding frequency.\n\nPeriodic rates can be constructed via Rate(rate,frequency) or Rate(rate,Periodic(frequency)). If not given a second argument, Rate(rate) is equivalent to Rate(rate,Periodic(1)).\n\nContinuous rates can be constructed via Rate(rate, Inf) or Rate(rate,Continuous()).\n\nExamples\n\njulia> Rate(0.01,Continuous())\nContinuous(0.01)\n\njulia> Continuous(0.01)\nContinuous(0.01)\n\njulia> Continuous()(0.01)\nContinuous(0.01)\n\njulia> Rate(0.01,Periodic(2))\nPeriodic(0.01, 2)\n\njulia> Periodic(0.01,2)\nPeriodic(0.01, 2)\n\njulia> Periodic(2)(0.01)\nPeriodic(0.01, 2)\n\njulia> Rate(0.01)\nPeriodic(0.01, 1)\n\njulia> Rate(0.01,2)\nPeriodic(0.01, 2)\n\njulia> Rate(0.01,Periodic(4))\nPeriodic(0.01, 4)\n\njulia> Rate(0.01,Inf)\nContinuous(0.01)\n\njulia> rate(Periodic(0.01,2))\n0.01\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.accumulation-Tuple{Any, Any}","page":"FinanceCore","title":"FinanceCore.accumulation","text":"accumulation(rate, t)\naccumulation(rate, from, to)\n\nAccumulate rate for a time t or for an interval (from, to). If rate is not a Rate, it will be assumed to be a Periodic rate compounded once per period, i.e. Periodic(rate,1). \n\n# Examples\n\njulia> accumulation(0.03, 10)\n1.3439163793441222\n\njulia> accumulation(Periodic(0.03, 2), 10)\n1.3468550065500535\n\njulia> accumulation(Continuous(0.03), 10)\n1.3498588075760032\n\njulia> accumulation(0.03, 5, 10)\n1.1592740743\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.amount-Tuple{C} where C<:Cashflow","page":"FinanceCore","title":"FinanceCore.amount","text":"amount(x)\n\nIf is an object with an amount component (e.g. a Cashflow), will retrun that amount component, otherwise just x.\n\nExamples\n\njulia> FinanceCore.amount(Cashflow(1.,3.))\n1.0\n\njulia> FinanceCore.amount(1.)\n1.0\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.compounding-Tuple{Rate}","page":"FinanceCore","title":"FinanceCore.compounding","text":"compounding(r::Rate)\n\nReturns the compounding frequency of the Rate.\n\nExamples\n\njulia> r = Continuous(0.03)\nContinuous(0.03)\n\njulia> compounding(r)\nContinuous()\n\njulia> r = Periodic(0.05, 2)\nPeriodic(0.05, 2)\n\njulia> compounding(r)\nPeriodic(2)\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.discount-Tuple{Any, Any}","page":"FinanceCore","title":"FinanceCore.discount","text":"discount(rate, t)\ndiscount(rate, from, to)\n\nDiscount rate for a time t or for an interval (from, to). If rate is not a Rate, it will be assumed to be a Periodic rate compounded once per period, i.e. Periodic(rate,1). \n\nExamples\n\njulia> discount(0.03, 10)\n0.7440939148967249\n\njulia> discount(Periodic(0.03, 2), 10)\n0.7424704182237725\n\njulia> discount(Continuous(0.03), 10)\n0.7408182206817179\n\njulia> discount(0.03, 5, 10)\n0.8626087843841639\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.internal_rate_of_return-Tuple{AbstractVector{<:Real}}","page":"FinanceCore","title":"FinanceCore.internal_rate_of_return","text":"internal_rate_of_return(cashflows::vector)::Rate\ninternal_rate_of_return(cashflows::Vector, timepoints::Vector)::Rate\n\nCalculate the internalrateof_return with given timepoints. If no timepoints given, will assume that a series of equally spaced cashflows, assuming the first cashflow occurring at time zero and subsequent elements at time 1, 2, 3, ..., n. \n\nReturns a Rate type with periodic compounding once per period (e.g. annual effective if the timepoints given represent years). Get the scalar rate by calling Yields.rate() on the result.\n\nExample\n\njulia> internal_rate_of_return([-100,110],[0,1]) # e.g. cashflows at time 0 and 1\n0.10000000001652906\njulia> internal_rate_of_return([-100,110]) # implied the same as above\n0.10000000001652906\n\nSolver notes\n\nWill try to return a root within the range [-2,2]. If the fast solver does not find one matching this condition, then a more robust search will be performed over the [.99,2] range.\n\nThe solution returned will be in the range [-2,2], but may not be the one nearest zero. For a slightly slower, but more robust version, call ActuaryUtilities.irr_robust(cashflows,timepoints) directly.\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.irr","page":"FinanceCore","title":"FinanceCore.irr","text":"irr(cashflows::vector)\nirr(cashflows::Vector, timepoints::Vector)\n\nAn alias for `internal_rate_of_return`.\n\n\n\n\n\n","category":"function"},{"location":"API/FinanceCore/#FinanceCore.present_value-Tuple{Any, Any, Any}","page":"FinanceCore","title":"FinanceCore.present_value","text":"present_value(yield_model, cashflows[, timepoints=pairs(cashflows)])\n\nDiscount the cashflows vector at the given yield_model,  with the cashflows occurring at the times specified in timepoints. If no timepoints given, assumes that cashflows happen at the indices of the cashflows.\n\nIf your timepoints are dates, you can convert them into a floating point representation of the time interval using DayCounts.jl.\n\nExamples\n\njulia> present_value(0.1, [10,20],[0,1])\n28.18181818181818\njulia> present_value(Continuous(0.1), [10,20],[0,1])\n28.096748360719193\njulia> present_value(Continuous(0.1), [10,20],[1,2])\n25.422989241919232\njulia> present_value(Continuous(0.1), [10,20])\n25.422989241919232\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.rate-Tuple{Rate{<:Any, Continuous}}","page":"FinanceCore","title":"FinanceCore.rate","text":"rate(r::Rate)\n\nReturns the nominal (untyped scalar) interest rate represented by the Rate, corresponding to its compounding frequency.\n\nSince Rate internally stores all rates (including Periodic) as their continuously compounded equivalent for performance, rate recovers the nominal rate for the given compounding convention.\n\nExamples\n\njulia> r = Continuous(0.03)\nContinuous(0.03)\n\njulia> rate(r)\n0.03\n\njulia> r = Periodic(0.06, 2)\nPeriodic(0.06, 2)\n\njulia> rate(r)\n0.06\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.timepoint-Union{Tuple{C}, Tuple{C, Any}} where C<:Cashflow","page":"FinanceCore","title":"FinanceCore.timepoint","text":"timepoint(x,t)\n\nIf x is an object with a defined time component (e.g. a Cashflow), will return that time component, otherwise will return t. This is useful in handling situations where you want to handle either Cashflows or separate amount and time vectors.\n\nExample\n\njulia> FinanceCore.timepoint(Cashflow(1.,3.),\"ignored\")\n3.0\n\njulia> FinanceCore.timepoint(1.,4.)\n4.0\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.Timepoint","page":"FinanceCore","title":"FinanceCore.Timepoint","text":"Timepoint(a)\n\nSummary ≡≡≡≡≡≡≡≡≡\n\nTimepoint is a type alias for Union{T,Dates.Date} that can be used to represent a point in time. It can be either a Dates.Date or a Real number. If defined as a real number, the interpretation is the number of (fractional) periods since time zero.\n\nCurrently, the usage of Dates.Date is not well supported across the JuliaActuary ecosystem but this type is in place such that it can be built upon further.\n\nSupertype Hierarchy ≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡\n\nTimepoint{T} = Union{T,Dates.Date} <: Any\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceCore/#Base.:*-Union{Tuple{T}, Tuple{N}, Tuple{Rate{N, T}, Real}} where {N, T<:Continuous}","page":"FinanceCore","title":"Base.:*","text":"*(Yields.Rate, T)\n*(T, Yields.Rate)\n\nThe multiplication of a Rate with a scalar will inherit the type of the Rate, or the first argument's type if both are Rates.\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#Base.:+-Union{Tuple{T}, Tuple{N}, Tuple{Rate{N, T}, Real}} where {N, T<:Continuous}","page":"FinanceCore","title":"Base.:+","text":"+(Yields.Rate, T<:Real)\n+(T<:Real, Yields.Rate)\n+(Yields.Rate,Yields.Rate)\n\nThe addition of a rate with a number will inherit the type of the Rate, or the first argument's type if both are Rates.\n\nExamples\n\njulia> Yields.Periodic(0.01,2) + Yields.Periodic(0.04,2)\nYields.Rate{Float64, Yields.Periodic}(0.05000000000000004, Yields.Periodic(2))\n\njulia> Yields.Periodic(0.04,2) + 0.01\nYields.Rate{Float64, Yields.Periodic}(0.05, Yields.Periodic(2))\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#Base.:--Union{Tuple{T}, Tuple{N}, Tuple{Rate{N, T}, Real}} where {N, T<:Continuous}","page":"FinanceCore","title":"Base.:-","text":"-(Yields.Rate, T<:Real)\n-(T<:Real, Yields.Rate)\n-(Yields.Rate, Yields.Rate)\n\nThe addition of a rate with a number will inherit the type of the Rate, or the first argument's type if both are Rates.\n\nExamples\n\njulia> Yields.Periodic(0.04,2) - Yields.Periodic(0.01,2)\nYields.Rate{Float64, Yields.Periodic}(0.030000000000000214, Yields.Periodic(2))\n\njulia> Yields.Periodic(0.04,2) - 0.01\nYields.Rate{Float64, Yields.Periodic}(0.03, Yields.Periodic(2))\n\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#Base.:/-Union{Tuple{T}, Tuple{N}, Tuple{Rate{N, T}, Real}} where {N, T<:Continuous}","page":"FinanceCore","title":"Base.:/","text":"/(x::Yields.Rate, y::Real)\n\nThe division of a Rate with a scalar will inherit the type of the Rate, or the first argument's type if both are Rates.\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#Base.convert-Union{Tuple{T}, Tuple{T, Rate}} where T<:FinanceCore.Frequency","page":"FinanceCore","title":"Base.convert","text":"convert(cf::Frequency,r::Rate)\n\nReturns a Rate with an equivalent discount but represented with a different compounding frequency.\n\nExamples\n\njulia> r = Rate(Periodic(12),0.01)\nRate(0.01, Periodic(12))\n\njulia> convert(Periodic(1),r)\nRate(0.010045960887181016, Periodic(1))\n\njulia> convert(Continuous(),r)\nRate(0.009995835646701251, Continuous())\n\n\n\n\n\n","category":"method"},{"location":"stochastic/#Stochastic-Interest-Rate-Models","page":"Stochastic Models","title":"Stochastic Interest Rate Models","text":"","category":"section"},{"location":"stochastic/#Introduction","page":"Stochastic Models","title":"Introduction","text":"FinanceModels.jl includes stochastic short-rate models that are first-class yield models. Because Vasicek, Cox-Ingersoll-Ross (CIR), and Hull-White all have closed-form zero-coupon bond prices, they implement discount(model, t) analytically. This means the entire existing valuation infrastructure – zero, forward, par, present_value, and fit – works unchanged with these models.\n\nFor stochastic-cashflow analysis (e.g. Monte Carlo valuation), simulate() generates scenario yield curves that also plug into the existing present_value.","category":"section"},{"location":"stochastic/#Available-Models","page":"Stochastic Models","title":"Available Models","text":"Model Dynamics Parameters\nShortRate.Vasicek dr = a(b - r)dt + σ dW a, b, σ, initial\nShortRate.CoxIngersollRoss dr = a(b - r)dt + σ√r dW a, b, σ, initial\nShortRate.HullWhite dr = (θ(t) - ar)dt + σ dW a, σ, curve\n\nWhere:\n\na is the speed of mean reversion\nb is the long-term mean rate\nσ is the volatility\ninitial is the initial short rate r₀ (a Rate or scalar)\ncurve is an existing yield model (for Hull-White, which calibrates to an initial term structure)","category":"section"},{"location":"stochastic/#Constructing-Models","page":"Stochastic Models","title":"Constructing Models","text":"","category":"section"},{"location":"stochastic/#Vasicek","page":"Stochastic Models","title":"Vasicek","text":"The Vasicek model is the simplest mean-reverting short-rate model. The short rate r(t) reverts to a long-term level b at speed a, with constant volatility σ.\n\nusing FinanceModels\n\nv = ShortRate.Vasicek(0.136, 0.0168, 0.0119, Continuous(0.01))\n\nThe initial rate can be passed as a scalar (interpreted as continuous) or as an explicit Rate:\n\n# These are equivalent:\nShortRate.Vasicek(0.136, 0.0168, 0.0119, 0.01)\nShortRate.Vasicek(0.136, 0.0168, 0.0119, Continuous(0.01))","category":"section"},{"location":"stochastic/#Cox-Ingersoll-Ross","page":"Stochastic Models","title":"Cox-Ingersoll-Ross","text":"The CIR model is similar to Vasicek but the volatility is proportional to √r, which prevents negative rates when the Feller condition 2ab > σ² is satisfied.\n\ncir = ShortRate.CoxIngersollRoss(0.3, 0.05, 0.1, Continuous(0.03))","category":"section"},{"location":"stochastic/#Hull-White","page":"Stochastic Models","title":"Hull-White","text":"The Hull-White model takes an existing yield curve and adds stochastic dynamics. The drift is calibrated so that the model exactly reproduces the initial term structure.\n\ncurve = fit(Spline.Cubic(), CMTYield.([0.04, 0.05, 0.055, 0.06], [1, 5, 10, 30]), Fit.Bootstrap())\nhw = ShortRate.HullWhite(0.1, 0.01, curve)\n\n# discount factors match the initial curve exactly:\ndiscount(hw, 10) == discount(curve, 10) # true","category":"section"},{"location":"stochastic/#Using-Stochastic-Models-as-Yield-Curves","page":"Stochastic Models","title":"Using Stochastic Models as Yield Curves","text":"Since these models implement discount(), all standard yield curve operations work:\n\nv = ShortRate.Vasicek(0.136, 0.0168, 0.0119, Continuous(0.01))\n\n# Discount factors (closed-form zero-coupon bond prices)\ndiscount(v, 5)        # P(0, 5)\ndiscount(v, 2, 10)    # P(2, 10)\n\n# Zero rates\nzero(v, 5)            # continuous zero rate at t=5\n\n# Forward rates\nforward(v, 2, 3)      # forward rate from t=2 to t=3\n\n# Par yields\npar(v, 10)            # par yield at t=10","category":"section"},{"location":"stochastic/#Conditional-Discount-Factors","page":"Stochastic Models","title":"Conditional Discount Factors","text":"Stochastic models also support the conditional zero-coupon bond price P(t, T | r(t) = r) — the price at time t of a bond maturing at T, given that the short rate at t is r:\n\nv = ShortRate.Vasicek(0.136, 0.0168, 0.0119, Continuous(0.01))\n\n# P(2, 10 | r(2) = 0.04) under Vasicek\ndiscount(v, 2.0, 10.0, 0.04)\n\nThis is distinct from the 2-argument form discount(v, 10) which gives the unconditional P(0, T) from the initial term structure.\n\nThe conditional form is used internally for derivative pricing (swaption Jamshidian decomposition) and can be useful for scenario analysis where the short rate at a future time is known.","category":"section"},{"location":"stochastic/#Extracting-the-Short-Rate-from-a-Simulated-Path","page":"Stochastic Models","title":"Extracting the Short Rate from a Simulated Path","text":"After simulation, you can extract the instantaneous short rate r(t) from a RatePath using short_rate:\n\nscenarios = simulate(v; n_scenarios=10, timestep=1/12, horizon=10.0)\nshort_rate(scenarios[1], 5.0)  # r(5) for the first scenario","category":"section"},{"location":"stochastic/#Valuing-Fixed-Income-Contracts","page":"Stochastic Models","title":"Valuing Fixed-Income Contracts","text":"Since stochastic models are yield models, present_value works directly for deterministic-cashflow instruments:\n\nv = ShortRate.Vasicek(0.136, 0.0168, 0.0119, Continuous(0.01))\nbond = Bond.Fixed(0.05, Periodic(2), 10)\n\n# Analytical present value using closed-form discount factors\npresent_value(v, bond)","category":"section"},{"location":"stochastic/#Calibrating-Models-with-fit","page":"Stochastic Models","title":"Calibrating Models with fit","text":"Stochastic models support calibration via fit, using the same API as all other models. The optimizer uses ForwardDiff automatic differentiation to find parameters that best match observed market quotes.\n\n# Observed market zero-coupon yields\nquotes = ZCBYield.([0.02, 0.025, 0.03], [1, 5, 10])\n\n# Initial guess\nv0 = ShortRate.Vasicek(0.1, 0.02, 0.01, Continuous(0.01))\n\n# Fit to market data\nv_fitted = fit(v0, quotes)\n\n# Verify: the fitted model reprices the quotes\nmap(q -> present_value(v_fitted, q.instrument), quotes)\n\nThe default parameter bounds for fitting are:\n\nModel a b σ initial\nVasicek 0.0 .. 5.0 -0.1 .. 0.5 0.0 .. 1.0 -0.05 .. 0.2\nCIR 0.0 .. 5.0 0.0 .. 0.5 0.0 .. 1.0 0.0 .. 0.2\nHull-White 0.0 .. 5.0 – 0.0 .. 1.0 –\n\nCustom bounds can be passed via the variables keyword argument to fit.","category":"section"},{"location":"stochastic/#Monte-Carlo-Simulation","page":"Stochastic Models","title":"Monte Carlo Simulation","text":"","category":"section"},{"location":"stochastic/#Generating-Scenarios-with-simulate","page":"Stochastic Models","title":"Generating Scenarios with simulate","text":"simulate uses Euler-Maruyama discretisation to generate interest-rate paths. Each path is returned as a RatePath, which is itself an AbstractYieldModel – so discount, zero, forward, par, and present_value all work on individual scenarios.\n\nusing Random\n\nv = ShortRate.Vasicek(0.136, 0.0168, 0.0119, Continuous(0.01))\n\nscenarios = simulate(v;\n    n_scenarios = 1000,    # number of paths\n    timestep    = 1/12,    # monthly steps\n    horizon     = 30.0,    # 30-year horizon\n    rng         = MersenneTwister(42),  # reproducible\n)\n\nlength(scenarios)            # 1000\nscenarios[1] isa RatePath    # true\n\n# Each scenario is a full yield model:\ndiscount(scenarios[1], 5)\nzero(scenarios[1], 10)\npresent_value(scenarios[1], Bond.Fixed(0.05, Periodic(2), 10))","category":"section"},{"location":"stochastic/#Monte-Carlo-Present-Value-with-pv_mc","page":"Stochastic Models","title":"Monte Carlo Present Value with pv_mc","text":"pv_mc is a convenience function that simulates scenarios and averages present_value across them:\n\nv = ShortRate.Vasicek(0.136, 0.0168, 0.0119, Continuous(0.01))\nbond = Bond.Fixed(0.05, Periodic(2), 10)\n\n# Monte Carlo expected PV\nmc = pv_mc(v, bond; n_scenarios=5000, timestep=1/12)\n\n# Compare to analytical (closed-form) PV\nanalytical = present_value(v, bond)\n\n# These should be close (within ~1-2% for 5000 scenarios)\n\nThe signature is:\n\npv_mc(model, contract;\n    n_scenarios = 1000,\n    timestep    = 1/12,\n    horizon     = nothing,   # defaults to maturity + 1\n    rng         = Random.default_rng(),\n)","category":"section"},{"location":"stochastic/#Working-with-Individual-Scenarios","page":"Stochastic Models","title":"Working with Individual Scenarios","text":"Since each scenario is a yield model, you can do per-scenario analysis:\n\nv = ShortRate.Vasicek(0.136, 0.0168, 0.0119, Continuous(0.01))\nbond = Bond.Fixed(0.05, Periodic(2), 10)\n\nscenarios = simulate(v; n_scenarios=1000, timestep=1/12, horizon=11.0)\n\n# Distribution of present values\npvs = [present_value(sc, bond) for sc in scenarios]\n\n# Percentiles\nsort!(pvs)\np95 = pvs[950]   # 95th percentile PV\np05 = pvs[50]    # 5th percentile PV\nmean_pv = sum(pvs) / length(pvs)","category":"section"},{"location":"stochastic/#Projecting-Cashflows-Across-Scenarios","page":"Stochastic Models","title":"Projecting Cashflows Across Scenarios","text":"For fixed-coupon bonds, the cashflows themselves don't change across scenarios – only the discount factors (and thus the present value) change. You can get the cashflows directly with collect:\n\nbond = Bond.Fixed(0.05, Periodic(2), 3)\ncollect(bond)\n# 6-element Vector{Cashflow}:\n#  Cashflow(0.025, 0.5)\n#  Cashflow(0.025, 1.0)\n#  ...\n#  Cashflow(1.025, 3.0)\n\nFor floating-rate bonds, the cashflows depend on forward rates, which differ across scenarios. Use Projection with a Dict mapping the reference rate key to the scenario's yield model:\n\nusing FinanceModels, Random\n\nv = ShortRate.Vasicek(0.136, 0.0168, 0.0119, Continuous(0.01))\nscenarios = simulate(v; n_scenarios=3, timestep=1/12, horizon=4.0,\n                     rng=MersenneTwister(42))\n\n# Floating bond: 2% spread over \"SOFR\", semiannual, 3-year\nbond_float = Bond.Floating(0.02, Periodic(2), 3.0, \"SOFR\")\n\nfor (i, sc) in enumerate(scenarios)\n    proj = Projection(bond_float, Dict(\"SOFR\" => sc), CashflowProjection())\n    cfs = collect(proj)\n    println(\"Scenario $i cashflows:\")\n    for cf in cfs\n        println(\"  t=$(cf.time): $(round(cf.amount; digits=4))\")\n    end\nend\n# Each scenario produces different coupon amounts because the\n# forward rates from each RatePath are different.\n\nThis also works with composite contracts like interest rate swaps, where the floating leg references a scenario:\n\ncurve = Yield.Constant(0.05)\nswap = InterestRateSwap(curve, 5)\n\nsc = scenarios[1]\nproj = Projection(swap, Dict(\"OIS\" => sc), CashflowProjection())\ncfs = collect(proj)  # net cashflows (received fixed, paid floating)","category":"section"},{"location":"stochastic/#Mean-Reversion-Behaviour","page":"Stochastic Models","title":"Mean Reversion Behaviour","text":"A key feature of these models is mean reversion. With strong mean reversion (a large), the long-term zero rate converges to b:\n\n# Strong mean reversion: long-term rate approaches b=0.05\nv_strong = ShortRate.Vasicek(2.0, 0.05, 0.01, Continuous(0.10))\nzero(v_strong, 30)  # close to Continuous(0.05)\n\n# Weak mean reversion: initial rate persists longer\nv_weak = ShortRate.Vasicek(0.01, 0.05, 0.01, Continuous(0.10))\nzero(v_weak, 30)    # still far from 0.05","category":"section"},{"location":"stochastic/#Gaussian-Model-Derivative-Pricing","page":"Stochastic Models","title":"Gaussian Model Derivative Pricing","text":"Both the Vasicek and Hull-White models are Gaussian short-rate models and share the same closed-form ZCB option formula (Black's formula). This means all derivative pricing — ZCB options, caps, floors, and swaptions — works identically for both models.\n\nFor Hull-White, since discount(hw, t) simply returns the initial curve's discount factor (the model is calibrated to match the curve exactly), bond prices alone cannot identify a and σ. Instead, Hull-White is typically calibrated to derivative prices — caps, floors, swaptions, or zero-coupon bond options.","category":"section"},{"location":"stochastic/#Zero-Coupon-Bond-Options","page":"Stochastic Models","title":"Zero-Coupon Bond Options","text":"curve = Yield.Constant(Continuous(0.05))\nhw = ShortRate.HullWhite(0.1, 0.015, curve)\n\n# Call on a ZCB: right to buy at time T=1 a ZCB maturing at S=5 for strike K\ncall = present_value(hw, Option.ZCBCall(1.0, 5.0, 0.75))\nput  = present_value(hw, Option.ZCBPut(1.0, 5.0, 0.75))","category":"section"},{"location":"stochastic/#Caps-and-Floors","page":"Stochastic Models","title":"Caps and Floors","text":"A cap is a portfolio of caplets, each paying max(L - K, 0) · τ where L is the simply-compounded forward rate. Under Hull-White, each caplet is equivalent to a scaled put on a zero-coupon bond.\n\nhw = ShortRate.HullWhite(0.03, 0.02, Yield.Constant(Continuous(0.01)))\n\n# 3% strike, quarterly resets, 2-year maturity\ncap = present_value(hw, Option.Cap(0.03, 4, 2.0))\nflr = present_value(hw, Option.Floor(0.03, 4, 2.0))\n\nCap-floor parity holds: Cap(K) - Floor(K) = forward swap value.","category":"section"},{"location":"stochastic/#Swaptions","page":"Stochastic Models","title":"Swaptions","text":"A European swaption gives the right to enter a swap at expiry. Pricing uses the Jamshidian (1989) decomposition into zero-coupon bond options.\n\nhw = ShortRate.HullWhite(0.03, 0.02, Yield.Constant(Continuous(0.01)))\n\n# 1y into 4y payer swaption, 1.1% strike, quarterly\npayer = present_value(hw, Option.Swaption(1.0, 5.0, 0.011, 4; payer=true))\n\n# Receiver swaption\nreceiver = present_value(hw, Option.Swaption(1.0, 5.0, 0.011, 4; payer=false))","category":"section"},{"location":"stochastic/#Calibrating-Hull-White-to-Derivatives","page":"Stochastic Models","title":"Calibrating Hull-White to Derivatives","text":"With derivative pricing, fit can calibrate Hull-White's a and σ to market swaption or cap prices:\n\ncurve = Yield.Constant(Continuous(0.03))\n\n# Initial guess\nhw0 = ShortRate.HullWhite(0.05, 0.01, curve)\n\n# Market swaption prices (here generated from a \"true\" model)\nhw_true = ShortRate.HullWhite(0.1, 0.015, curve)\ninstruments = [\n    Option.Swaption(1.0, 6.0, 0.03, 2),\n    Option.Swaption(2.0, 7.0, 0.03, 2),\n    Option.Swaption(3.0, 8.0, 0.03, 2),\n]\nquotes = [Quote(present_value(hw_true, inst), inst) for inst in instruments]\n\n# Calibrate\nhw_fit = fit(hw0, quotes)","category":"section"},{"location":"stochastic/#Important-Notes","page":"Stochastic Models","title":"Important Notes","text":"","category":"section"},{"location":"stochastic/#Model-Behaviour","page":"Stochastic Models","title":"Model Behaviour","text":"CIR Feller condition: The CIR model requires 2ab > σ² for the short rate to stay strictly positive. When this condition is violated, the rate can reach zero. The simulation uses the full truncation scheme (absorption at zero) in that case.\nVasicek negative rates: The Vasicek model allows negative rates by design. For very negative rates or long horizons, discount factors may exceed 1 (equivalently, zero rates are negative). This is consistent with observed negative-rate environments.","category":"section"},{"location":"stochastic/#Performance-Guidance","page":"Stochastic Models","title":"Performance Guidance","text":"simulate allocates one LinearInterpolation per scenario. For 100k scenarios with a 30-year monthly horizon, expect execution times on the order of seconds.\npv_mc is embarrassingly parallel across scenarios but is not parallelised internally. For large-scale simulations, users can parallelise with Threads.@threads or Distributed:\n\nusing Base.Threads\n\nscenarios = simulate(v; n_scenarios=100_000, timestep=1/12, horizon=31.0)\npvs = Vector{Float64}(undef, length(scenarios))\n@threads for i in eachindex(scenarios)\n    pvs[i] = present_value(scenarios[i], bond)\nend\nmean_pv = sum(pvs) / length(pvs)","category":"section"},{"location":"stochastic/#Summary","page":"Stochastic Models","title":"Summary","text":"Function Description\ndiscount(model, t) Closed-form ZCB price P(0,t)\ndiscount(model, t, T, r_t) Conditional ZCB price P(t,T | r(t)=r)\nzero(model, t) Continuous zero rate at t\nforward(model, t1, t2) Forward rate from t1 to t2\npar(model, t) Par yield at t\npresent_value(model, contract) Analytical present value\npresent_value(m, Option.ZCBCall(...)) Vasicek/Hull-White ZCB option price\npresent_value(m, Option.Cap(...)) Vasicek/Hull-White cap price\npresent_value(m, Option.Swaption(...)) Vasicek/Hull-White swaption price\nfit(model, quotes) Calibrate to market data\nsimulate(model; ...) Generate Vector{RatePath} scenarios\npv_mc(model, contract; ...) Monte Carlo expected present value\nshort_rate(path, t) Extract r(t) from a simulated RatePath","category":"section"},{"location":"API/Equity/#FinanceModels.Equity-API-Reference","page":"Equity","title":"FinanceModels.Equity API Reference","text":"Modules = [FinanceModels.Equity]","category":"section"},{"location":"API/Equity/#Exported-API","page":"Equity","title":"Exported API","text":"","category":"section"},{"location":"API/Equity/#Unexported-API","page":"Equity","title":"Unexported API","text":"Please open an issue if you encounter any issues or confusion with the package.","category":"section"},{"location":"API/Equity/#FinanceModels.Equity","page":"Equity","title":"FinanceModels.Equity","text":"The Equity module provides equity-related model definitions.\n\nSee also: the Volatility module.\n\n\n\n\n\n","category":"module"},{"location":"API/Equity/#FinanceModels.Equity.BlackScholesMerton","page":"Equity","title":"FinanceModels.Equity.BlackScholesMerton","text":"BlackScholesMerton(r, q, σ) <: AbstractEquityModel\n\nA struct representing the Black-Scholes-Merton model for equity prices.\n\nArguments\n\nr: The risk-free rate (continuously compounded scalar or a FinanceCore.Rate type).\nq: The dividend yield (continuously compounded scalar or a FinanceCore.Rate type).\nσ: The volatility model of the underlying asset (see Volatility module) \n\nFields\n\nr: The risk-free rate.\nq: The dividend yield.\nσ: The volatility model of the underlying asset (see Volatility module)\n\nWhen fitting, the volatility will be solved-for; volatility itself is a sub-model that will be optimized with a default optimization bound of 0.0 .. 10.0\n\nExamples\n\njulia> model = BlackScholesMerton(0.05, 0.02, 0.2)\nBlackScholesMerton{Float64, Float64, Float64}(0.05, 0.02, 0.2)\n\nValuing an option:\n\nm = Equity.BlackScholesMerton(0.01, 0.02, 0.15)\n\na = Option.EuroCall(CommonEquity(), 1.0, 1.0)\n\n@test pv(m, a) ≈ 0.05410094201902403\n\nFitting a set of option prices:\n\nqs = [\n    Quote(0.0541, a),\n    Quote(0.072636, b),\n]\nm = Equity.BlackScholesMerton(0.01, 0.02, Volatility.Constant())\nfit(m, qs)\n@test fit(m, qs).σ ≈ 0.15 atol = 1e-4\n\n\n\n\n\n\n","category":"type"},{"location":"API/Equity/#FinanceModels.Equity.volatility-Tuple{FinanceModels.Volatility.Constant, Any, Any}","page":"Equity","title":"FinanceModels.Equity.volatility","text":"volatility(volatility_model,strike_ratio,time_to_maturity)\n\nReturns the volatility associated with the money-ness (strike/price ratio) and time to maturity.\n\n\n\n\n\n","category":"method"},{"location":"Rates/#Rates","page":"Rates","title":"Rates","text":"We should first discuss Rates, which are reexported from FinanceCore.jl\n\nRates are types that wrap scalar values to provide information about how to determine discount and accumulation factors. These allow for explicit handling of rate compounding conventions which, if not explicit, is often a source of errors in practice.\n\nThere are two Frequency types:\n\nYields.Periodic(m) for rates that compound m times per period (e.g. m times per year if working with annual rates).\nYields.Continuous() for continuously compounding rates.","category":"section"},{"location":"Rates/#Examples","page":"Rates","title":"Examples","text":"Continuous(0.05)       # 5% continuously compounded\nPeriodic(0.05,2)       # 5% compounded twice per period\n\nThese are both subtypes of the parent Rate type and are instantiated as:\n\nRate(0.05,Continuous())       # 5% continuously compounded\nRate(0.05,Periodic(2))        # 5% compounded twice per period\n\nBroadcast over a vector to create Rates with the given compounding:\n\nPeriodic.([0.02,0.03,0.04],2) \nContinuous.([0.02,0.03,0.04]) \n\nRates can also be constructed by specifying the CompoundingFrequency and then passing a scalar rate:\n\nPeriodic(1)(0.05)\nContinuous()(0.05)","category":"section"},{"location":"Rates/#Conversion","page":"Rates","title":"Conversion","text":"Convert rates between different types with convert. E.g.:\n\nr = Rate(0.01,Periodic(12))             # rate that compounds 12 times per rate period (ie monthly)\n\nconvert(Yields.Periodic(1),r)                  # convert monthly rate to annual effective\nconvert(Yields.Continuous(),r)          # convert monthly rate to continuous\n\nTo get the scalar value out of the Rate, use FinanceModels.rate(r):\n\njulia> r = Rate(0.01,Periodic(12));   \njulia> rate(r)\n0.01\n","category":"section"},{"location":"Rates/#Arithmetic","page":"Rates","title":"Arithmetic","text":"Adding, subtracting, multiplying, dividing, and comparing rates is supported.","category":"section"},{"location":"introduction/#FinanceModels.jl-Guide","page":"Introduction","title":"FinanceModels.jl Guide","text":"FinanceModels.jl provides a set of composable contracts, models, and functions that allow for modeling of both simple and complex financial instruments. The resulting models, such as discount rates or term structures, can then be used across the JuliaActuary ecosystem to perform actuarial and financial analysis.\n\n(Image: A conceptual sketch of FinanceModels.jl)","category":"section"},{"location":"introduction/#1.-Cashflow-a-fundamental-financial-type","page":"Introduction","title":"1. Cashflow - a fundamental financial type","text":"Say you wanted to model a contract that paid quarterly payments, and those payments occurred starting 15 days from the valuation date (first payment time = 15/365 = 0.057)\n\nPreviously, you had two options:\n\nChoose a discrete timestep to model (e.g. monthly, quarterly, annual) and then lump the cashflows into those timesteps. E.g. with monthly timesteps  of a unit payment of our contract, it might look like: [1,0,0,1,0,0...]\nKeep track of two vectors: one for the payment and one for the times. In this case, that might look like: cfs = [1,1,...];times = [0.057, 0.307...]\n\nThe former has inaccuracies due to the simplified timing and logical complication related to mapping the contracts natural periodicity into an arbitrary modeling choice. The latter becomes unwieldy and fails to take advantage of Julia's type system.\n\nThe new solution: Cashflows. Our example above would become: [Cashflow(1,0.057), Cashflow(1,0.307),...]","category":"section"},{"location":"introduction/#2.-**Contracts**-A-composable-way-to-represent-financial-instruments","page":"Introduction","title":"2. Contracts - A composable way to represent financial instruments","text":"Contracts are a composable way to represent financial instruments. They are, in essence, anything that is a collection of cashflows. Contracts can be combined to represent more complex instruments. For example, a bond can be represented as a collection of cashflows that correspond to the coupon payments and the principal repayment.\n\nExamples:\n\na Cashflow\nBonds:\nBond.Fixed, Bond.Floating\nOptions:\nOption.EuroCall and Option.EuroPut\nCompositional contracts:\nForwardto represent an instrument that is relative to a forward point in time.\nComposite to represent the combination of two other instruments.  \n\nIn the future, this notion may be extended to liabilities (e.g. insurance policies in LifeContingencies.jl)","category":"section"},{"location":"introduction/#Creating-a-new-Contract","page":"Introduction","title":"Creating a new Contract","text":"A contract is anything that creates a vector of Cashflows when collected. For example, let's create a bond which only pays down principle and offers no coupons.\n\nusing FinanceModels,FinanceCore\n\n# Transducers is used to provide a more powerful, composable way to construct collections than the basic iteration interface\nusing Transducers: __foldl__, @next, complete\n\n\"\"\"\nA bond which pays down its par (one unit) in equal payments. \n\"\"\"\nstruct PrincipalOnlyBond{F<:FinanceCore.Frequency} <: FinanceModels.Bond.AbstractBond\n    frequency::F\n    maturity::Float64\nend\n\n# We extend the interface to say what should happen as the bond is projected\n# There's two parts to customize:\n# 1. any initialization or state to keep track of\n# 2. The loop where we decide what gets returned at each timestep\nfunction Transducers.__foldl__(rf, val, p::Projection{C,M,K}) where {C<:PrincipalOnlyBond,M,K}\n    # initialization stuff\n    b = p.contract # the contract within a projection\n    ts = Bond.coupon_times(b) # works since it's a FinanceModels.Bond.AbstractBond with a frequency and maturity\n    pmt = 1 / length(ts)\n\n    for t in ts\n        # the loop which returns a value\n        cf = Cashflow(pmt, t)\n        val = @next(rf, val, cf) # the value to return is the last argument\n    end\n    return complete(rf, val)\nend\n\nThat's it! then we can use this contract to fitting models, create projections, quotes, etc. Here we simply collect the bond into an array of cashflows:\n\njulia> PrincipalOnlyBond(Periodic(2),5.) |> collect\n10-element Vector{Cashflow{Float64, Float64}}:\n Cashflow{Float64, Float64}(0.1, 0.5)\n Cashflow{Float64, Float64}(0.1, 1.0)\n Cashflow{Float64, Float64}(0.1, 1.5)\n Cashflow{Float64, Float64}(0.1, 2.0)\n Cashflow{Float64, Float64}(0.1, 2.5)\n Cashflow{Float64, Float64}(0.1, 3.0)\n Cashflow{Float64, Float64}(0.1, 3.5)\n Cashflow{Float64, Float64}(0.1, 4.0)\n Cashflow{Float64, Float64}(0.1, 4.5)\n Cashflow{Float64, Float64}(0.1, 5.0)\n\nNote that all contracts in FinanceModels.jl are currently unit contracts in that they assume a unit par value. Scale assets down to unit values before constructing the default contracts.","category":"section"},{"location":"introduction/#More-complex-Contracts","page":"Introduction","title":"More complex Contracts","text":"When the cashflow depends on a model. An example of this is a floating bond where the coupon paid depends on a view of forward rates. See Section 6 - Projections for how this is handled.","category":"section"},{"location":"introduction/#3.-Quotes-The-observed-price-we-need-to-fit-a-model-to","page":"Introduction","title":"3. Quotes - The observed price we need to fit a model to","text":"Quotes are the observed prices that we need to fit a model to. They represent the market prices of financial instruments, such as bonds or swaps. In the context of the package, a quote is defined as a pair of a contract and a price.\n\nFor example, a par yield bond paying a 4% coupon (paid as 2% twice per annum) implies a price at par (i.e. 1.0):\n\njulia> ParYield(Periodic(0.04,2),10)\nQuote{Float64, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}}(\n1.0, \nFinanceModels.Bond.Fixed{Periodic, Float64, Int64}(0.040000000000000036, Periodic(2), 10))\n\n\nA number of convenience functions are included to construct a Quote:\n\nZCBPrice and ZCBYield\nParYield\nCMTYield\nOISYield\nForwardYields","category":"section"},{"location":"introduction/#4.-**Models**-Not-just-yield-curves-anymore","page":"Introduction","title":"4. Models - Not just yield curves anymore","text":"Yield Curves: all of Yields.jl yield models are included in the initial FinanceModels.jl release\nEquities and Options: The initial release includes BlackScholesMerton option pricing and one can use constant or spline volatility models\nOthers more to come in the future","category":"section"},{"location":"introduction/#Creating-a-new-model","page":"Introduction","title":"Creating a new model","text":"Here we'll do a complete implementation of a yield curve model where the discount rate is approximated by a straight line (often called an AB line from the y=ax+b formula.\n\n using FinanceModels, FinanceCore\n using AccessibleModels \n using IntervalSets\n \nstruct ABDiscountLine{A} <: FinanceModels.Yield.AbstractYieldModel\n    a::A\n    b::A\nend\n\nABDiscountLine() = ABDiscountLine(0.,0.)\n\nfunction FinanceCore.discount(m::ABDiscountLine,t)\n    #discount rate is approximated by a straight line, floored at 0.0 and capped at 1.0\n    clamp(m.a*t + m.b, 0.0,1.0) \nend\n\n\n# `@optic` indicates what in our model variables needs to be updated (from AccessibleModels.jl)\n# `-1.0 .. 1.0` says to bound the search from negative to positive one (from IntervalSets.jl)\nFinanceModels.__default_optic(m::ABDiscountLine) = (\n    @optic(_.a) => -1.0 .. 1.0,\n    @optic(_.b) => -1.0 .. 1.0,\n)\n\nquotes = ZCBPrice([0.9, 0.8, 0.7,0.6])\n\nm = fit(ABDiscountLine(),quotes)\n\nNow, m is a model like any of the other yield curve models provided and can be used in that context. For example, calculating the price of the bonds contained within our quotes where we indeed recover the prices for our contrived example:\n\njulia> map(q -> pv(m,q.instrument),quotes) \n4-element Vector{Float64}:\n 0.9\n 0.8\n 0.7\n 0.6","category":"section"},{"location":"introduction/#5.-fit-The-standardized-API-for-all-models,-quotes,-and-methods","page":"Introduction","title":"5. fit - The standardized API for all models, quotes, and methods","text":"       Model                                                               Method\n          |                                                                   |\n    |------------|                                                     |---------------|\nfit(Spline.Cubic(), CMTYield.([0.04,0.05,0.055,0.06,0055],[1,2,3,4,5]), Fit.Bootstrap())\n                    |-------------------------------------------------|\n                                              |\n                                              Quotes\n\nModel could be Spline.Linear(), Yield.NelsonSiegelSvensson(), Equity.BlackScholesMerton(...), etc.\nQuote could be CMTYields, ParYields, Option.Eurocall, etc.\nMethod could be Fit.Loss(x->x^2), Fit.Loss(x->abs(x)), Fit.Bootstrap(), etc.\n\nThe benefit of this versus the old Yields.jl API is:\n\nWithout a generic fit method, no obvious way to expose different curve construction methods (e.g. choice of model and method)\nThe fit is extensible. Users or other packages could define their own Models, Quotes, or Methods and integrate into the JuliaActuary ecosystem.\nThe fit formulation is very generic: the required methods are minimal to integrate in order to extend the functionality.","category":"section"},{"location":"introduction/#Customizing-model-fitting","page":"Introduction","title":"Customizing model fitting","text":"Model fitting can be customized:\n\nThe loss function (least squares, absolute difference, etc.) via the third argument to fit:\ne.g.fit(ABDiscountLine(), quotes, FIt.Loss(x -> abs(x))\nthe default is Fit.Loss(x->x^2)\nthe optimization algorithm by defining a method FinanceModels.__default_optim__(m::ABDiscountLine) = OptimizationOptimJL.Newton()\nyou may need to change the __default_optic to be unbounded (simply omit the => and subsequent bounds)\nThe default is OptimizationMetaheuristics.ECA()\nThe general algorithm can be customized by creating a new method for fit:\n\nfunction FinanceModels.fit(m::ABDiscountLine, quotes, ...)\n # custom code for fitting your model here\nend\n\nAs an example, the splines (Spline.Linear(), Spline.Cubic(),...) are defined to use bootstrap by default: fit(mod0::Spline.BSpline, quotes, method::Fit.Bootstrap)","category":"section"},{"location":"introduction/#Using-models-without-fitting","page":"Introduction","title":"Using models without fitting","text":"While many of the examples show models being fit to observed prices, you can skip that step in practice if you want to define an assumed valuation model that does not intend to calibrate market prices.","category":"section"},{"location":"introduction/#6.-Projections","page":"Introduction","title":"6. Projections","text":"A Projection is a generic way to work with various data that you can project forward. For example, getting the series of cashflows associated with a contract.\n\nWhat is a Projection?\n\nstruct Projection{C,M,K} <: AbstractProjection\n    contract::C    # the contract (or set of contracts) we want to project\n    model::M       # the model that defines how the contract will behave\n    kind::K           # what kind of projetion do we want? only cashflows? \nend\n\ncontract is obvious, so let's talk more about the second two:\n\nmodel is the same kind of thing we discussed above. Some contracts (e.g. a floating rate bond). We can still decompose a floating rate bond into a set of cashflows, but we need a model.\nThere are also projections which don't need a model (e.g. fixed bonds) and for that there's the generic NullModel()\nkind defines what we'll return from the projection.\nCashflowProjection() says we just want a Cashflow[...] vector\n... but if we wanted to extend this such that we got a vector containing cashflows, capital factors, default rates, etc we could define a new projection type (e.g. we might call the above AssetDetailProjection()\nCurrently, only CashflowProjection() is defined by FinanceModels.jl","category":"section"},{"location":"introduction/#Contracts-that-depend-on-the-model-(or-multiple-models)","page":"Introduction","title":"Contracts that depend on the model (or multiple models)","text":"For example, the cashflows you generate for a floating rate bond is the current reference rate. Or maybe you have a stochastic volatility model and want to project forward option values. This type of dependency is handled like this:\n\ndefine model as a relation that maps a key to a model. E.g. a Dict(\"SOFR\" => NelsonSiegelSvensson(...))\nwhen defining the logic for the reducible collection/foldl, you can reference the Projection.model by the associated key.\n\nHere's how a floating bond is implemented:\n\nThe contract struct. The key would be \"SOFR\" in our example above.\n\nstruct Floating{F<:FinanceCore.Frequency,N<:Real,M<:Timepoint,K} <: AbstractBond\n    coupon_rate::N # coupon_rate / frequency is the actual payment amount\n    frequency::F\n    maturity::M\n    key::K\nend\n\nAnd how we can reference the associated model when projecting that contract. This is very similar to the definition of __foldl__ for our PrincipalOnlyBond, except we are paying a coupon and referencing the scenario rate.\n\n@inline function Transducers.__foldl__(rf, val, p::Projection{C,M,K}) where {C<:Bond.Floating,M,K}\n    b = p.contract\n    ts = Bond.coupon_times(b)\n    for t in ts\n        freq = b.frequency # e.g. `Periodic(2)`\n        freq_scalar = freq.frequency  # the 2 from `Periodic(2)`\n\n        # get the rate from the current time to next payment \n        # out of the model and convert it to the contract's periodicity\n        model = p.model[b.key]\n        reference_rate = rate(freq(forward(model, t, t + 1 / freq_scalar)))\n        coup = (reference_rate + b.coupon_rate) / freq_scalar\n        amt = if t == last(ts)\n            1.0 + coup\n        else\n            coup\n        end\n        cf = Cashflow(amt, t)\n        val = @next(rf, val, cf)\n    end\n    return complete(rf, val)\nend\n\nIn this post we've now defined two assets that can work seamlessly with projecting cashflows, fitting models, and determining valuations :)","category":"section"},{"location":"introduction/#7.-ProjectionKinds","page":"Introduction","title":"7. ProjectionKinds","text":"While CashflowProjection is the most common (and the only one built into the initial release of FinanceModels), a Projection can be created which handles different kinds of outputs in the same manner as projecting just basic cashflows. For example, you may want to output an amortization schedule, or a financial statement, or an account value roll-forward. The Projection is able to handle these custom outputs by dispatching on the third element in a Projection.\n\nLet's extend the example of a principle-only bond from section 2 above. Our goal is to create a basic amortization schedule which shows the payment made and outstanding balance.\n\nFirst, we create a new subtype of ProjectionKind:\n\nstruct AmortizationSchedule <: FinanceModels.ProjectionKind\nend\n\nAnd then define the loop for the amortization schedule output:\n\n# note the dispatch on `AmortizationSchedule` in the next line\nfunction Transducers.__foldl__(rf, val, p::Projection{C,M,K}) where {C<:PrincipalOnlyBond,M,K<:AmortizationSchedule}\n    # initialization stuff\n    b = p.contract # the contract within a projection\n    ts = Bond.coupon_times(b) # works since it's a FinanceModels.Bond.AbstractBond with a frequency and maturity\n    pmt = 1 / length(ts)\n    balance = 1.0\n    for t in ts\n        # the loop wich returns a tuple of the relevant data\n        balance -= pmt\n        result = (time=t,payment=pmt,outstanding=balance)\n        val = @next(rf, val, result) # the value to return is the last argument\n    end\n    return complete(rf, val)\nend\n\nWe can now define the projection:\n\njulia> p = Projection(\n           PrincipalOnlyBond(Periodic(2),5.),  # our contract\n           NullModel(),                       # the projection doesn't need a model, so use the null model\n           AmortizationSchedule(),            # specify the amortization schedule output\n           );\n\n\nAnd then collect the values:\n\njulia> collect(p)\n10-element Vector{NamedTuple{(:time, :payment, :outstanding), Tuple{Float64, Float64, Float64}}}:\n (time = 0.5, payment = 0.1, outstanding = 0.9)\n (time = 1.0, payment = 0.1, outstanding = 0.8)\n (time = 1.5, payment = 0.1, outstanding = 0.7000000000000001)\n (time = 2.0, payment = 0.1, outstanding = 0.6000000000000001)\n (time = 2.5, payment = 0.1, outstanding = 0.5000000000000001)\n (time = 3.0, payment = 0.1, outstanding = 0.40000000000000013)\n (time = 3.5, payment = 0.1, outstanding = 0.30000000000000016)\n (time = 4.0, payment = 0.1, outstanding = 0.20000000000000015)\n (time = 4.5, payment = 0.1, outstanding = 0.10000000000000014)\n (time = 5.0, payment = 0.1, outstanding = 1.3877787807814457e-16)","category":"section"},{"location":"#FinanceModels.jl","page":"Home","title":"FinanceModels.jl","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage)\n\nFinanceModels.jl provides a set of composable contracts, models, and functions that allow for modeling of both simple and complex financial instruments. The resulting models, such as discount rates or term structures, can then be used across the JuliaActuary ecosystem to perform actuarial and financial analysis.\n\nAdditionally, the models can be used to project contracts through time: most basically as a series of cashflows but more complex output can be defined for contracts.\n\n(Image: anim_fps2)","category":"section"},{"location":"#QuickStart","page":"Home","title":"QuickStart","text":"using FinanceModels\n\n# a set of market-observed prices we wish to calibrate the model to\n# annual effective unless otherwise specified\nq_rate = ZCBYield([0.01,0.02,0.03]);\nq_spread = ZCBYield([0.01,0.01,0.01]);\n\n# bootstrap a linear spline yield model\nmodel_rate = fit(Spline.Linear(),q_rate,Fit.Bootstrap());⠀           \nmodel_spread = fit(Spline.Linear(),q_spread,Fit.Bootstrap());\n\n# the zero rate is the combination of the two underlying rates\nzero(m_spread + m_rate,1) # 0.02 annual effective rate \n\n# the discount is the same as if we added the underlying zero rates\ndiscount(m_spread + m_rate,0,3) ≈ discount(0.01 + 0.03,3)   # true\n\n# compute the present value of a contract (a cashflow of 10 at time 3)\npresent_value(m_rate,Cashflow(10,3)) # 9.15...","category":"section"},{"location":"#Overview-of-FinanceModels","page":"Home","title":"Overview of FinanceModels","text":"(Image: A conceptual sketch of FinanceModels.jl)\n\nOften we start with observed or assumed values for existing contracts. We want to then use those assumed values to extend the valuation logic to new contracts. For example, we may have a set of bond yields which we then want to discount a series of insurance obligations.\n\nIn the language of FinanceModels, we would have a set of Quotes which are used to fit a Model. That model is then used to discount a new series of cashflows.\n\nThat's just an example, and we can use the various components in different ways depending on the objective of the analysis.","category":"section"},{"location":"#Contracts-and-Quotes","page":"Home","title":"Contracts and Quotes","text":"Contracts are a way to represent financial obligations. These can be valued using a model, projected into a future steam of values, or combined with assumed prices as a Quote.\n\nIncluded are a number of primitives and convenience methods for contracts:\n\nExisting structs:\n\nCashflow\nBond.Fixed\nBond.Floating\nForward (an obligation with a forward start time)\nComposite (combine two other contracts, e.g. into a swap)\nEuroCall\nCommonEquity\nOption.Cap, Option.Floor, Option.Swaption (interest rate derivatives)\n\nCommonly, we deal with conventions that imply a contract and an observed price. For example, we may talk about a treasury yield of 0.03. This is a description that implies a Quoteed price for an underling fixed bond. In FinanceModels, we could use CMTYield(rate,tenor) which would create a Quote(price,Bond.Fixed(...)). In this way, we can conveniently create a number of Quotes which can be used to fit models. Such convenience methods include:\n\nZCBYield\nZCBPrice\nCMTYield\nParYield\nParSwapYield\nForwardYield\n\nFinanceModels offers a way to define new contracts as well.","category":"section"},{"location":"#Cashflows","page":"Home","title":"Cashflows","text":"A Cashflows obligation are themselves a contract, but other contracts can be considered as essentially anything that can be combined with assumptions (a model) to derive a collection of cashflows.\n\nFor example, a obligation that pays 1.75 at time 2 could be represented as: Cashflow(1.75,2).","category":"section"},{"location":"#Models","page":"Home","title":"Models","text":"Models are objects that can be fit to observed prices and then subsequently used to make valuations of other cashflows/contracts.\n\nYield models include:\n\nYield.Constant\nBootstrapped Splines\nYield.SmithWilson\nYield.NelsonSiegel\nYield.NelsonSiegelSvensson","category":"section"},{"location":"#Yield-related-functions","page":"Home","title":"Yield-related functions","text":"The models can be used to compute various rates of interest:\n\ndiscount(curve,from,to) or discount(curve,to) gives the discount factor\naccumulation(curve,from,to) or accumulation(curve,to) gives the accumulation factor\nzero(curve,time) or zero(curve,time,Frequency) gives the zero-coupon spot rate for the given time.\nforward(curve,from,to) gives the zero rate between the two given times\npar(curve,time;frequency=2) gives the coupon-paying par equivalent rate for the given time.","category":"section"},{"location":"#ZeroRateCurve-—-direct-construction","page":"Home","title":"ZeroRateCurve — direct construction","text":"Construct a zero-rate curve directly from rates and tenors, without fitting:\n\nrates = [0.02, 0.025, 0.03, 0.035, 0.04]\ntenors = [1.0, 2.0, 3.0, 5.0, 10.0]\nzrc = ZeroRateCurve(rates, tenors)                          # default: MonotoneConvex\nzrc = ZeroRateCurve(rates, tenors, Spline.Linear())          # or Linear, PCHIP, Cubic, Akima\n\nZeroRateCurve is compatible with ForwardDiff dual numbers, making it the primary interface for automatic differentiation-based sensitivities in ActuaryUtilities.jl.","category":"section"},{"location":"#Stochastic-short-rate-models","page":"Home","title":"Stochastic short-rate models","text":"Simulate interest rate paths under classical short-rate dynamics:\n\nShortRate.Vasicek — mean-reverting Gaussian: dr = a(b - r)dt + σ dW\nShortRate.CoxIngersollRoss — square-root volatility: dr = a(b - r)dt + σ√r dW\nShortRate.HullWhite — calibrated to an initial term structure: dr = (θ(t) - ar)dt + σ dW\n\nusing FinanceModels: ShortRate, simulate\n\nzrc = ZeroRateCurve([0.03, 0.03, 0.03, 0.03, 0.03], [1.0, 2.0, 3.0, 4.0, 5.0])\nhw = ShortRate.HullWhite(0.1, 0.01, zrc)\n\n# Monte Carlo simulation — returns a vector of RatePath scenarios\nscenarios = simulate(hw; n_scenarios=1000, timestep=1/12, horizon=30.0)\n\n# Expected present value of a contract under stochastic rates\npv_mc(hw, Bond.Fixed(0.04, Periodic(1), 5); n_scenarios=1000)\n\nClosed-form pricing for Gaussian models (Vasicek, Hull-White):\n\nZero-coupon bond options via present_value(model, Option.ZCBCall(...))\nInterest rate caps and floors via present_value(model, Option.Cap(...))\nEuropean swaptions via Jamshidian decomposition: present_value(model, Option.Swaption(...))\n\nOther models include:\n\nBlackScholesMerton derivative valuation","category":"section"},{"location":"#Plotting-of-Yield-Curves","page":"Home","title":"Plotting of Yield Curves","text":"In interactive sessions (e.g. REPL, Notebooks, VS Code, etc.) you can get a pretty printing of yield curves by also using UnicodePlots.jl, for example:\n\njulia> using FinanceModels\njulia> q_rate = ZCBYield.([0.01, 0.02, 0.03,0.04,0.03],[1,3,5,10,20]);\njulia> fit(Spline.PolynomialSpline(3), q_rate, Fit.Bootstrap())\nFinanceModels.Yield.Spline{DataInterpolations.CubicSpline{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, true, Float64}}([0.009950330853168092, 0.009950330853168092, 0.019802627296179747, 0.02955880224154443, 0.0, 1.0, 2.0, 3.0])\n\njulia> using UnicodePlots \njulia> fit(Spline.PolynomialSpline(3), q_rate, Fit.Bootstrap()) # after importing UnicodePlots\n              ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Yield Curve (FinanceModels.Yield.Spline)⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀           \n              ┌────────────────────────────────────────────────────────────┐           \n         0.04 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⠤⠖⠒⠊⠉⠉⠉⠒⠒⠢⠤⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ Zero rates\n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⠔⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠑⠒⢄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠖⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠑⠢⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡔⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠒⢄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⢠⠎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠓⠤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⢠⠎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠑⠦⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⢠⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠓⠦⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀│           \n   Continuous │⠀⠀⠀⠀⠀⢠⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠒⠒⠦⠤⠤⠤⠤│           \n              │⠀⠀⠀⠀⢀⠎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⢀⡎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⢀⠎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠒⠒⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n            0 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              └────────────────────────────────────────────────────────────┘           \n              ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀time⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀30⠀           \n\n\n[!NOTE] This was built-in prior to v4.9 of FinanceModels. It has been split out to materially speed up using FinanceModels.","category":"section"},{"location":"#Projections","page":"Home","title":"Projections","text":"Most basically, we can project a contract into a series of Cashflows:\n\njulia> b = Bond.Fixed(0.04,Periodic(2),3)\nFinanceModels.Bond.Fixed{Periodic, Float64, Int64}(0.04, Periodic(2), 3)\n\njulia> collect(b)\n6-element Vector{Cashflow{Float64, Float64}}:\n Cashflow{Float64, Float64}(0.02, 0.5)\n Cashflow{Float64, Float64}(0.02, 1.0)\n Cashflow{Float64, Float64}(0.02, 1.5)\n Cashflow{Float64, Float64}(0.02, 2.0)\n Cashflow{Float64, Float64}(0.02, 2.5)\n Cashflow{Float64, Float64}(1.02, 3.0)\n\nHowever, Projections allow one to combine three elements which can be extended to define any desired output (such as amortization schedules, financial statement projections, or account value rollforwards). The three elements are:\n\nthe underlying contract of interest\nthe model which includes assumptions of how the contract will behave\na ProjectionKind which indicates the kind of output desired (cashflow stream, amortization schedule, etc...)","category":"section"},{"location":"#Examples","page":"Home","title":"Examples","text":"A fixed bond that needs no valuation model (NullModel()) to define its projected gross cashflows:\n\nProjection(Bond.Fixed(0.04,Periodic(2),3),NullModel(),CashflowProjection())","category":"section"},{"location":"#Plotting-Projections","page":"Home","title":"Plotting Projections","text":"A CashflowProjection or a vector of Cashflows can be plotted with the Makie family of plotting packages.\n\nusing FinanceModels, CairoMakie\nproj = Projection(Bond.Fixed(0.10,Periodic(2),20),NullModel(),CashflowProjection())\n# a stem plot:\nstem(proj)\n\nWill produce:\n\n(Image: A stem plot of bond cashflows)","category":"section"},{"location":"#Fitting-Models","page":"Home","title":"Fitting Models","text":"","category":"section"},{"location":"#Fitting-Models-2","page":"Home","title":"Fitting Models","text":"       Model                                                               Method\n          |                                                                   |\n   |------------|                                                     |---------------|\nfit(Spline.Cubic(), CMTYield.([0.04,0.05,0.055,0.06,0055],[1,2,3,4,5]), Fit.Bootstrap())\n                    |-------------------------------------------------|\n                                              |\n                                              Quotes\n\nModel could be Spline.Linear(), Yield.NelsonSiegelSvensson(), Equity.BlackScholesMerton(...), etc.\nQuote could be CMTYields, ParYields, Option.Eurocall, etc.\nMethod could be Fit.Loss(x->x^2), Fit.Loss(x->abs(x)), Fit.Bootstrap(), etc.\n\nThis unified way to fit models offers a much simpler way to extend functionality to new models or contract types.","category":"section"},{"location":"#Using-Models","page":"Home","title":"Using Models","text":"After being fit, models can be used to value contracts:\n\npresent_value(model,cashflows)\n\nAdditionally, ActuaryUtilities.jl offers a number of other methods that can be used, such as duration, convexity, price which can be used for analysis with the fitted models.","category":"section"},{"location":"#Rates","page":"Home","title":"Rates","text":"Rates are types that wrap scalar values to provide information about how to determine discount and accumulation factors.\n\nThere are two Frequency types:\n\nPeriodic(m) for rates that compound m times per period (e.g. m times per year if working with annual rates).\nContinuous() for continuously compounding rates.","category":"section"},{"location":"#Examples-2","page":"Home","title":"Examples","text":"Continuous(0.05)       # 5% continuously compounded\nPeriodic(0.05,2)       # 5% compounded twice per period\n\nThese are both subtypes of the parent Rate type and are instantiated as:\n\nRate(0.05,Continuous())       # 5% continuously compounded\nRate(0.05,Periodic(2))        # 5% compounded twice per period\n\nRates can also be constructed by specifying the Frequency and then passing a scalar rate:\n\nPeriodic(1)(0.05)\nContinuous()(0.05)","category":"section"},{"location":"#Conversion","page":"Home","title":"Conversion","text":"Convert rates between different types with convert. E.g.:\n\nr = Rate(FinanceModels.Periodic(12),0.01)             # rate that compounds 12 times per rate period (ie monthly)\n\nconvert(FinanceModels.Periodic(1),r)                  # convert monthly rate to annual effective\nconvert(FinanceModels.Continuous(),r)          # convert monthly rate to continuous","category":"section"},{"location":"#Arithmetic","page":"Home","title":"Arithmetic","text":"Adding, substracting, multiplying, dividing, and comparing rates is supported.","category":"section"},{"location":"#Guide-and-Documentation","page":"Home","title":"Guide and Documentation","text":"A guide which explains more about the components of the package and from-scratch examples of extending the package is available in the documenation","category":"section"},{"location":"#Exported-vs-Un-exported-Functions","page":"Home","title":"Exported vs Un-exported Functions","text":"Generally, CamelCase methods which construct a datatype are exported as they are unlikely to conflict with other parts of code that may be written. For example, rate is un-exported (it must be called with FinanceModels.rate(...)) because rate is likely a very commonly defined variable within actuarial and financial contexts and there is a high risk of conflicting with defined variables.\n\nConsider using import FinanceModels which would require qualifying all methods, but alleviates any namespace conflicts and has the benefit of being explicit about the calls (internally we prefer this in the package design to keep dependencies and their usage clear).","category":"section"},{"location":"#Internals","page":"Home","title":"Internals","text":"For time-variant FinanceModels (ie yield curves), the inputs are converted to spot rates and interpolated using quadratic B-splines by default (see documentation for alternatives, such as linear interpolations).","category":"section"},{"location":"#Combination-Implementation","page":"Home","title":"Combination Implementation","text":"Combinations track two different curve objects and are not combined into a single underlying data structure. This means that you may achieve better performance if you combine the rates before constructing a FinanceModels representation. The exception to this is Constant curves, which do get combined into a single structure that is as performant as pre-combined rate structure.","category":"section"},{"location":"#Related-Packages","page":"Home","title":"Related Packages","text":"InterestRates.jl specializes in fast rate calculations aimed at valuing fixed income contracts, with business-day-level accuracy.\nComparative comments: FinanceModels.jl does not try to provide as precise controls over the timing, structure, and interpolation of the curve. Instead, FinanceModels.jl provides a minimal, but flexible and intuitive interface for common modeling needs.","category":"section"},{"location":"extensions/#UnicodePlots.jl-for-Interactive-Session-Yield-Curve-Plotting","page":"Extensions","title":"UnicodePlots.jl for Interactive Session Yield Curve Plotting","text":"In interactive sessions (e.g. REPL, Notebooks, VS Code, etc.) you can get a pretty printing of yield curves by also using UnicodePlots.jl, for example:\n\njulia> using FinanceModels\njulia> q_rate = ZCBYield.([0.01, 0.02, 0.03,0.04,0.03],[1,3,5,10,20]);\njulia> fit(Spline.PolynomialSpline(3), q_rate, Fit.Bootstrap())\nFinanceModels.Yield.Spline{DataInterpolations.CubicSpline{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, true, Float64}}([0.009950330853168092, 0.009950330853168092, 0.019802627296179747, 0.02955880224154443, 0.0, 1.0, 2.0, 3.0])\n\njulia> using UnicodePlots \njulia> fit(Spline.PolynomialSpline(3), q_rate, Fit.Bootstrap()) # after importing UnicodePlots\n              ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Yield Curve (FinanceModels.Yield.Spline)⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀           \n              ┌────────────────────────────────────────────────────────────┐           \n         0.04 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⠤⠖⠒⠊⠉⠉⠉⠒⠒⠢⠤⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ Zero rates\n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⠔⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠑⠒⢄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠖⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠑⠢⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡔⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠒⢄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⢠⠎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠓⠤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⢠⠎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠑⠦⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⢠⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠓⠦⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀│           \n   Continuous │⠀⠀⠀⠀⠀⢠⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠒⠒⠦⠤⠤⠤⠤│           \n              │⠀⠀⠀⠀⢀⠎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⢀⡎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⢀⠎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠒⠒⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n            0 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              └────────────────────────────────────────────────────────────┘           \n              ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀time⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀30⠀           \n\n\n[!NOTE] This was built-in prior to v4.9 of FinanceModels. It has been split out to materially speed up using FinanceModels.","category":"section"},{"location":"extensions/#Makie-for-Cashflow-Plotting","page":"Extensions","title":"Makie for Cashflow Plotting","text":"A CashflowProjection or a vector of Cashflows can be plotted with the Makie family of plotting packages. For example:\n\nusing FinanceModels, CairoMakie\nproj = Projection(Bond.Fixed(0.10,Periodic(2),20),NullModel(),CashflowProjection())\n# a stem plot:\nstem(proj)\n\nWill produce:\n\n(Image: A stem plot of bond cashflows)","category":"section"}]
}

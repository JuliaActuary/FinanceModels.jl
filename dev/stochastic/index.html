<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Stochastic Models · FinanceModels.jl</title><meta name="title" content="Stochastic Models · FinanceModels.jl"/><meta property="og:title" content="Stochastic Models · FinanceModels.jl"/><meta property="twitter:title" content="Stochastic Models · FinanceModels.jl"/><meta name="description" content="Documentation for FinanceModels.jl."/><meta property="og:description" content="Documentation for FinanceModels.jl."/><meta property="twitter:description" content="Documentation for FinanceModels.jl."/><meta property="og:url" content="https://JuliaActuary.github.io/FinanceModels.jl/stochastic/"/><meta property="twitter:url" content="https://JuliaActuary.github.io/FinanceModels.jl/stochastic/"/><link rel="canonical" href="https://JuliaActuary.github.io/FinanceModels.jl/stochastic/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="FinanceModels.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">FinanceModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Guide</span><ul><li><a class="tocitem" href="../introduction/">Introduction</a></li><li><a class="tocitem" href="../models/">Models, Valuation, and Fitting</a></li><li class="is-active"><a class="tocitem" href>Stochastic Models</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Available-Models"><span>Available Models</span></a></li><li><a class="tocitem" href="#Constructing-Models"><span>Constructing Models</span></a></li><li><a class="tocitem" href="#Using-Stochastic-Models-as-Yield-Curves"><span>Using Stochastic Models as Yield Curves</span></a></li><li><a class="tocitem" href="#Calibrating-Models-with-fit"><span>Calibrating Models with <code>fit</code></span></a></li><li><a class="tocitem" href="#Monte-Carlo-Simulation"><span>Monte Carlo Simulation</span></a></li><li><a class="tocitem" href="#Mean-Reversion-Behaviour"><span>Mean Reversion Behaviour</span></a></li><li><a class="tocitem" href="#Gaussian-Model-Derivative-Pricing"><span>Gaussian Model Derivative Pricing</span></a></li><li><a class="tocitem" href="#Important-Notes"><span>Important Notes</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li></ul></li><li><a class="tocitem" href="../interpolation/">Interpolation Methods</a></li><li><a class="tocitem" href="../contracts/">Contracts</a></li><li><a class="tocitem" href="../Rates/">Rates</a></li><li><a class="tocitem" href="../migration/">Migration Guide</a></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../API/FinanceModels/">FinanceModels</a></li><li><a class="tocitem" href="../API/FinanceCore/">FinanceCore</a></li><li><a class="tocitem" href="../API/Spline/">Spline</a></li><li><a class="tocitem" href="../API/Fit/">Fit</a></li><li><a class="tocitem" href="../API/Yield/">Yield</a></li><li><a class="tocitem" href="../API/Bond/">Bond</a></li><li><a class="tocitem" href="../API/Equity/">Equity</a></li><li><a class="tocitem" href="../API/Option/">Option</a></li><li><a class="tocitem" href="../API/Volatility/">Volatility</a></li><li><a class="tocitem" href="../API/ShortRate/">ShortRate</a></li></ul></li><li><a class="tocitem" href="../faq/">FAQs</a></li><li><a class="tocitem" href="../extensions/">Extensions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Guide</a></li><li class="is-active"><a href>Stochastic Models</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Stochastic Models</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaActuary/FinanceModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaActuary/FinanceModels.jl/blob/master/docs/src/stochastic.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Stochastic-Interest-Rate-Models"><a class="docs-heading-anchor" href="#Stochastic-Interest-Rate-Models">Stochastic Interest Rate Models</a><a id="Stochastic-Interest-Rate-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Stochastic-Interest-Rate-Models" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>FinanceModels.jl includes stochastic short-rate models that are first-class yield models. Because Vasicek, Cox-Ingersoll-Ross (CIR), and Hull-White all have closed-form zero-coupon bond prices, they implement <code>discount(model, t)</code> analytically. This means the entire existing valuation infrastructure – <code>zero</code>, <code>forward</code>, <code>par</code>, <code>present_value</code>, and <code>fit</code> – works unchanged with these models.</p><p>For stochastic-cashflow analysis (e.g. Monte Carlo valuation), <code>simulate()</code> generates scenario yield curves that also plug into the existing <code>present_value</code>.</p><h2 id="Available-Models"><a class="docs-heading-anchor" href="#Available-Models">Available Models</a><a id="Available-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Available-Models" title="Permalink"></a></h2><table><tr><th style="text-align: left">Model</th><th style="text-align: left">Dynamics</th><th style="text-align: left">Parameters</th></tr><tr><td style="text-align: left"><a href="../API/ShortRate/#FinanceModels.ShortRate.Vasicek"><code>ShortRate.Vasicek</code></a></td><td style="text-align: left"><code>dr = a(b - r)dt + σ dW</code></td><td style="text-align: left"><code>a</code>, <code>b</code>, <code>σ</code>, <code>initial</code></td></tr><tr><td style="text-align: left"><a href="../API/ShortRate/#FinanceModels.ShortRate.CoxIngersollRoss"><code>ShortRate.CoxIngersollRoss</code></a></td><td style="text-align: left"><code>dr = a(b - r)dt + σ√r dW</code></td><td style="text-align: left"><code>a</code>, <code>b</code>, <code>σ</code>, <code>initial</code></td></tr><tr><td style="text-align: left"><a href="../API/ShortRate/#FinanceModels.ShortRate.HullWhite"><code>ShortRate.HullWhite</code></a></td><td style="text-align: left"><code>dr = (θ(t) - ar)dt + σ dW</code></td><td style="text-align: left"><code>a</code>, <code>σ</code>, <code>curve</code></td></tr></table><p>Where:</p><ul><li><code>a</code> is the speed of mean reversion</li><li><code>b</code> is the long-term mean rate</li><li><code>σ</code> is the volatility</li><li><code>initial</code> is the initial short rate <code>r₀</code> (a <code>Rate</code> or scalar)</li><li><code>curve</code> is an existing yield model (for Hull-White, which calibrates to an initial term structure)</li></ul><h2 id="Constructing-Models"><a class="docs-heading-anchor" href="#Constructing-Models">Constructing Models</a><a id="Constructing-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-Models" title="Permalink"></a></h2><h3 id="Vasicek"><a class="docs-heading-anchor" href="#Vasicek">Vasicek</a><a id="Vasicek-1"></a><a class="docs-heading-anchor-permalink" href="#Vasicek" title="Permalink"></a></h3><p>The Vasicek model is the simplest mean-reverting short-rate model. The short rate <code>r(t)</code> reverts to a long-term level <code>b</code> at speed <code>a</code>, with constant volatility <code>σ</code>.</p><pre><code class="language-julia hljs">using FinanceModels

v = ShortRate.Vasicek(0.136, 0.0168, 0.0119, Continuous(0.01))</code></pre><p>The <code>initial</code> rate can be passed as a scalar (interpreted as continuous) or as an explicit <code>Rate</code>:</p><pre><code class="language-julia hljs"># These are equivalent:
ShortRate.Vasicek(0.136, 0.0168, 0.0119, 0.01)
ShortRate.Vasicek(0.136, 0.0168, 0.0119, Continuous(0.01))</code></pre><h3 id="Cox-Ingersoll-Ross"><a class="docs-heading-anchor" href="#Cox-Ingersoll-Ross">Cox-Ingersoll-Ross</a><a id="Cox-Ingersoll-Ross-1"></a><a class="docs-heading-anchor-permalink" href="#Cox-Ingersoll-Ross" title="Permalink"></a></h3><p>The CIR model is similar to Vasicek but the volatility is proportional to <code>√r</code>, which prevents negative rates when the Feller condition <code>2ab &gt; σ²</code> is satisfied.</p><pre><code class="language-julia hljs">cir = ShortRate.CoxIngersollRoss(0.3, 0.05, 0.1, Continuous(0.03))</code></pre><h3 id="Hull-White"><a class="docs-heading-anchor" href="#Hull-White">Hull-White</a><a id="Hull-White-1"></a><a class="docs-heading-anchor-permalink" href="#Hull-White" title="Permalink"></a></h3><p>The Hull-White model takes an existing yield curve and adds stochastic dynamics. The drift is calibrated so that the model exactly reproduces the initial term structure.</p><pre><code class="language-julia hljs">curve = fit(Spline.Cubic(), CMTYield.([0.04, 0.05, 0.055, 0.06], [1, 5, 10, 30]), Fit.Bootstrap())
hw = ShortRate.HullWhite(0.1, 0.01, curve)

# discount factors match the initial curve exactly:
discount(hw, 10) == discount(curve, 10) # true</code></pre><h2 id="Using-Stochastic-Models-as-Yield-Curves"><a class="docs-heading-anchor" href="#Using-Stochastic-Models-as-Yield-Curves">Using Stochastic Models as Yield Curves</a><a id="Using-Stochastic-Models-as-Yield-Curves-1"></a><a class="docs-heading-anchor-permalink" href="#Using-Stochastic-Models-as-Yield-Curves" title="Permalink"></a></h2><p>Since these models implement <code>discount()</code>, all standard yield curve operations work:</p><pre><code class="language-julia hljs">v = ShortRate.Vasicek(0.136, 0.0168, 0.0119, Continuous(0.01))

# Discount factors (closed-form zero-coupon bond prices)
discount(v, 5)        # P(0, 5)
discount(v, 2, 10)    # P(2, 10)

# Zero rates
zero(v, 5)            # continuous zero rate at t=5

# Forward rates
forward(v, 2, 3)      # forward rate from t=2 to t=3

# Par yields
par(v, 10)            # par yield at t=10</code></pre><h3 id="Conditional-Discount-Factors"><a class="docs-heading-anchor" href="#Conditional-Discount-Factors">Conditional Discount Factors</a><a id="Conditional-Discount-Factors-1"></a><a class="docs-heading-anchor-permalink" href="#Conditional-Discount-Factors" title="Permalink"></a></h3><p>Stochastic models also support the <strong>conditional</strong> zero-coupon bond price <code>P(t, T | r(t) = r)</code> — the price at time <code>t</code> of a bond maturing at <code>T</code>, given that the short rate at <code>t</code> is <code>r</code>:</p><pre><code class="language-julia hljs">v = ShortRate.Vasicek(0.136, 0.0168, 0.0119, Continuous(0.01))

# P(2, 10 | r(2) = 0.04) under Vasicek
discount(v, 2.0, 10.0, 0.04)</code></pre><p>This is distinct from the 2-argument form <code>discount(v, 10)</code> which gives the <strong>unconditional</strong> <code>P(0, T)</code> from the initial term structure.</p><p>The conditional form is used internally for derivative pricing (swaption Jamshidian decomposition) and can be useful for scenario analysis where the short rate at a future time is known.</p><h3 id="Extracting-the-Short-Rate-from-a-Simulated-Path"><a class="docs-heading-anchor" href="#Extracting-the-Short-Rate-from-a-Simulated-Path">Extracting the Short Rate from a Simulated Path</a><a id="Extracting-the-Short-Rate-from-a-Simulated-Path-1"></a><a class="docs-heading-anchor-permalink" href="#Extracting-the-Short-Rate-from-a-Simulated-Path" title="Permalink"></a></h3><p>After simulation, you can extract the instantaneous short rate <code>r(t)</code> from a <code>RatePath</code> using <code>short_rate</code>:</p><pre><code class="language-julia hljs">scenarios = simulate(v; n_scenarios=10, timestep=1/12, horizon=10.0)
short_rate(scenarios[1], 5.0)  # r(5) for the first scenario</code></pre><h3 id="Valuing-Fixed-Income-Contracts"><a class="docs-heading-anchor" href="#Valuing-Fixed-Income-Contracts">Valuing Fixed-Income Contracts</a><a id="Valuing-Fixed-Income-Contracts-1"></a><a class="docs-heading-anchor-permalink" href="#Valuing-Fixed-Income-Contracts" title="Permalink"></a></h3><p>Since stochastic models are yield models, <code>present_value</code> works directly for deterministic-cashflow instruments:</p><pre><code class="language-julia hljs">v = ShortRate.Vasicek(0.136, 0.0168, 0.0119, Continuous(0.01))
bond = Bond.Fixed(0.05, Periodic(2), 10)

# Analytical present value using closed-form discount factors
present_value(v, bond)</code></pre><h2 id="Calibrating-Models-with-fit"><a class="docs-heading-anchor" href="#Calibrating-Models-with-fit">Calibrating Models with <code>fit</code></a><a id="Calibrating-Models-with-fit-1"></a><a class="docs-heading-anchor-permalink" href="#Calibrating-Models-with-fit" title="Permalink"></a></h2><p>Stochastic models support calibration via <code>fit</code>, using the same API as all other models. The optimizer uses ForwardDiff automatic differentiation to find parameters that best match observed market quotes.</p><pre><code class="language-julia hljs"># Observed market zero-coupon yields
quotes = ZCBYield.([0.02, 0.025, 0.03], [1, 5, 10])

# Initial guess
v0 = ShortRate.Vasicek(0.1, 0.02, 0.01, Continuous(0.01))

# Fit to market data
v_fitted = fit(v0, quotes)

# Verify: the fitted model reprices the quotes
map(q -&gt; present_value(v_fitted, q.instrument), quotes)</code></pre><p>The default parameter bounds for fitting are:</p><table><tr><th style="text-align: left">Model</th><th style="text-align: left"><code>a</code></th><th style="text-align: left"><code>b</code></th><th style="text-align: left"><code>σ</code></th><th style="text-align: left"><code>initial</code></th></tr><tr><td style="text-align: left">Vasicek</td><td style="text-align: left"><code>0.0 .. 5.0</code></td><td style="text-align: left"><code>-0.1 .. 0.5</code></td><td style="text-align: left"><code>0.0 .. 1.0</code></td><td style="text-align: left"><code>-0.05 .. 0.2</code></td></tr><tr><td style="text-align: left">CIR</td><td style="text-align: left"><code>0.0 .. 5.0</code></td><td style="text-align: left"><code>0.0 .. 0.5</code></td><td style="text-align: left"><code>0.0 .. 1.0</code></td><td style="text-align: left"><code>0.0 .. 0.2</code></td></tr><tr><td style="text-align: left">Hull-White</td><td style="text-align: left"><code>0.0 .. 5.0</code></td><td style="text-align: left">–</td><td style="text-align: left"><code>0.0 .. 1.0</code></td><td style="text-align: left">–</td></tr></table><p>Custom bounds can be passed via the <code>variables</code> keyword argument to <code>fit</code>.</p><h2 id="Monte-Carlo-Simulation"><a class="docs-heading-anchor" href="#Monte-Carlo-Simulation">Monte Carlo Simulation</a><a id="Monte-Carlo-Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Monte-Carlo-Simulation" title="Permalink"></a></h2><h3 id="Generating-Scenarios-with-simulate"><a class="docs-heading-anchor" href="#Generating-Scenarios-with-simulate">Generating Scenarios with <code>simulate</code></a><a id="Generating-Scenarios-with-simulate-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-Scenarios-with-simulate" title="Permalink"></a></h3><p><code>simulate</code> uses Euler-Maruyama discretisation to generate interest-rate paths. Each path is returned as a <a href="../API/FinanceModels/#FinanceModels.RatePath"><code>RatePath</code></a>, which is itself an <code>AbstractYieldModel</code> – so <code>discount</code>, <code>zero</code>, <code>forward</code>, <code>par</code>, and <code>present_value</code> all work on individual scenarios.</p><pre><code class="language-julia hljs">using Random

v = ShortRate.Vasicek(0.136, 0.0168, 0.0119, Continuous(0.01))

scenarios = simulate(v;
    n_scenarios = 1000,    # number of paths
    timestep    = 1/12,    # monthly steps
    horizon     = 30.0,    # 30-year horizon
    rng         = MersenneTwister(42),  # reproducible
)

length(scenarios)            # 1000
scenarios[1] isa RatePath    # true

# Each scenario is a full yield model:
discount(scenarios[1], 5)
zero(scenarios[1], 10)
present_value(scenarios[1], Bond.Fixed(0.05, Periodic(2), 10))</code></pre><h3 id="Monte-Carlo-Present-Value-with-pv_mc"><a class="docs-heading-anchor" href="#Monte-Carlo-Present-Value-with-pv_mc">Monte Carlo Present Value with <code>pv_mc</code></a><a id="Monte-Carlo-Present-Value-with-pv_mc-1"></a><a class="docs-heading-anchor-permalink" href="#Monte-Carlo-Present-Value-with-pv_mc" title="Permalink"></a></h3><p><code>pv_mc</code> is a convenience function that simulates scenarios and averages <code>present_value</code> across them:</p><pre><code class="language-julia hljs">v = ShortRate.Vasicek(0.136, 0.0168, 0.0119, Continuous(0.01))
bond = Bond.Fixed(0.05, Periodic(2), 10)

# Monte Carlo expected PV
mc = pv_mc(v, bond; n_scenarios=5000, timestep=1/12)

# Compare to analytical (closed-form) PV
analytical = present_value(v, bond)

# These should be close (within ~1-2% for 5000 scenarios)</code></pre><p>The signature is:</p><pre><code class="language-julia hljs">pv_mc(model, contract;
    n_scenarios = 1000,
    timestep    = 1/12,
    horizon     = nothing,   # defaults to maturity + 1
    rng         = Random.default_rng(),
)</code></pre><h3 id="Working-with-Individual-Scenarios"><a class="docs-heading-anchor" href="#Working-with-Individual-Scenarios">Working with Individual Scenarios</a><a id="Working-with-Individual-Scenarios-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-Individual-Scenarios" title="Permalink"></a></h3><p>Since each scenario is a yield model, you can do per-scenario analysis:</p><pre><code class="language-julia hljs">v = ShortRate.Vasicek(0.136, 0.0168, 0.0119, Continuous(0.01))
bond = Bond.Fixed(0.05, Periodic(2), 10)

scenarios = simulate(v; n_scenarios=1000, timestep=1/12, horizon=11.0)

# Distribution of present values
pvs = [present_value(sc, bond) for sc in scenarios]

# Percentiles
sort!(pvs)
p95 = pvs[950]   # 95th percentile PV
p05 = pvs[50]    # 5th percentile PV
mean_pv = sum(pvs) / length(pvs)</code></pre><h3 id="Projecting-Cashflows-Across-Scenarios"><a class="docs-heading-anchor" href="#Projecting-Cashflows-Across-Scenarios">Projecting Cashflows Across Scenarios</a><a id="Projecting-Cashflows-Across-Scenarios-1"></a><a class="docs-heading-anchor-permalink" href="#Projecting-Cashflows-Across-Scenarios" title="Permalink"></a></h3><p>For fixed-coupon bonds, the cashflows themselves don&#39;t change across scenarios – only the discount factors (and thus the present value) change. You can get the cashflows directly with <code>collect</code>:</p><pre><code class="language-julia hljs">bond = Bond.Fixed(0.05, Periodic(2), 3)
collect(bond)
# 6-element Vector{Cashflow}:
#  Cashflow(0.025, 0.5)
#  Cashflow(0.025, 1.0)
#  ...
#  Cashflow(1.025, 3.0)</code></pre><p>For <strong>floating-rate bonds</strong>, the cashflows depend on forward rates, which differ across scenarios. Use <code>Projection</code> with a <code>Dict</code> mapping the reference rate key to the scenario&#39;s yield model:</p><pre><code class="language-julia hljs">using FinanceModels, Random

v = ShortRate.Vasicek(0.136, 0.0168, 0.0119, Continuous(0.01))
scenarios = simulate(v; n_scenarios=3, timestep=1/12, horizon=4.0,
                     rng=MersenneTwister(42))

# Floating bond: 2% spread over &quot;SOFR&quot;, semiannual, 3-year
bond_float = Bond.Floating(0.02, Periodic(2), 3.0, &quot;SOFR&quot;)

for (i, sc) in enumerate(scenarios)
    proj = Projection(bond_float, Dict(&quot;SOFR&quot; =&gt; sc), CashflowProjection())
    cfs = collect(proj)
    println(&quot;Scenario $i cashflows:&quot;)
    for cf in cfs
        println(&quot;  t=$(cf.time): $(round(cf.amount; digits=4))&quot;)
    end
end
# Each scenario produces different coupon amounts because the
# forward rates from each RatePath are different.</code></pre><p>This also works with composite contracts like interest rate swaps, where the floating leg references a scenario:</p><pre><code class="language-julia hljs">curve = Yield.Constant(0.05)
swap = InterestRateSwap(curve, 5)

sc = scenarios[1]
proj = Projection(swap, Dict(&quot;OIS&quot; =&gt; sc), CashflowProjection())
cfs = collect(proj)  # net cashflows (received fixed, paid floating)</code></pre><h2 id="Mean-Reversion-Behaviour"><a class="docs-heading-anchor" href="#Mean-Reversion-Behaviour">Mean Reversion Behaviour</a><a id="Mean-Reversion-Behaviour-1"></a><a class="docs-heading-anchor-permalink" href="#Mean-Reversion-Behaviour" title="Permalink"></a></h2><p>A key feature of these models is mean reversion. With strong mean reversion (<code>a</code> large), the long-term zero rate converges to <code>b</code>:</p><pre><code class="language-julia hljs"># Strong mean reversion: long-term rate approaches b=0.05
v_strong = ShortRate.Vasicek(2.0, 0.05, 0.01, Continuous(0.10))
zero(v_strong, 30)  # close to Continuous(0.05)

# Weak mean reversion: initial rate persists longer
v_weak = ShortRate.Vasicek(0.01, 0.05, 0.01, Continuous(0.10))
zero(v_weak, 30)    # still far from 0.05</code></pre><h2 id="Gaussian-Model-Derivative-Pricing"><a class="docs-heading-anchor" href="#Gaussian-Model-Derivative-Pricing">Gaussian Model Derivative Pricing</a><a id="Gaussian-Model-Derivative-Pricing-1"></a><a class="docs-heading-anchor-permalink" href="#Gaussian-Model-Derivative-Pricing" title="Permalink"></a></h2><p>Both the Vasicek and Hull-White models are Gaussian short-rate models and share the same closed-form ZCB option formula (Black&#39;s formula). This means all derivative pricing — ZCB options, caps, floors, and swaptions — works identically for both models.</p><p>For Hull-White, since <code>discount(hw, t)</code> simply returns the initial curve&#39;s discount factor (the model is calibrated to match the curve exactly), bond prices alone cannot identify <code>a</code> and <code>σ</code>. Instead, Hull-White is typically calibrated to <strong>derivative prices</strong> — caps, floors, swaptions, or zero-coupon bond options.</p><h3 id="Zero-Coupon-Bond-Options"><a class="docs-heading-anchor" href="#Zero-Coupon-Bond-Options">Zero-Coupon Bond Options</a><a id="Zero-Coupon-Bond-Options-1"></a><a class="docs-heading-anchor-permalink" href="#Zero-Coupon-Bond-Options" title="Permalink"></a></h3><pre><code class="language-julia hljs">curve = Yield.Constant(Continuous(0.05))
hw = ShortRate.HullWhite(0.1, 0.015, curve)

# Call on a ZCB: right to buy at time T=1 a ZCB maturing at S=5 for strike K
call = present_value(hw, Option.ZCBCall(1.0, 5.0, 0.75))
put  = present_value(hw, Option.ZCBPut(1.0, 5.0, 0.75))</code></pre><h3 id="Caps-and-Floors"><a class="docs-heading-anchor" href="#Caps-and-Floors">Caps and Floors</a><a id="Caps-and-Floors-1"></a><a class="docs-heading-anchor-permalink" href="#Caps-and-Floors" title="Permalink"></a></h3><p>A cap is a portfolio of caplets, each paying <code>max(L - K, 0) · τ</code> where <code>L</code> is the simply-compounded forward rate. Under Hull-White, each caplet is equivalent to a scaled put on a zero-coupon bond.</p><pre><code class="language-julia hljs">hw = ShortRate.HullWhite(0.03, 0.02, Yield.Constant(Continuous(0.01)))

# 3% strike, quarterly resets, 2-year maturity
cap = present_value(hw, Option.Cap(0.03, 4, 2.0))
flr = present_value(hw, Option.Floor(0.03, 4, 2.0))</code></pre><p>Cap-floor parity holds: <code>Cap(K) - Floor(K) = forward swap value</code>.</p><h3 id="Swaptions"><a class="docs-heading-anchor" href="#Swaptions">Swaptions</a><a id="Swaptions-1"></a><a class="docs-heading-anchor-permalink" href="#Swaptions" title="Permalink"></a></h3><p>A European swaption gives the right to enter a swap at expiry. Pricing uses the Jamshidian (1989) decomposition into zero-coupon bond options.</p><pre><code class="language-julia hljs">hw = ShortRate.HullWhite(0.03, 0.02, Yield.Constant(Continuous(0.01)))

# 1y into 4y payer swaption, 1.1% strike, quarterly
payer = present_value(hw, Option.Swaption(1.0, 5.0, 0.011, 4; payer=true))

# Receiver swaption
receiver = present_value(hw, Option.Swaption(1.0, 5.0, 0.011, 4; payer=false))</code></pre><h3 id="Calibrating-Hull-White-to-Derivatives"><a class="docs-heading-anchor" href="#Calibrating-Hull-White-to-Derivatives">Calibrating Hull-White to Derivatives</a><a id="Calibrating-Hull-White-to-Derivatives-1"></a><a class="docs-heading-anchor-permalink" href="#Calibrating-Hull-White-to-Derivatives" title="Permalink"></a></h3><p>With derivative pricing, <code>fit</code> can calibrate Hull-White&#39;s <code>a</code> and <code>σ</code> to market swaption or cap prices:</p><pre><code class="language-julia hljs">curve = Yield.Constant(Continuous(0.03))

# Initial guess
hw0 = ShortRate.HullWhite(0.05, 0.01, curve)

# Market swaption prices (here generated from a &quot;true&quot; model)
hw_true = ShortRate.HullWhite(0.1, 0.015, curve)
instruments = [
    Option.Swaption(1.0, 6.0, 0.03, 2),
    Option.Swaption(2.0, 7.0, 0.03, 2),
    Option.Swaption(3.0, 8.0, 0.03, 2),
]
quotes = [Quote(present_value(hw_true, inst), inst) for inst in instruments]

# Calibrate
hw_fit = fit(hw0, quotes)</code></pre><h2 id="Important-Notes"><a class="docs-heading-anchor" href="#Important-Notes">Important Notes</a><a id="Important-Notes-1"></a><a class="docs-heading-anchor-permalink" href="#Important-Notes" title="Permalink"></a></h2><h3 id="Model-Behaviour"><a class="docs-heading-anchor" href="#Model-Behaviour">Model Behaviour</a><a id="Model-Behaviour-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Behaviour" title="Permalink"></a></h3><ul><li><strong>CIR Feller condition:</strong> The CIR model requires <code>2ab &gt; σ²</code> for the short rate to stay strictly positive. When this condition is violated, the rate can reach zero. The simulation uses the full truncation scheme (absorption at zero) in that case.</li><li><strong>Vasicek negative rates:</strong> The Vasicek model allows negative rates by design. For very negative rates or long horizons, discount factors may exceed 1 (equivalently, zero rates are negative). This is consistent with observed negative-rate environments.</li></ul><h3 id="Performance-Guidance"><a class="docs-heading-anchor" href="#Performance-Guidance">Performance Guidance</a><a id="Performance-Guidance-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Guidance" title="Permalink"></a></h3><ul><li><code>simulate</code> allocates one <code>LinearInterpolation</code> per scenario. For 100k scenarios with a 30-year monthly horizon, expect execution times on the order of seconds.</li><li><code>pv_mc</code> is embarrassingly parallel across scenarios but is not parallelised internally. For large-scale simulations, users can parallelise with <code>Threads.@threads</code> or <code>Distributed</code>:</li></ul><pre><code class="language-julia hljs">using Base.Threads

scenarios = simulate(v; n_scenarios=100_000, timestep=1/12, horizon=31.0)
pvs = Vector{Float64}(undef, length(scenarios))
@threads for i in eachindex(scenarios)
    pvs[i] = present_value(scenarios[i], bond)
end
mean_pv = sum(pvs) / length(pvs)</code></pre><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>discount(model, t)</code></td><td style="text-align: left">Closed-form ZCB price <code>P(0,t)</code></td></tr><tr><td style="text-align: left"><code>discount(model, t, T, r_t)</code></td><td style="text-align: left">Conditional ZCB price <code>P(t,T | r(t)=r)</code></td></tr><tr><td style="text-align: left"><code>zero(model, t)</code></td><td style="text-align: left">Continuous zero rate at <code>t</code></td></tr><tr><td style="text-align: left"><code>forward(model, t1, t2)</code></td><td style="text-align: left">Forward rate from <code>t1</code> to <code>t2</code></td></tr><tr><td style="text-align: left"><code>par(model, t)</code></td><td style="text-align: left">Par yield at <code>t</code></td></tr><tr><td style="text-align: left"><code>present_value(model, contract)</code></td><td style="text-align: left">Analytical present value</td></tr><tr><td style="text-align: left"><code>present_value(m, Option.ZCBCall(...))</code></td><td style="text-align: left">Vasicek/Hull-White ZCB option price</td></tr><tr><td style="text-align: left"><code>present_value(m, Option.Cap(...))</code></td><td style="text-align: left">Vasicek/Hull-White cap price</td></tr><tr><td style="text-align: left"><code>present_value(m, Option.Swaption(...))</code></td><td style="text-align: left">Vasicek/Hull-White swaption price</td></tr><tr><td style="text-align: left"><code>fit(model, quotes)</code></td><td style="text-align: left">Calibrate to market data</td></tr><tr><td style="text-align: left"><code>simulate(model; ...)</code></td><td style="text-align: left">Generate <code>Vector{RatePath}</code> scenarios</td></tr><tr><td style="text-align: left"><code>pv_mc(model, contract; ...)</code></td><td style="text-align: left">Monte Carlo expected present value</td></tr><tr><td style="text-align: left"><code>short_rate(path, t)</code></td><td style="text-align: left">Extract <code>r(t)</code> from a simulated <code>RatePath</code></td></tr></table></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../models/">« Models, Valuation, and Fitting</a><a class="docs-footer-nextpage" href="../interpolation/">Interpolation Methods »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 16 February 2026 06:01">Monday 16 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

var documenterSearchIndex = {"docs":
[{"location":"api/#Yields-API-Reference","page":"API Reference","title":"Yields API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Please open an issue if you encounter any issues or confusion with the package.","category":"page"},{"location":"api/#Rate-Types","page":"API Reference","title":"Rate Types","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"When JuliaActuary packages return a rate, they will be of a Rate type, such as Rate(0.05,Periodic(2)) for a 5% rate compounded twice per period. It is recommended to keep rates typed and use them throughout the ecosystem without modifying it. ","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"For example, if we construct a curve like this:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"# 2021-03-31 rates from Treasury.gov\nrates =[0.01, 0.01, 0.03, 0.05, 0.07, 0.16, 0.35, 0.92, 1.40, 1.74, 2.31, 2.41] ./ 100\nmats = [1/12, 2/12, 3/12, 6/12, 1, 2, 3, 5, 7, 10, 20, 30]\n  \ncurve = Yields.CMT(rates,mats)","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Then rates from this curve will be typed. For example:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"z = zero(c,10)","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Now, z will be: Yields.Rate{Float64, Continuous}(0.01779624378877313, Continuous())","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"This Rate has both the rate an the compounding convention embedded in the datatype.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"You can now use that rate throughout the JuliaActuary ecosystem, such as with ActuaryUtilities.jl:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"using ActuaryUtilities\npresent_values(z,cashflows)","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"If you need to extract the rate for some reason, you can get the rate by calling Yields.rate(...). Using the above example, Yields.rate(z) will return 0.01779624378877313. ","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [Yields]","category":"page"},{"location":"api/#Yields.Bootstrap","page":"API Reference","title":"Yields.Bootstrap","text":"Boostrap(interpolation_method=QuadraticSpline)\n\nThis YieldCurveFitParameters object defines the interpolation method to use when bootstrapping the curve. Provided options are QuadraticSpline() (the default) and LinearSpline(). You may also pass a custom interpolation method with the function signature of f(xs, ys) -> f(x) -> y.\n\nIf constructing curves and the rates are not Rates (ie you pass a Vector{Float64}), then they will be interpreted as Periodic(1) Rates, except the Par curve, which is interpreted as Periodic(2) Rates. CMT and OIS FinanceCore.CompoundingFrequency assumption depends on the corresponding maturity.\n\nSee for more:\n\nZero\nForward\nPar\nCMT\nOIS\n\n\n\n\n\n","category":"type"},{"location":"api/#Yields.BulletBondQuote","page":"API Reference","title":"Yields.BulletBondQuote","text":"BulletBondQuote(yield, price, maturity, frequency)\n\nQuote for a set of fixed interest bullet bonds with given yield, price, maturity and a given payment frequency frequency.\n\nConstruct a vector of quotes for use with SmithWilson methods, e.g. by broadcasting over an array of inputs.\n\nExamples\n\njulia> maturities = [1.2, 2.5, 3.6]\njulia> interests = [-0.02, 0.3, 0.04]\njulia> prices = [1.3, 0.1, 4.5]\njulia> frequencies = [2,1,2]\njulia> bbq = Yields.BulletBondQuote.(interests, maturities, prices, frequencies)\n\n\n\n\n\n","category":"type"},{"location":"api/#Yields.Constant","page":"API Reference","title":"Yields.Constant","text":"Constant(rate::Real, cf::CompoundingFrequency=Periodic(1))\nConstant(r::Rate)\n\nConstruct a yield object where the spot rate is constant for all maturities. If rate is not a Rate type, will assume Periodic(1) for the compounding frequency\n\nExamples\n\njulia> y = Yields.Constant(0.05)\njulia> FinanceCore.discount(y,2)\n0.9070294784580498     # 1 / (1.05) ^ 2\n\n\n\n\n\n","category":"type"},{"location":"api/#Yields.ForwardStarting","page":"API Reference","title":"Yields.ForwardStarting","text":"ForwardStarting(curve,forwardstart)\n\nRebase a curve so that discount/accumulation/etc. are re-based so that time zero from the new curves perspective is the given forwardstart time.\n\nExamples\n\njulia> zero = [5.0, 5.8, 6.4, 6.8] ./ 100\njulia> maturity = [0.5, 1.0, 1.5, 2.0]\njulia> curve = Yields.Zero(zero, maturity)\njulia> fwd = Yields.ForwardStarting(curve, 1.0)\n\njulia> FinanceCore.discount(curve,1,2)\n0.9275624570410582\n\njulia> FinanceCore.discount(fwd,1) # `curve` has effectively been reindexed to `1.0`\n0.9275624570410582\n\nExtended Help\n\nWhile ForwardStarting could be nested so that, e.g. the third period's curve is the one-period forward of the second period's curve, it will be more efficient to reuse the initial curve from a runtime and compiler perspective.\n\nForwardStarting is not used to construct a curve based on forward rates. See  Forward instead.\n\n\n\n\n\n","category":"type"},{"location":"api/#Yields.NelsonSiegel","page":"API Reference","title":"Yields.NelsonSiegel","text":"NelsonSiegel(τ_initial)\nNelsonSiegel() # defaults to τ_initial=1.0\n\nThis parameter set is used to fit the Nelson-Siegel parametric model to given rates. τ_initial should be a scalar and is used as the starting τ value in the optimization. The default value for τ_initial is 1.0.\n\nWhen fitting rates using this YieldCurveFitParameters object, the Nelson-Siegel model is used. If constructing curves and the rates are not Rates (ie you pass a Vector{Float64}), then they will be interpreted as Continuous Rates.\n\nSee for more:\n\nZero\nForward\nPar\nCMT\nOIS\n\n\n\n\n\n","category":"type"},{"location":"api/#Yields.NelsonSiegelCurve","page":"API Reference","title":"Yields.NelsonSiegelCurve","text":"NelsonSiegel(rates::AbstractVector, maturities::AbstractVector; τ_initial=1.0)\n\nReturn the NelsonSiegel fitted parameters. The rates should be zero spot rates. If rates are not Rates, then they will be interpreted as Continuous Rates.\n\nNelsonSiegel(β₀, β₁, β₂, τ₁)\n\nParameters of Nelson and Siegel (1987) parametric model:\n\nβ₀ represents a long-term interest rate\nβ₁ represents a time-decay component\nβ₂ represents a hump\nτ₁ controls the location of the hump\n\nExamples\n\njulia> β₀, β₁, β₂, τ₁ = 0.6, -1.2, -1.9, 3.0\njulia> nsm = Yields.NelsonSiegel.(β₀, β₁, β₂, τ₁)\n\n# Extend Help\n\n## References\n- https://onriskandreturn.com/2019/12/01/nelson-siegel-yield-curve-model/\n- https://www.bis.org/publ/bppdf/bispap25.pdf\n\n\n\n\n\n\n","category":"type"},{"location":"api/#Yields.NelsonSiegelSvensson","page":"API Reference","title":"Yields.NelsonSiegelSvensson","text":"NelsonSiegelSvensson(τ_initial) \nNelsonSiegelSvensson() # defaults to τ_initial=[1.0,1.0]\n\nThis parameter set is used to fit the Nelson-Siegel parametric model to given rates. τ_initial should be a two element vector and is used as the starting τ value in the optimization. The default value for τ_initial is [1.0,1.0].\n\nSee for more:\n\nZero\nForward\nPar\nCMT\nOIS\n\n\n\n\n\n","category":"type"},{"location":"api/#Yields.NelsonSiegelSvenssonCurve","page":"API Reference","title":"Yields.NelsonSiegelSvenssonCurve","text":"NelsonSiegelSvensson(yields::AbstractVector, maturities::AbstractVector; τ_initial=[1.0,1.0])\n\nReturn the NelsonSiegelSvensson fitted parameters. The rates should be continuous zero spot rates. If rates are not Rates, then they will be interpreted as Continuous Rates.\n\nWhen fitting rates using this YieldCurveFitParameters object, the Nelson-Siegel model is used. If constructing curves and the rates are not Rates (ie you pass a Vector{Float64}), then they will be interpreted as Continuous Rates.\n\nSee for more:\n\n- [`Zero`](@ref)\n- [`Forward`](@ref)\n- [`Par`](@ref)\n- [`CMT`](@ref)\n- [`OIS`](@ref)\n\nNelsonSiegelSvensson(β₀, β₁, β₂, β₃, τ₁, τ₂)\n\nParameters of Svensson (1994) parametric model:\n\nβ₀ represents a long-term interest rate\nβ₁ represents a time-decay component\nβ₂ represents a hump\nβ₃ represents a second hum\nτ₁ controls the location of the hump \nτ₁ controls the location of the second hump \n\nExamples\n\njulia> β₀, β₁, β₂, β₃, τ₁, τ₂ = 0.6, -1.2, -2.1, 3.0, 1.5\njulia> nssm = NelsonSiegelSvensson.NelsonSiegelSvensson.(β₀, β₁, β₂, β₃, τ₁, τ₂)\n\n## References\n- https://onriskandreturn.com/2019/12/01/nelson-siegel-yield-curve-model/\n- https://www.bis.org/publ/bppdf/bispap25.pdf\n\n\n\n\n\n\n","category":"type"},{"location":"api/#Yields.RateCombination","page":"API Reference","title":"Yields.RateCombination","text":"RateCombination(curve1,curve2,operation)\n\nCreates a datastructure that will perform the given operation after independently calculating the effects of the two curves.  Can only be created via the public API by using the +, -, *, and / operatations on AbstractYield objects.\n\nAs this is double the normal operations when performing calculations, if you are using the curve in performance critical locations, you should consider transforming the inputs and  constructing a single curve object ahead of time.\n\n\n\n\n\n","category":"type"},{"location":"api/#Yields.SmithWilson","page":"API Reference","title":"Yields.SmithWilson","text":"SmithWilson(zcq::Vector{ZeroCouponQuote}; ufr, α)\nSmithWilson(swq::Vector{SwapQuote}; ufr, α)\nSmithWilson(bbq::Vector{BulletBondQuote}; ufr, α)\nSmithWilson(times<:AbstractVector, cashflows<:AbstractMatrix, prices<:AbstractVector; ufr, α)\nSmithWilson(u, qb; ufr, α)\n\nCreate a yield curve object that implements the Smith-Wilson interpolation/extrapolation scheme.\n\nPositional arguments to construct a curve:\n\nQuoted instrument as the first argument: either a Vector of ZeroCouponQuotes, SwapQuotes, or BulletBondQuotes, or \nA set of times, cashflows, and prices, or\nA curve can be with u is the timepoints coming from the calibration, and qb is the internal parameterization of the curve that ensures that the calibration is correct. Users may prefer the other constructors but this mathematical constructor is also available.\n\nRequired keyword arguments:\n\nufr is the Ultimate Forward Rate, the forward interest rate to which the yield curve tends, in continuous compounding convention. \nα is the parameter that governs the speed of convergence towards the Ultimate Forward Rate. It can be typed with \\alpha[TAB]\n\n\n\n\n\n","category":"type"},{"location":"api/#Yields.Step","page":"API Reference","title":"Yields.Step","text":"Step(rates,times)\n\nCreate a yield curve object where the applicable rate is the effective rate of interest applicable until corresponding time. If rates is not a Vector{Rate}, will assume Periodic(1) type.\n\nThe last rate will be applied to any time after the last time in times.\n\nExamples\n\njulia>y = Yields.Step([0.02,0.05], [1,2])\n\njulia>rate(y,0.5)\n0.02\n\njulia>rate(y,1.5)\n0.05\n\njulia>rate(y,2.5)\n0.05\n\n\n\n\n\n","category":"type"},{"location":"api/#Yields.SwapQuote","page":"API Reference","title":"Yields.SwapQuote","text":"SwapQuote(yield, maturity, frequency)\n\nQuote for a set of interest rate swaps with the given yield and maturity and a given payment frequency.\n\nExamples\n\njulia> maturities = [1.2, 2.5, 3.6]\njulia> interests = [-0.02, 0.3, 0.04]\njulia> prices = [1.3, 0.1, 4.5]\njulia> frequencies = [2,1,2]\njulia> swq = Yields.SwapQuote.(interests, maturities, frequencies)\n\n\n\n\n\n","category":"type"},{"location":"api/#Yields.YieldCurveFitParameters","page":"API Reference","title":"Yields.YieldCurveFitParameters","text":"A YieldCurveFitParameters is a structure which contains associated parameters for a yield curve fitting procedure. The type of the object determines the method, and the values of the object determine the parameters.\n\nIf the fitting data and the rates are passed as <:Real numbers instead of a type of Rates, the default interpretation may vary depending on the fitting type/parameter. See the individual docstrings of the types for more information.\n\nAvailable types are:\n\nBootstrap\nNelsonSiegel\nNelsonSiegelSvensson\n\n\n\n\n\n","category":"type"},{"location":"api/#Yields.ZeroCouponQuote","page":"API Reference","title":"Yields.ZeroCouponQuote","text":"ZeroCouponQuote(price, maturity)\n\nQuote for a set of zero coupon bonds with given price and maturity. \n\nExamples\n\njulia> prices = [1.3, 0.1, 4.5]\njulia> maturities = [1.2, 2.5, 3.6]\njulia> swq = Yields.ZeroCouponQuote.(prices, maturities)\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.:*-Tuple{Yields.AbstractYieldCurve, Yields.AbstractYieldCurve}","page":"API Reference","title":"Base.:*","text":"Yields.AbstractYieldCurve * Yields.AbstractYieldCurve\n\nThe multiplication of two yields will create a RateCombination. For rate, discount, and accumulation purposes the spot rates of the two curves will be added together. This can be useful, for example, if you wanted to after-tax a yield.\n\nExamples\n\njulia> m = Yields.Constant(0.01) * 0.79;\n\njulia> accumulation(m,1)\n1.0079\n\njulia> accumulation(.01*.79,1)\n1.0079\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:+-Tuple{Yields.AbstractYieldCurve, Yields.AbstractYieldCurve}","page":"API Reference","title":"Base.:+","text":"Yields.AbstractYieldCurve + Yields.AbstractYieldCurve\n\nThe addition of two yields will create a RateCombination. For rate, discount, and accumulation purposes the spot rates of the two curves will be added together.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:--Tuple{Yields.AbstractYieldCurve, Yields.AbstractYieldCurve}","page":"API Reference","title":"Base.:-","text":"Yields.AbstractYieldCurve - Yields.AbstractYieldCurve\n\nThe subtraction of two yields will create a RateCombination. For rate, discount, and accumulation purposes the spot rates of the second curves will be subtracted from the first.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:/-Tuple{Yields.AbstractYieldCurve, Yields.AbstractYieldCurve}","page":"API Reference","title":"Base.:/","text":"Yields.AbstractYieldCurve / Yields.AbstractYieldCurve\n\nThe division of two yields will create a RateCombination. For rate, discount, and accumulation purposes the spot rates of the two curves will have the first divided by the second. This can be useful, for example, if you wanted to gross-up a yield to be pre-tax.\n\nExamples\n\njulia> m = Yields.Constant(0.01) / 0.79;\n\njulia> accumulation(d,1)\n1.0126582278481013\n\njulia> accumulation(.01/.79,1)\n1.0126582278481013\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.zero-Union{Tuple{YC}, Tuple{YC, Any}} where YC<:Yields.AbstractYieldCurve","page":"API Reference","title":"Base.zero","text":"zero(curve,time)\nzero(curve,time,CompoundingFrequency)\n\nReturn the zero rate for the curve at the given time.\n\n\n\n\n\n","category":"method"},{"location":"api/#FinanceCore.accumulation-Tuple{Yields.AbstractYieldCurve, Any}","page":"API Reference","title":"FinanceCore.accumulation","text":"accumulation(yc, from, to)\n\nThe accumulation factor for the yield curve yc for times from through to.\n\n\n\n\n\n","category":"method"},{"location":"api/#FinanceCore.discount-Union{Tuple{T}, Tuple{T, Any, Any}} where T<:Yields.AbstractYieldCurve","page":"API Reference","title":"FinanceCore.discount","text":"discount(yc, to)\ndiscount(yc, from,to)\n\nThe discount factor for the yield curve yc for times from through to.\n\n\n\n\n\n","category":"method"},{"location":"api/#FinanceCore.forward-Union{Tuple{T}, Tuple{T, Any, Any}} where T<:Yields.AbstractYieldCurve","page":"API Reference","title":"FinanceCore.forward","text":"forward(yc, from, to, CompoundingFrequency=Periodic(1))\n\nThe forward Rate implied by the yield curve yc between times from and to.\n\n\n\n\n\n","category":"method"},{"location":"api/#Yields.CMT","page":"API Reference","title":"Yields.CMT","text":"Yields.CMT(rates, maturities; interpolation=QuadraticSpline())\nYields.CMT(p::YieldCurveFitParameters,rates, maturities)\n\nTakes constant maturity (treasury) yields (bond equivalent), and assumes that instruments <= one year maturity pay no coupons and that the rest pay semi-annual.\n\nThe method of fitting the curve to the data is determined by the YieldCurveFitParameters object p, which is a Boostrap(QuadraticSpline()) by default. \n\nExamples\n\n# 2021-03-31 rates from Treasury.gov\nrates =[0.01, 0.01, 0.03, 0.05, 0.07, 0.16, 0.35, 0.92, 1.40, 1.74, 2.31, 2.41] ./ 100\nmats = [1/12, 2/12, 3/12, 6/12, 1, 2, 3, 5, 7, 10, 20, 30]\n\t\nYields.CMT(rates,mats)\n\n\n\n\n\n","category":"function"},{"location":"api/#Yields.Forward","page":"API Reference","title":"Yields.Forward","text":"Forward(rates,maturities=eachindex(rates))\nForward(p::YieldCurveFitParameters, rates,maturities=eachindex(rates))\n\nTakes a vector of 1-period forward rates and constructs a discount curve. The method of fitting the curve to the data is determined by the YieldCurveFitParameters object p, which is a Boostrap(QuadraticSpline()) by default. \n\nIf rates is a vector of floating point number instead of a vector Rates, see the YieldCurveFitParameters for how the rate will be interpreted.\n\nExamples\n\njulia> Yields.Forward( [0.01,0.02,0.03] );\n\njulia> Yields.Forward( Yields.Continuous.([0.01,0.02,0.03]) );\n\n\n\n\n\n\n","category":"function"},{"location":"api/#Yields.H-Union{Tuple{T}, Tuple{Any, T, T}} where T","page":"API Reference","title":"Yields.H","text":"H(α, t1, t2)\n\nThe Smith-Wilson H function implemented in a faster way.\n\n\n\n\n\n","category":"method"},{"location":"api/#Yields.H_ordered-Tuple{Any, Any, Any}","page":"API Reference","title":"Yields.H_ordered","text":"H_ordered(α, t_min, t_max)\n\nThe Smith-Wilson H function with ordered arguments (for better performance than using min and max).\n\n\n\n\n\n","category":"method"},{"location":"api/#Yields.OIS","page":"API Reference","title":"Yields.OIS","text":"OIS(rates, maturities)\nOIS(p::YieldCurveFitParameters, rates, maturities)\n\nTakes Overnight Index Swap rates, and assumes that instruments <= one year maturity are settled once and other agreements are settled quarterly with a corresponding CompoundingFrequency.\n\nThe method of fitting the curve to the data is determined by the YieldCurveFitParameters object p, which is a Boostrap(QuadraticSpline()) by default. \n\nExamples\n\njulia> ois = [1.8, 2.0, 2.2, 2.5, 3.0, 4.0] ./ 100;\njulia> mats = [1 / 12, 1 / 4, 1 / 2, 1, 2, 5];\njulia> curve = Yields.OIS(ois, mats)\n\n              ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Yield Curve (Yields.BootstrapCurve)⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀           \n              ┌────────────────────────────────────────────────────────────┐           \n          0.1 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ Zero rates\n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⡤│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⡤⠔⠒⠋⠁⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⡤⠔⠒⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⡤⠔⠒⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⡤⠔⠒⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⡤⠔⠒⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n   Continuous │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⡤⠔⠒⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⡤⠔⠒⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⡤⠔⠒⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⡠⠔⠊⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⣀⠔⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⡠⠎⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠜⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n         0.01 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              └────────────────────────────────────────────────────────────┘           \n              ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀time⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀30⠀   \n\n\n\n\n\n","category":"function"},{"location":"api/#Yields.Par","page":"API Reference","title":"Yields.Par","text":"Par(rates, maturities=eachindex(rates)\nPar(p::YieldCurveFitParameters, rates, maturities=eachindex(rates)\n\nConstruct a curve given a set of bond equivalent yields and the corresponding maturities. Assumes that maturities <= 1 year do not pay coupons and that after one year, pays coupons with frequency equal to the CompoundingFrequency of the corresponding rate (normally the default for a Rate is 1, but when constructed via Par the default compounding Frequency is 2).\n\nSee bootstrap for more on the interpolation parameter, which is set to QuadraticSpline() by default.\n\nExamples\n\n\njulia> par = [6.,8.,9.5,10.5,11.0,11.25,11.38,11.44,11.48,11.5] ./ 100\njulia> maturities = [t for t in 1:10]\njulia> curve = Par(par,maturities);\njulia> zero(curve,1)\nRate(0.06000000000000005, Periodic(1))\n\n\n\n\n\n\n","category":"function"},{"location":"api/#Yields.Zero","page":"API Reference","title":"Yields.Zero","text":"Zero(rates, maturities=eachindex(rates))\nZero(p::YieldCurveFitParameters,rates, maturities=eachindex(rates))\n\nConstruct a yield curve with given zero-coupon spot rates at the given maturities. The method of fitting the curve to the data is determined by the YieldCurveFitParameters object p, which is a Boostrap(QuadraticSpline()) by default. \n\nIf rates is a vector of floating point number instead of a vector Rates, see the YieldCurveFitParameters for how the rate will be interpreted.\n\nExamples\n\njulia> Yields.Zero([0.01,0.02,0.04,0.05],[1,2,5,10])\n\n              ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Yield Curve (Yields.BootstrapCurve)⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀           \n              ┌────────────────────────────────────────────────────────────┐           \n         0.05 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡠⠤⠒⠒⠒⠒⠒⠤⠤⠤⢄⣀⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ Zero rates\n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⠖⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠉⠉⠒⠒⠒⠢⠤⠤⠤⣄⣀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠖⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠉⠑⠒⠒⠒⠦⠤⠤⠤⣀⣀⣀⡀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⡔⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉│           \n              │⠀⠀⠀⠀⠀⠀⠀⢠⠎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⢠⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⢠⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n   Continuous │⠀⠀⠀⠀⢀⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⡜⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⡸⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⢠⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⡜⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠒⠒⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n            0 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│           \n              └────────────────────────────────────────────────────────────┘           \n              ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀time⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀30⠀      \n\n\n\n\n\n\n","category":"function"},{"location":"api/#Yields.bootstrap","page":"API Reference","title":"Yields.bootstrap","text":"bootstrap(rates, maturities, settlement_frequency, interpolation::QuadraticSpline())\n\nBootstrap the rates with the given maturities, treating the rates according to the periodic frequencies in settlement_frequency. \n\ninterpolator is any function that will take two vectors of inputs and output points and return a function that will estimate an output given a scalar input. That is interpolator should be: interpolator(xs, ys) -> f(x) where f(x) is the interpolated value of y at x. \n\nBuilt in interpolators in Yields are: \n\nQuadraticSpline(): Quadratic spline interpolation.\nLinearSpline(): Linear spline interpolation.\n\nThe default is QuadraticSpline().\n\n\n\n\n\n","category":"function"},{"location":"api/#Yields.cashflows-Tuple{Any, Any, Any}","page":"API Reference","title":"Yields.cashflows","text":"cashflows(interests, maturities, frequency)\ntimepoints(zcq::Vector{ZeroCouponQuote})\ntimepoints(bbq::Vector{BulletBondQuote})\n\nProduce a cash flow matrix for a set of instruments with given interests and maturities and a given payment frequency frequency. All instruments are assumed to have their first payment at time 1/frequency and have their last payment at the largest multiple of 1/frequency less than or equal to the input maturity.\n\n\n\n\n\n","category":"method"},{"location":"api/#Yields.par-Tuple{Any, Any}","page":"API Reference","title":"Yields.par","text":"par(curve,time;frequency=2)\n\nCalculate the par yield for maturity time for the given curve and frequency. Returns a Rate object with periodicity corresponding to the frequency. The exception to this is if time is less than what the payments allowed by frequency (e.g. a time 0.5 but with frequency 1) will effectively assume frequency equal to 1 over time.\n\nExamples\n\njulia> c = Yields.Constant(0.04);\n\njulia> Yields.par(c,4)\nYields.Rate{Float64, Yields.Periodic}(0.03960780543711406, Yields.Periodic(2))\n\njulia> Yields.par(c,4;frequency=1)\nYields.Rate{Float64, Yields.Periodic}(0.040000000000000036, Yields.Periodic(1))\n\njulia> Yields.par(c,0.6;frequency=4)\nYields.Rate{Float64, Yields.Periodic}(0.039413626195875295, Yields.Periodic(4))\n\njulia> Yields.par(c,0.2;frequency=4)\nYields.Rate{Float64, Yields.Periodic}(0.039374942589460726, Yields.Periodic(5))\n\njulia> Yields.par(c,2.5)\nYields.Rate{Float64, Yields.Periodic}(0.03960780543711406, Yields.Periodic(2))\n\n\n\n\n\n","category":"method"},{"location":"api/#Yields.timepoints-Union{Tuple{Vector{Q}}, Tuple{Q}} where Q<:Yields.ObservableQuote","page":"API Reference","title":"Yields.timepoints","text":"timepoints(zcq::Vector{ZeroCouponQuote})\ntimepoints(bbq::Vector{BulletBondQuote})\n\nReturn the times associated with the cashflows of the instruments.\n\n\n\n\n\n","category":"method"},{"location":"developer/","page":"Developer Notes","title":"Developer Notes","text":"CurrentModule = Yields","category":"page"},{"location":"developer/#Developer-Notes","page":"Developer Notes","title":"Developer Notes","text":"","category":"section"},{"location":"developer/#Custom-Curve-Types","page":"Developer Notes","title":"Custom Curve Types","text":"","category":"section"},{"location":"developer/","page":"Developer Notes","title":"Developer Notes","text":"Types that subtype Yields.AbstractYieldCurve should implement a few key methods:","category":"page"},{"location":"developer/","page":"Developer Notes","title":"Developer Notes","text":"discount(curve,to) should return the discount factor for the given curve through time to","category":"page"},{"location":"developer/","page":"Developer Notes","title":"Developer Notes","text":"For example:","category":"page"},{"location":"developer/","page":"Developer Notes","title":"Developer Notes","text":"struct MyYield <: Yields.AbstractYieldCurve\n    rate\nend\n\nYields.discount(c::MyYield,to) = exp(-c.rate * to)","category":"page"},{"location":"developer/","page":"Developer Notes","title":"Developer Notes","text":"By defining the discount method as above and subtyping Yields.AbstractYieldCurve, Yields.jl has generic functions that will work:","category":"page"},{"location":"developer/","page":"Developer Notes","title":"Developer Notes","text":"zero(curve,to) returns the zero rate at time to\ndiscount(curve,from,to) is the discount factor between the two timepoints\nforward(curve,to) and forward(curve,from,to) is the forward zero rate\naccumulation(curve,to) and accumulation(curve,from,to) is the inverse of the discount factor.","category":"page"},{"location":"developer/","page":"Developer Notes","title":"Developer Notes","text":"If creating a new type of curve, you may find that it's most natural to define one of the functions versus the other, or that you may define specialized functions which are more performant than the generic implementations.","category":"page"},{"location":"developer/#__ratetype","page":"Developer Notes","title":"__ratetype","text":"","category":"section"},{"location":"developer/","page":"Developer Notes","title":"Developer Notes","text":"In some contexts, such as creating performant iteration of curves in EconomicScenarioGenerators.jl, Julia wants to know what type should be expected given an object type. For this reason, we define an internal, un-exported function which returns the Rate type expected given a Yield curve.","category":"page"},{"location":"developer/","page":"Developer Notes","title":"Developer Notes","text":"Sometimes it is most natural or convenient to expect a certain kind of Rate from a given curve. In many advanced use-cases (differentiation, stochastic rates), Continuous rates are most natural. For this reason, the DEFAULT_COMPOUNDING constant within Yields.jl is Yields.DEFAULT_COMPOUNDING. Two comments on this:","category":"page"},{"location":"developer/","page":"Developer Notes","title":"Developer Notes","text":"Becuase Yields.jl returns Rate types (e.g. Rate(0.05,Continuous()) instead of single scalars (e.g. 0.05) functions within the JuliaActuary universe (e.g. `ActuaryUtilities.present_value) know how to treat rates differently and in general users should not ever need to worry about converting between different compounding conventions.\nDevelopers implementing new AbstractYieldCurve types can define their own default. For example, using the MyYield example above:","category":"page"},{"location":"developer/","page":"Developer Notes","title":"Developer Notes","text":"__ratetype(::Type{MyYield}) = Yields.Rate{Float64, Continuous}","category":"page"},{"location":"developer/","page":"Developer Notes","title":"Developer Notes","text":"If the CompoundingFrequency is Continuous, then it's currently not necessary to define __ratetype, as it will fall back onto the generic method defined for AbstractYieldCurves.","category":"page"},{"location":"developer/","page":"Developer Notes","title":"Developer Notes","text":"If the preferred compounding frequency is Periodic, then you must either define the methods (zero, forward,...) for your type or to use the generic methods then you must define Yields.CompoundingFrequency(curve::MyCurve) to return the Periodic compounding datatype of the rates to return. ","category":"page"},{"location":"developer/","page":"Developer Notes","title":"Developer Notes","text":"For example, if we wanted MyCurve to return Periodic(1) rates, then we would define:","category":"page"},{"location":"developer/","page":"Developer Notes","title":"Developer Notes","text":"Yields.CompoundingFrequency(curve::MyCurve) = Periodic(1)","category":"page"},{"location":"developer/","page":"Developer Notes","title":"Developer Notes","text":"This latter step is necessary and distinct from __ratetype. This is due to __ratetype relying on type-only information. The Periodic type contains as a datafield the compounding frequency. Therefore, the frequency is not known to the type system and is available only at runtime. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Yields","category":"page"},{"location":"#Yields.jl","page":"Home","title":"Yields.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Yields.jl provides a simple interface for constructing, manipulating, and using yield curves for modeling purposes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It's intended to provide common functionality around modeling interest rates, spreads, and miscellaneous yields across the JuliaActuary ecosystem (though not limited to use in JuliaActuary packages).","category":"page"},{"location":"#QuickStart","page":"Home","title":"QuickStart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Yields\n\nriskfree_maturities = [0.5, 1.0, 1.5, 2.0]\nriskfree    = [5.0, 5.8, 6.4, 6.8] ./ 100     #spot rates, annual effective if unspecified\n\nspread_maturities = [0.5, 1.0, 1.5, 3.0]      # different maturities\nspread    = [1.0, 1.8, 1.4, 1.8] ./ 100       # spot spreads\n\nrf_curve = Yields.Zero(riskfree,riskfree_maturities)\nspread_curve = Yields.Zero(spread,spread_maturities)\n\n\nyield = rf_curve + spread_curve               # additive combination of the two curves\n\ndiscount(yield,1.5)                           # 1 / (1 + 0.064 + 0.014) ^ 1.5","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"#Rates","page":"Home","title":"Rates","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Rates are types that wrap scalar values to provide information about how to determine discount and accumulation factors.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are two CompoundingFrequency types:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Yields.Periodic(m) for rates that compound m times per period (e.g. m times per year if working with annual rates).\nYields.Continuous() for continuously compounding rates.","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Continuous(0.05)       # 5% continuously compounded\nPeriodic(0.05,2)       # 5% compounded twice per period","category":"page"},{"location":"","page":"Home","title":"Home","text":"These are both subtypes of the parent Rate type and are instantiated as:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Rate(0.05,Continuous())       # 5% continuously compounded\nRate(0.05,Periodic(2))        # 5% compounded twice per period","category":"page"},{"location":"","page":"Home","title":"Home","text":"Broadcast over a vector to create Rates with the given compounding:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Periodic.([0.02,0.03,0.04],2) \nContinuous.([0.02,0.03,0.04]) ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Rates can also be constructed by specifying the CompoundingFrequency and then passing a scalar rate:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Periodic(1)(0.05)\nContinuous()(0.05)","category":"page"},{"location":"#Conversion","page":"Home","title":"Conversion","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Convert rates between different types with convert. E.g.:","category":"page"},{"location":"","page":"Home","title":"Home","text":"r = Rate(Yields.Periodic(12),0.01)             # rate that compounds 12 times per rate period (ie monthly)\n\nconvert(Yields.Periodic(1),r)                  # convert monthly rate to annual effective\nconvert(Yields.Continuous(),r)          # convert monthly rate to continuous","category":"page"},{"location":"#Arithmetic","page":"Home","title":"Arithmetic","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Adding, substracting, and comparing rates is supported.","category":"page"},{"location":"#Curves","page":"Home","title":"Curves","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are a several ways to construct a yield curve object. If maturities is omitted, the method will assume that the timepoints corresponding to each rate are the indices of the rates (e.g. generally one to the length of the array for standard, non-offset arrays). ","category":"page"},{"location":"#Fitting-Curves-to-Rates","page":"Home","title":"Fitting Curves to Rates","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There is a set of constructor methods which will return a yield curve calibrated to the given inputs. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Yields.Zero(rates,maturities)  using a vector of zero rates (sometimes referred to as \"spot\" rates)\nYields.Forward(rates,maturities) using a vector of forward rates\nYields.Par(rates,maturities) takes a series of yields for securities priced at par. Assumes that maturities <= 1 year do not pay coupons and that after one year, pays coupons with frequency equal to the CompoundingFrequency of the corresponding rate (2 by default).\nYields.CMT(rates,maturities) takes the most commonly presented rate data (e.g. Treasury.gov) and bootstraps the curve given the combination of bills and bonds.\nYields.OIS(rates,maturities) takes the most commonly presented rate data for overnight swaps and bootstraps the curve. Rates assume a single settlement for <1 year and quarterly settlements for 1 year and above.","category":"page"},{"location":"#Fitting-techniques","page":"Home","title":"Fitting techniques","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are multiple curve fitting methods available:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Boostrap(interpolation_method) (the default method)\nwhere interpolation can be one of the built-in QuadraticSpline() (the default) or LinearSpline(), or a user-supplied function.\nTwo methods from the Nelson-Siegel-Svensson family, where τ_initial is the starting τ point for the fitting optimization routine: \nNelsonSiegel(τ_initial=1.0)\nNelsonSiegelSvensson(τ_initial=[1.0,1.0])","category":"page"},{"location":"","page":"Home","title":"Home","text":"To specify which fitting method to use, pass the object to as the first parameter to the above set of constructors, for example: Yields.Par(NelsonSiegel(),rates,maturities).","category":"page"},{"location":"#Kernel-Methods","page":"Home","title":"Kernel Methods","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Yields.SmithWilson curve (used for discounting in the EU Solvency II framework) can be constructed either directly by specifying its inner representation or by calibrating to a set of cashflows with known prices.\nThese cashflows can conveniently be constructed with a Vector of Yields.ZeroCouponQuotes, Yields.SwapQuotes, or Yields.BulletBondQuotes.","category":"page"},{"location":"#Other-Curves","page":"Home","title":"Other Curves","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Yields.Constant(rate) takes a single constant rate for all times\nYields.Step(rates,maturities) doesn't interpolate - the rate is flat up to the corresponding time in times","category":"page"},{"location":"#Functions","page":"Home","title":"Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Most of the above yields have the following defined (goal is to have them all):","category":"page"},{"location":"","page":"Home","title":"Home","text":"discount(curve,from,to) or discount(curve,to) gives the discount factor\naccumulation(curve,from,to) or accumulation(curve,to) gives the accumulation factor\nzero(curve,time) or zero(curve,time,CompoundingFrequency) gives the zero-coupon spot rate for the given time.\nforward(curve,from,to) gives the zero rate between the two given times\npar(curve,time) gives the coupon-paying par equivalent rate for the given time.","category":"page"},{"location":"#Combinations","page":"Home","title":"Combinations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Different yield objects can be combined with addition or subtraction. See the Quickstart for an example.","category":"page"},{"location":"","page":"Home","title":"Home","text":"When adding a Yields.AbstractYield with a scalar or vector, that scalar or vector will be promoted to a yield type via Yield(). For example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"y1 = Yields.Constant(0.05)\ny2 = y1 + 0.01                # y2 is a yield of 0.06","category":"page"},{"location":"#Forward-Starting-Curves","page":"Home","title":"Forward Starting Curves","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Constructed curves can be shifted so that a future timepoint becomes the effective time-zero for a said curve.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> zero = [5.0, 5.8, 6.4, 6.8] ./ 100\njulia> maturity = [0.5, 1.0, 1.5, 2.0]\njulia> curve = Yields.Zero(zero, maturity)\njulia> fwd = Yields.ForwardStarting(curve, 1.0)\n\njulia> discount(curve,1,2)\n0.9275624570410582\n\njulia> discount(fwd,1) # `curve` has effectively been reindexed to `1.0`\n0.9275624570410582","category":"page"},{"location":"#Exported-vs-Un-exported-Functions","page":"Home","title":"Exported vs Un-exported Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Generally, CamelCase methods which construct a datatype are exported as they are unlikely to conflict with other parts of code that may be written. For example, rate is un-exported (it must be called with Yields.rate(...)) because rate is likely a very commonly defined variable within actuarial and financial contexts and there is a high risk of conflicting with defined variables.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Consider using import Yields which would require qualifying all methods, but alleviates any namespace conflicts and has the benefit of being explicit about the calls (internally we prefer this in the package design to keep dependencies and their usage clear). ","category":"page"},{"location":"#Internals","page":"Home","title":"Internals","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For time-variant yields (ie yield curves), the inputs are converted to spot rates and interpolated using quadratic B-splines by default (see documentation for alternatives, such as linear interpolations).","category":"page"},{"location":"#Combination-Implementation","page":"Home","title":"Combination Implementation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Combinations track two different curve objects and are not combined into a single underlying data structure. This means that you may achieve better performance if you combine the rates before constructing a Yields representation. The exception to this is Constant curves, which do get combined into a single structure that is as performant as pre-combined rate structure.","category":"page"},{"location":"#Related-Packages","page":"Home","title":"Related Packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"InterestRates.jl specializes in fast rate calculations aimed at valuing fixed income contracts, with business-day-level accuracy.\nComparative comments: Yields.jl does not try to provide as precise controls over the timing, structure, and interpolation of the curve. Instead, Yields.jl provides a minimal, but flexible and intuitive interface for common modeling needs.","category":"page"}]
}
